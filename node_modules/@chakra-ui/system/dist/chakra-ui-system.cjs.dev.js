'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var colorMode = require('@chakra-ui/color-mode');
var styledSystem = require('@chakra-ui/styled-system');
var react = require('@emotion/react');
var utils = require('@chakra-ui/utils');
var React = require('react');
var isEqual = require('react-fast-compare');
var reactUtils = require('@chakra-ui/react-utils');
var _styled = require('@emotion/styled');

function _interopDefault (e) { return e && e.__esModule ? e : { 'default': e }; }

function _interopNamespace(e) {
  if (e && e.__esModule) return e;
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n["default"] = e;
  return Object.freeze(n);
}

var React__namespace = /*#__PURE__*/_interopNamespace(React);
var isEqual__default = /*#__PURE__*/_interopDefault(isEqual);
var _styled__default = /*#__PURE__*/_interopDefault(_styled);

const ThemeProvider = props => {
  const {
    cssVarsRoot = ":host, :root",
    theme,
    children
  } = props;
  const computedTheme = React__namespace.useMemo(() => styledSystem.toCSSVar(theme), [theme]);
  return /*#__PURE__*/React__namespace.createElement(react.ThemeProvider, {
    theme: computedTheme
  }, /*#__PURE__*/React__namespace.createElement(react.Global, {
    styles: theme => ({
      [cssVarsRoot]: theme.__cssVars
    })
  }), children);
};
function useTheme() {
  const theme = React__namespace.useContext(react.ThemeContext);

  if (!theme) {
    throw Error("useTheme: `theme` is undefined. Seems you forgot to wrap your app in `<ChakraProvider />` or `<ThemeProvider />`");
  }

  return theme;
}
const [StylesProvider, useStyles] = reactUtils.createContext({
  name: "StylesContext",
  errorMessage: "useStyles: `styles` is undefined. Seems you forgot to wrap the components in `<StylesProvider />` "
});
/**
 * Applies styles defined in `theme.styles.global` globally
 * using emotion's `Global` component
 */

const GlobalStyle = () => {
  const {
    colorMode: colorMode$1
  } = colorMode.useColorMode();
  return /*#__PURE__*/React__namespace.createElement(react.Global, {
    styles: theme => {
      const styleObjectOrFn = utils.memoizedGet(theme, "styles.global");
      const globalStyles = utils.runIfFn(styleObjectOrFn, {
        theme,
        colorMode: colorMode$1
      });
      if (!globalStyles) return undefined;
      const styles = styledSystem.css(globalStyles)(theme);
      return styles;
    }
  });
};

/**
 * Carefully selected html elements for chakra components.
 * This is mostly for `chakra.<element>` syntax.
 */
const domElements = ["a", "b", "article", "aside", "blockquote", "button", "caption", "cite", "circle", "code", "dd", "div", "dl", "dt", "fieldset", "figcaption", "figure", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "header", "hr", "img", "input", "kbd", "label", "li", "main", "mark", "nav", "ol", "p", "path", "pre", "q", "rect", "s", "svg", "section", "select", "strong", "small", "span", "sub", "sup", "table", "tbody", "td", "textarea", "tfoot", "th", "thead", "tr", "ul"];
function omitThemingProps(props) {
  return utils.omit(props, ["styleConfig", "size", "variant", "colorScheme"]);
}

function useChakra() {
  const colorModeResult = colorMode.useColorMode();
  const theme = useTheme();
  return { ...colorModeResult,
    theme
  };
} // inspired from ./css.ts : resolveTokenValue

const resolveTokenValue = (theme, tokenValue, fallbackValue) => {
  if (tokenValue == null) return tokenValue;

  const getValue = val => theme.__cssMap?.[val]?.value;

  return getValue(tokenValue) ?? getValue(fallbackValue) ?? fallbackValue;
};

function useToken(scale, token, fallback) {
  const theme = useTheme();

  if (Array.isArray(token)) {
    let fallbackArr = [];

    if (fallback) {
      fallbackArr = Array.isArray(fallback) ? fallback : [fallback];
    }

    return token.map((token, index) => {
      const path = `${scale}.${token}`;
      return resolveTokenValue(theme, path, fallbackArr[index] ?? token);
    });
  }

  const path = `${scale}.${token}`;
  return resolveTokenValue(theme, path, fallback);
}
function useProps(themeKey, props) {
  const {
    theme,
    colorMode
  } = useChakra();
  const styleConfig = props.styleConfig || theme.components?.[themeKey];
  const defaultProps = styleConfig?.defaultProps ?? {};
  const propsWithDefault = { ...defaultProps,
    ...utils.filterUndefined(props)
  };
  const stylesRef = React.useRef({});
  const mergedProps = utils.mergeWith({}, propsWithDefault, {
    theme,
    colorMode
  });
  const memoizedStyles = React.useMemo(() => {
    if (styleConfig) {
      const baseStyles = utils.runIfFn(styleConfig.baseStyle ?? {}, mergedProps);
      const variants = utils.runIfFn(styleConfig.variants?.[mergedProps.variant] ?? {}, mergedProps);
      const sizes = utils.runIfFn(styleConfig.sizes?.[mergedProps.size] ?? {}, mergedProps);
      const styles = utils.mergeWith(baseStyles, sizes, variants);

      if (styleConfig.parts) {
        styleConfig.parts.forEach(part => {
          styles[part] = styles[part] ?? {};
        });
      }

      const isStyleEqual = isEqual__default["default"](stylesRef.current, styles);

      if (!isStyleEqual) {
        stylesRef.current = styles;
      }
    }

    return stylesRef.current;
  }, [styleConfig, mergedProps]);
  return {
    styles: memoizedStyles,
    props: omitThemingProps(propsWithDefault)
  };
}

/**
 * List of props for emotion to omit from DOM.
 * It mostly consists of Chakra props
 */

const allPropNames = new Set([...styledSystem.propNames, "textStyle", "layerStyle", "apply", "isTruncated", "noOfLines", "focusBorderColor", "errorBorderColor", "as", "__css", "css", "sx"]);
/**
 * htmlWidth and htmlHeight is used in the <Image />
 * component to support the native `width` and `height` attributes
 *
 * https://github.com/chakra-ui/chakra-ui/issues/149
 */

const validHTMLProps = new Set(["htmlWidth", "htmlHeight", "htmlSize"]);
const shouldForwardProp = prop => validHTMLProps.has(prop) || !allPropNames.has(prop);

/**
 * Style resolver function that manages how style props are merged
 * in combination with other possible ways of defining styles.
 *
 * For example, take a component defined this way:
 * ```jsx
 * <Box fontSize="24px" sx={{ fontSize: "40px" }}></Box>
 * ```
 *
 * We want to manage the priority of the styles properly to prevent unwanted
 * behaviors. Right now, the `sx` prop has the highest priority so the resolved
 * fontSize will be `40px`
 */
const toCSSObject = ({
  baseStyle
}) => props => {
  const {
    theme,
    css: cssProp,
    __css,
    sx,
    ...rest
  } = props;
  const styleProps = utils.objectFilter(rest, (_, prop) => styledSystem.isStyleProp(prop));
  const finalBaseStyle = utils.runIfFn(baseStyle, props);
  const finalStyles = Object.assign({}, __css, finalBaseStyle, utils.filterUndefined(styleProps), sx);
  const computedCSS = styledSystem.css(finalStyles)(props.theme);
  return cssProp ? [computedCSS, cssProp] : computedCSS;
};
function styled(component, options) {
  const {
    baseStyle,
    ...styledOptions
  } = options ?? {};

  if (!styledOptions.shouldForwardProp) {
    styledOptions.shouldForwardProp = shouldForwardProp;
  }

  const styleObject = toCSSObject({
    baseStyle
  });
  return _styled__default["default"](component, styledOptions)(styleObject);
}
const chakra = styled;
domElements.forEach(tag => {
  chakra[tag] = chakra(tag);
});

/**
 * All credit goes to Chance (Reach UI), Haz (Reakit) and (fluentui)
 * for creating the base type definitions upon which we improved on
 */
function forwardRef(component) {
  return /*#__PURE__*/React__namespace.forwardRef(component);
}

function useStyleConfig(themeKey, props = {}, opts = {}) {
  const {
    styleConfig: styleConfigProp,
    ...rest
  } = props;
  const {
    theme,
    colorMode
  } = useChakra();
  const themeStyleConfig = utils.memoizedGet(theme, `components.${themeKey}`);
  const styleConfig = styleConfigProp || themeStyleConfig;
  const mergedProps = utils.mergeWith({
    theme,
    colorMode
  }, styleConfig?.defaultProps ?? {}, utils.filterUndefined(utils.omit(rest, ["children"])));
  /**
   * Store the computed styles in a `ref` to avoid unneeded re-computation
   */

  const stylesRef = React.useRef({});

  if (styleConfig) {
    const baseStyles = utils.runIfFn(styleConfig.baseStyle ?? {}, mergedProps);
    const variants = utils.runIfFn(styleConfig.variants?.[mergedProps.variant] ?? {}, mergedProps);
    const sizes = utils.runIfFn(styleConfig.sizes?.[mergedProps.size] ?? {}, mergedProps);
    const styles = utils.mergeWith({}, baseStyles, sizes, variants);

    if (opts?.isMultiPart && styleConfig.parts) {
      styleConfig.parts.forEach(part => {
        styles[part] = styles[part] ?? {};
      });
    }

    const isStyleEqual = isEqual__default["default"](stylesRef.current, styles);

    if (!isStyleEqual) {
      stylesRef.current = styles;
    }
  }

  return stylesRef.current;
}
function useMultiStyleConfig(themeKey, props) {
  return useStyleConfig(themeKey, props, {
    isMultiPart: true
  });
}

Object.defineProperty(exports, 'keyframes', {
  enumerable: true,
  get: function () { return react.keyframes; }
});
exports.GlobalStyle = GlobalStyle;
exports.StylesProvider = StylesProvider;
exports.ThemeProvider = ThemeProvider;
exports.chakra = chakra;
exports.forwardRef = forwardRef;
exports.omitThemingProps = omitThemingProps;
exports.shouldForwardProp = shouldForwardProp;
exports.styled = styled;
exports.toCSSObject = toCSSObject;
exports.useChakra = useChakra;
exports.useMultiStyleConfig = useMultiStyleConfig;
exports.useProps = useProps;
exports.useStyleConfig = useStyleConfig;
exports.useStyles = useStyles;
exports.useTheme = useTheme;
exports.useToken = useToken;
Object.keys(colorMode).forEach(function (k) {
  if (k !== 'default' && !exports.hasOwnProperty(k)) Object.defineProperty(exports, k, {
    enumerable: true,
    get: function () { return colorMode[k]; }
  });
});
Object.keys(styledSystem).forEach(function (k) {
  if (k !== 'default' && !exports.hasOwnProperty(k)) Object.defineProperty(exports, k, {
    enumerable: true,
    get: function () { return styledSystem[k]; }
  });
});

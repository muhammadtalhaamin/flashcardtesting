import { useColorMode } from '@chakra-ui/color-mode';
export * from '@chakra-ui/color-mode';
import { toCSSVar, css, propNames, isStyleProp } from '@chakra-ui/styled-system';
export * from '@chakra-ui/styled-system';
import { ThemeProvider as ThemeProvider$1, Global, ThemeContext } from '@emotion/react';
export { keyframes } from '@emotion/react';
import { memoizedGet, runIfFn, omit, filterUndefined, mergeWith, objectFilter } from '@chakra-ui/utils';
import * as React from 'react';
import { useRef, useMemo } from 'react';
import isEqual from 'react-fast-compare';
import { createContext } from '@chakra-ui/react-utils';
import _styled from '@emotion/styled';

const ThemeProvider = props => {
  const {
    cssVarsRoot = ":host, :root",
    theme,
    children
  } = props;
  const computedTheme = React.useMemo(() => toCSSVar(theme), [theme]);
  return /*#__PURE__*/React.createElement(ThemeProvider$1, {
    theme: computedTheme
  }, /*#__PURE__*/React.createElement(Global, {
    styles: theme => ({
      [cssVarsRoot]: theme.__cssVars
    })
  }), children);
};
function useTheme() {
  const theme = React.useContext(ThemeContext);

  if (!theme) {
    throw Error("useTheme: `theme` is undefined. Seems you forgot to wrap your app in `<ChakraProvider />` or `<ThemeProvider />`");
  }

  return theme;
}
const [StylesProvider, useStyles] = createContext({
  name: "StylesContext",
  errorMessage: "useStyles: `styles` is undefined. Seems you forgot to wrap the components in `<StylesProvider />` "
});
/**
 * Applies styles defined in `theme.styles.global` globally
 * using emotion's `Global` component
 */

const GlobalStyle = () => {
  const {
    colorMode
  } = useColorMode();
  return /*#__PURE__*/React.createElement(Global, {
    styles: theme => {
      const styleObjectOrFn = memoizedGet(theme, "styles.global");
      const globalStyles = runIfFn(styleObjectOrFn, {
        theme,
        colorMode
      });
      if (!globalStyles) return undefined;
      const styles = css(globalStyles)(theme);
      return styles;
    }
  });
};

/**
 * Carefully selected html elements for chakra components.
 * This is mostly for `chakra.<element>` syntax.
 */
const domElements = ["a", "b", "article", "aside", "blockquote", "button", "caption", "cite", "circle", "code", "dd", "div", "dl", "dt", "fieldset", "figcaption", "figure", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "header", "hr", "img", "input", "kbd", "label", "li", "main", "mark", "nav", "ol", "p", "path", "pre", "q", "rect", "s", "svg", "section", "select", "strong", "small", "span", "sub", "sup", "table", "tbody", "td", "textarea", "tfoot", "th", "thead", "tr", "ul"];
function omitThemingProps(props) {
  return omit(props, ["styleConfig", "size", "variant", "colorScheme"]);
}

function useChakra() {
  const colorModeResult = useColorMode();
  const theme = useTheme();
  return { ...colorModeResult,
    theme
  };
} // inspired from ./css.ts : resolveTokenValue

const resolveTokenValue = (theme, tokenValue, fallbackValue) => {
  if (tokenValue == null) return tokenValue;

  const getValue = val => theme.__cssMap?.[val]?.value;

  return getValue(tokenValue) ?? getValue(fallbackValue) ?? fallbackValue;
};

function useToken(scale, token, fallback) {
  const theme = useTheme();

  if (Array.isArray(token)) {
    let fallbackArr = [];

    if (fallback) {
      fallbackArr = Array.isArray(fallback) ? fallback : [fallback];
    }

    return token.map((token, index) => {
      const path = `${scale}.${token}`;
      return resolveTokenValue(theme, path, fallbackArr[index] ?? token);
    });
  }

  const path = `${scale}.${token}`;
  return resolveTokenValue(theme, path, fallback);
}
function useProps(themeKey, props) {
  const {
    theme,
    colorMode
  } = useChakra();
  const styleConfig = props.styleConfig || theme.components?.[themeKey];
  const defaultProps = styleConfig?.defaultProps ?? {};
  const propsWithDefault = { ...defaultProps,
    ...filterUndefined(props)
  };
  const stylesRef = useRef({});
  const mergedProps = mergeWith({}, propsWithDefault, {
    theme,
    colorMode
  });
  const memoizedStyles = useMemo(() => {
    if (styleConfig) {
      const baseStyles = runIfFn(styleConfig.baseStyle ?? {}, mergedProps);
      const variants = runIfFn(styleConfig.variants?.[mergedProps.variant] ?? {}, mergedProps);
      const sizes = runIfFn(styleConfig.sizes?.[mergedProps.size] ?? {}, mergedProps);
      const styles = mergeWith(baseStyles, sizes, variants);

      if (styleConfig.parts) {
        styleConfig.parts.forEach(part => {
          styles[part] = styles[part] ?? {};
        });
      }

      const isStyleEqual = isEqual(stylesRef.current, styles);

      if (!isStyleEqual) {
        stylesRef.current = styles;
      }
    }

    return stylesRef.current;
  }, [styleConfig, mergedProps]);
  return {
    styles: memoizedStyles,
    props: omitThemingProps(propsWithDefault)
  };
}

/**
 * List of props for emotion to omit from DOM.
 * It mostly consists of Chakra props
 */

const allPropNames = new Set([...propNames, "textStyle", "layerStyle", "apply", "isTruncated", "noOfLines", "focusBorderColor", "errorBorderColor", "as", "__css", "css", "sx"]);
/**
 * htmlWidth and htmlHeight is used in the <Image />
 * component to support the native `width` and `height` attributes
 *
 * https://github.com/chakra-ui/chakra-ui/issues/149
 */

const validHTMLProps = new Set(["htmlWidth", "htmlHeight", "htmlSize"]);
const shouldForwardProp = prop => validHTMLProps.has(prop) || !allPropNames.has(prop);

/**
 * Style resolver function that manages how style props are merged
 * in combination with other possible ways of defining styles.
 *
 * For example, take a component defined this way:
 * ```jsx
 * <Box fontSize="24px" sx={{ fontSize: "40px" }}></Box>
 * ```
 *
 * We want to manage the priority of the styles properly to prevent unwanted
 * behaviors. Right now, the `sx` prop has the highest priority so the resolved
 * fontSize will be `40px`
 */
const toCSSObject = ({
  baseStyle
}) => props => {
  const {
    theme,
    css: cssProp,
    __css,
    sx,
    ...rest
  } = props;
  const styleProps = objectFilter(rest, (_, prop) => isStyleProp(prop));
  const finalBaseStyle = runIfFn(baseStyle, props);
  const finalStyles = Object.assign({}, __css, finalBaseStyle, filterUndefined(styleProps), sx);
  const computedCSS = css(finalStyles)(props.theme);
  return cssProp ? [computedCSS, cssProp] : computedCSS;
};
function styled(component, options) {
  const {
    baseStyle,
    ...styledOptions
  } = options ?? {};

  if (!styledOptions.shouldForwardProp) {
    styledOptions.shouldForwardProp = shouldForwardProp;
  }

  const styleObject = toCSSObject({
    baseStyle
  });
  return _styled(component, styledOptions)(styleObject);
}
const chakra = styled;
domElements.forEach(tag => {
  chakra[tag] = chakra(tag);
});

/**
 * All credit goes to Chance (Reach UI), Haz (Reakit) and (fluentui)
 * for creating the base type definitions upon which we improved on
 */
function forwardRef(component) {
  return /*#__PURE__*/React.forwardRef(component);
}

function useStyleConfig(themeKey, props = {}, opts = {}) {
  const {
    styleConfig: styleConfigProp,
    ...rest
  } = props;
  const {
    theme,
    colorMode
  } = useChakra();
  const themeStyleConfig = memoizedGet(theme, `components.${themeKey}`);
  const styleConfig = styleConfigProp || themeStyleConfig;
  const mergedProps = mergeWith({
    theme,
    colorMode
  }, styleConfig?.defaultProps ?? {}, filterUndefined(omit(rest, ["children"])));
  /**
   * Store the computed styles in a `ref` to avoid unneeded re-computation
   */

  const stylesRef = useRef({});

  if (styleConfig) {
    const baseStyles = runIfFn(styleConfig.baseStyle ?? {}, mergedProps);
    const variants = runIfFn(styleConfig.variants?.[mergedProps.variant] ?? {}, mergedProps);
    const sizes = runIfFn(styleConfig.sizes?.[mergedProps.size] ?? {}, mergedProps);
    const styles = mergeWith({}, baseStyles, sizes, variants);

    if (opts?.isMultiPart && styleConfig.parts) {
      styleConfig.parts.forEach(part => {
        styles[part] = styles[part] ?? {};
      });
    }

    const isStyleEqual = isEqual(stylesRef.current, styles);

    if (!isStyleEqual) {
      stylesRef.current = styles;
    }
  }

  return stylesRef.current;
}
function useMultiStyleConfig(themeKey, props) {
  return useStyleConfig(themeKey, props, {
    isMultiPart: true
  });
}

export { GlobalStyle, StylesProvider, ThemeProvider, chakra, forwardRef, omitThemingProps, shouldForwardProp, styled, toCSSObject, useChakra, useMultiStyleConfig, useProps, useStyleConfig, useStyles, useTheme, useToken };

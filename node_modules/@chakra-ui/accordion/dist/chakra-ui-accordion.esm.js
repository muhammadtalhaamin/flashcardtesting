import { Icon } from '@chakra-ui/icon';
import { forwardRef, useMultiStyleConfig, omitThemingProps, StylesProvider, chakra, useStyles } from '@chakra-ui/system';
import { Collapse } from '@chakra-ui/transition';
import { normalizeEventKey, callAllHandlers, isUndefined, isArray, warn, addItem, removeItem, focus, cx, __DEV__, runIfFn } from '@chakra-ui/utils';
import { createContext, mergeRefs } from '@chakra-ui/react-utils';
import * as React from 'react';
import { useState, useRef, useCallback } from 'react';
import { createDescendantContext } from '@chakra-ui/descendant';
import { useUnmountEffect, useControllableState, useIds } from '@chakra-ui/hooks';

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

/* -------------------------------------------------------------------------------------------------
 * Create context to track descendants and their indices
 * -----------------------------------------------------------------------------------------------*/

const [AccordionDescendantsProvider, useAccordionDescendantsContext, useAccordionDescendants, useAccordionDescendant] = createDescendantContext();
/* -------------------------------------------------------------------------------------------------
 * useAccordion - The root react hook that manages all accordion items
 * -----------------------------------------------------------------------------------------------*/

/**
 * useAccordion hook provides all the state and focus management logic
 * for accordion items.
 */
function useAccordion(props) {
  const {
    onChange,
    defaultIndex,
    index: indexProp,
    allowMultiple,
    allowToggle,
    ...htmlProps
  } = props; // validate the props and `warn` if used incorrectly

  allowMultipleWarning(props);
  allowMultipleAndAllowToggleWarning(props);
  /**
   * Think of this as the register to each accordion item.
   * We used to manage focus between accordion item buttons.
   *
   * Every accordion item, registers their button refs in this context
   */

  const descendants = useAccordionDescendants();
  /**
   * This state is used to track the index focused accordion
   * button when click on the button, tab on the button, or
   * use the down/up arrow to navigate.
   */

  const [focusedIndex, setFocusedIndex] = useState(-1);
  /**
   * Reset focused index when accordion unmounts
   * or descendants change
   */

  useUnmountEffect(() => {
    setFocusedIndex(-1);
  });
  /**
   * Hook that manages the controlled and un-controlled state
   * for the accordion.
   */

  const [index, setIndex] = useControllableState({
    value: indexProp,

    defaultValue() {
      if (allowMultiple) return defaultIndex ?? [];
      return defaultIndex ?? -1;
    },

    onChange
  });
  /**
   * Gets the `isOpen` and `onChange` props for a child accordion item based on
   * the child's index.
   *
   * @param idx {number} The index of the child accordion item
   */

  const getAccordionItemProps = idx => {
    let isOpen = false;

    if (idx !== null) {
      isOpen = isArray(index) ? index.includes(idx) : index === idx;
    }

    const onChange = isOpen => {
      if (idx === null) return;

      if (allowMultiple && isArray(index)) {
        const nextState = isOpen ? addItem(index, idx) : removeItem(index, idx);
        setIndex(nextState);
      } else if (isOpen) {
        setIndex(idx);
      } else if (allowToggle) {
        setIndex(-1);
      }
    };

    return {
      isOpen,
      onChange
    };
  };

  return {
    index,
    setIndex,
    htmlProps,
    getAccordionItemProps,
    focusedIndex,
    setFocusedIndex,
    descendants
  };
}
const [AccordionProvider, useAccordionContext] = createContext({
  name: "AccordionContext",
  errorMessage: "useAccordionContext: `context` is undefined. Seems you forgot to wrap the accordion components in `<Accordion />`"
});
/* -------------------------------------------------------------------------------------------------
 * Hook for a single accordion item
 * -----------------------------------------------------------------------------------------------*/

/**
 * useAccordionItem
 *
 * React hook that provides the open/close functionality
 * for an accordion item and its children
 */
function useAccordionItem(props) {
  const {
    isDisabled,
    isFocusable,
    id,
    ...htmlProps
  } = props;
  const {
    getAccordionItemProps,
    setFocusedIndex
  } = useAccordionContext();
  const buttonRef = useRef(null);
  /**
   * Generate unique ids for all accordion item components (button and panel)
   */

  const [buttonId, panelId] = useIds(id, `accordion-button`, `accordion-panel`);
  focusableNotDisabledWarning(props);
  /**
   * Think of this as a way to register this accordion item
   * with its parent `useAccordion`
   */

  const {
    register,
    index,
    descendants
  } = useAccordionDescendant({
    disabled: isDisabled && !isFocusable
  });
  const {
    isOpen,
    onChange
  } = getAccordionItemProps(index === -1 ? null : index);
  warnIfOpenAndDisabled({
    isOpen,
    isDisabled
  });

  const onOpen = () => {
    onChange?.(true);
  };

  const onClose = () => {
    onChange?.(false);
  };
  /**
   * Toggle the visibility of the accordion item
   */


  const onClick = useCallback(() => {
    onChange?.(!isOpen);
    setFocusedIndex(index);
  }, [index, setFocusedIndex, isOpen, onChange]);
  /**
   * Manage keyboard navigation between accordion items.
   */

  const onKeyDown = useCallback(event => {
    const eventKey = normalizeEventKey(event);
    const keyMap = {
      ArrowDown: () => {
        const next = descendants.nextEnabled(index);
        if (next) focus(next.node);
      },
      ArrowUp: () => {
        const prev = descendants.prevEnabled(index);
        if (prev) focus(prev.node);
      },
      Home: () => {
        const first = descendants.firstEnabled();
        if (first) focus(first.node);
      },
      End: () => {
        const last = descendants.lastEnabled();
        if (last) focus(last.node);
      }
    };
    const action = keyMap[eventKey];

    if (action) {
      event.preventDefault();
      action(event);
    }
  }, [descendants, index]);
  /**
   * Since each accordion item's button still remains tabbable, let's
   * update the focusedIndex when it receives focus
   */

  const onFocus = useCallback(() => {
    setFocusedIndex(index);
  }, [setFocusedIndex, index]);
  const getButtonProps = useCallback((props = {}, ref = null) => ({ ...props,
    type: "button",
    ref: mergeRefs(register, buttonRef, ref),
    id: buttonId,
    disabled: !!isDisabled,
    "aria-expanded": !!isOpen,
    "aria-controls": panelId,
    onClick: callAllHandlers(props.onClick, onClick),
    onFocus: callAllHandlers(props.onFocus, onFocus),
    onKeyDown: callAllHandlers(props.onKeyDown, onKeyDown)
  }), [buttonId, isDisabled, isOpen, onClick, onFocus, onKeyDown, panelId, register]);
  const getPanelProps = useCallback((props = {}, ref = null) => ({ ...props,
    ref,
    role: "region",
    id: panelId,
    "aria-labelledby": buttonId,
    hidden: !isOpen
  }), [buttonId, isOpen, panelId]);
  return {
    isOpen,
    isDisabled,
    isFocusable,
    onOpen,
    onClose,
    getButtonProps,
    getPanelProps,
    htmlProps
  };
}

/* -------------------------------------------------------------------------------------------------
 * Validate accordion and accordion item props, and emit warnings.
 * -----------------------------------------------------------------------------------------------*/
function allowMultipleWarning(props) {
  const index = props.index || props.defaultIndex;
  const condition = !isUndefined(index) && !isArray(index) && props.allowMultiple;
  warn({
    condition: !!condition,
    message: `If 'allowMultiple' is passed, then 'index' or 'defaultIndex' must be an array. You passed: ${typeof index},`
  });
}

function allowMultipleAndAllowToggleWarning(props) {
  warn({
    condition: !!(props.allowMultiple && props.allowToggle),
    message: `If 'allowMultiple' is passed, 'allowToggle' will be ignored. Either remove 'allowToggle' or 'allowMultiple' depending on whether you want multiple accordions visible or not`
  });
}

function focusableNotDisabledWarning(props) {
  warn({
    condition: !!(props.isFocusable && !props.isDisabled),
    message: `Using only 'isFocusable', this prop is reserved for situations where you pass 'isDisabled' but you still want the element to receive focus (A11y). Either remove it or pass 'isDisabled' as well.
    `
  });
}

function warnIfOpenAndDisabled(props) {
  warn({
    condition: props.isOpen && !!props.isDisabled,
    message: "Cannot open a disabled accordion item"
  });
}

/* -------------------------------------------------------------------------------------------------
 * Accordion - The wrapper that provides context for all accordion items
 * -----------------------------------------------------------------------------------------------*/

/**
 * The wrapper that provides context and focus management
 * for all accordion items.
 *
 * It wraps all accordion items in a `div` for better grouping.
 * @see Docs https://chakra-ui.com/accordion
 */
const Accordion = /*#__PURE__*/forwardRef(({
  children,
  reduceMotion,
  ...props
}, ref) => {
  const styles = useMultiStyleConfig("Accordion", props);
  const ownProps = omitThemingProps(props);
  const {
    htmlProps,
    descendants,
    ...context
  } = useAccordion(ownProps);
  const ctx = React.useMemo(() => ({ ...context,
    reduceMotion: !!reduceMotion
  }), [context, reduceMotion]);
  return /*#__PURE__*/React.createElement(AccordionDescendantsProvider, {
    value: descendants
  }, /*#__PURE__*/React.createElement(AccordionProvider, {
    value: ctx
  }, /*#__PURE__*/React.createElement(StylesProvider, {
    value: styles
  }, /*#__PURE__*/React.createElement(chakra.div, _extends({
    ref: ref
  }, htmlProps, {
    className: cx("chakra-accordion", props.className)
  }), children))));
});

if (__DEV__) {
  Accordion.displayName = "Accordion";
}
/* -------------------------------------------------------------------------------------------------
 * Accordion Item
 * -----------------------------------------------------------------------------------------------*/


const [AccordionItemProvider, useAccordionItemContext] = createContext({
  name: "AccordionItemContext",
  errorMessage: "useAccordionItemContext: `context` is undefined. Seems you forgot to wrap the accordion item parts in `<AccordionItem />` "
});

/**
 * AccordionItem is a single accordion that provides the open-close
 * behavior when the accordion button is clicked.
 *
 * It also provides context for the accordion button and panel.
 */
const AccordionItem = /*#__PURE__*/forwardRef((props, ref) => {
  const {
    children,
    className
  } = props;
  const {
    htmlProps,
    ...context
  } = useAccordionItem(props);
  const styles = useStyles();
  const containerStyles = { ...styles.container,
    overflowAnchor: "none"
  };
  const ctx = React.useMemo(() => context, [context]);
  return /*#__PURE__*/React.createElement(AccordionItemProvider, {
    value: ctx
  }, /*#__PURE__*/React.createElement(chakra.div, _extends({
    ref: ref
  }, htmlProps, {
    className: cx("chakra-accordion__item", className),
    __css: containerStyles
  }), runIfFn(children, {
    isExpanded: !!context.isOpen,
    isDisabled: !!context.isDisabled
  })));
});

if (__DEV__) {
  AccordionItem.displayName = "AccordionItem";
}
/**
 * React hook to get the state and actions of an accordion item
 */


function useAccordionItemState() {
  const {
    isOpen,
    isDisabled,
    onClose,
    onOpen
  } = useAccordionItemContext();
  return {
    isOpen,
    onClose,
    isDisabled,
    onOpen
  };
}
/* -------------------------------------------------------------------------------------------------
 * Accordion Item => Button
 * -----------------------------------------------------------------------------------------------*/

/**
 * AccordionButton is used expands and collapses an accordion item.
 * It must be a child of `AccordionItem`.
 *
 * Note 🚨: Each accordion button must be wrapped in an heading tag,
 * that is appropriate for the information architecture of the page.
 */
const AccordionButton = /*#__PURE__*/forwardRef((props, ref) => {
  const {
    getButtonProps
  } = useAccordionItemContext();
  const buttonProps = getButtonProps(props, ref);
  const styles = useStyles();
  const buttonStyles = {
    display: "flex",
    alignItems: "center",
    width: "100%",
    outline: 0,
    ...styles.button
  };
  return /*#__PURE__*/React.createElement(chakra.button, _extends({}, buttonProps, {
    className: cx("chakra-accordion__button", props.className),
    __css: buttonStyles
  }));
});

if (__DEV__) {
  AccordionButton.displayName = "AccordionButton";
}
/* -------------------------------------------------------------------------------------------------
 * Accordion Item => Panel
 * -----------------------------------------------------------------------------------------------*/


/**
 * Accordion panel that holds the content for each accordion.
 * It shows and hides based on the state login from the `AccordionItem`.
 *
 * It uses the `Collapse` component to animate its height.
 */
const AccordionPanel = /*#__PURE__*/forwardRef((props, ref) => {
  const {
    reduceMotion
  } = useAccordionContext();
  const {
    getPanelProps,
    isOpen
  } = useAccordionItemContext(); // remove `hidden` prop, 'coz we're using height animation

  const panelProps = getPanelProps(props, ref);

  const _className = cx("chakra-accordion__panel", props.className);

  const styles = useStyles();

  if (!reduceMotion) {
    delete panelProps.hidden;
  }

  const child = /*#__PURE__*/React.createElement(chakra.div, _extends({}, panelProps, {
    __css: styles.panel,
    className: _className
  }));

  if (!reduceMotion) {
    return /*#__PURE__*/React.createElement(Collapse, {
      in: isOpen
    }, child);
  }

  return child;
});

if (__DEV__) {
  AccordionPanel.displayName = "AccordionPanel";
}
/* -------------------------------------------------------------------------------------------------
 * Accordion Item => Icon
 * -----------------------------------------------------------------------------------------------*/

/**
 * AccordionIcon that gives a visual cue of the open/close state of the accordion item.
 * It rotates `180deg` based on the open/close state.
 */


const AccordionIcon = props => {
  const {
    isOpen,
    isDisabled
  } = useAccordionItemContext();
  const {
    reduceMotion
  } = useAccordionContext();

  const _className = cx("chakra-accordion__icon", props.className);

  const styles = useStyles();
  const iconStyles = {
    opacity: isDisabled ? 0.4 : 1,
    transform: isOpen ? "rotate(-180deg)" : undefined,
    transition: reduceMotion ? undefined : "transform 0.2s",
    transformOrigin: "center",
    ...styles.icon
  };
  return /*#__PURE__*/React.createElement(Icon, _extends({
    viewBox: "0 0 24 24",
    "aria-hidden": true,
    className: _className,
    __css: iconStyles
  }, props), /*#__PURE__*/React.createElement("path", {
    fill: "currentColor",
    d: "M16.59 8.59L12 13.17 7.41 8.59 6 10l6 6 6-6z"
  }));
};

if (__DEV__) {
  AccordionIcon.displayName = "AccordionIcon";
}

export { Accordion, AccordionButton, AccordionDescendantsProvider, AccordionIcon, AccordionItem, AccordionPanel, AccordionProvider, useAccordion, useAccordionContext, useAccordionDescendant, useAccordionDescendants, useAccordionDescendantsContext, useAccordionItem, useAccordionItemState };

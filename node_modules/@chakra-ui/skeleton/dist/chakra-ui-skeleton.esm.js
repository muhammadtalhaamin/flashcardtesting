import { useBreakpointValue } from '@chakra-ui/media-query';
import { chakra, keyframes, forwardRef, useStyleConfig, omitThemingProps } from '@chakra-ui/system';
import { usePrevious } from '@chakra-ui/hooks';
import { cx, __DEV__ } from '@chakra-ui/utils';
import * as React from 'react';

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

const StyledSkeleton = chakra("div", {
  baseStyle: {
    boxShadow: "none",
    backgroundClip: "padding-box",
    cursor: "default",
    color: "transparent",
    pointerEvents: "none",
    userSelect: "none",
    "&::before, &::after, *": {
      visibility: "hidden"
    }
  }
});
const fade = keyframes({
  from: {
    opacity: 0
  },
  to: {
    opacity: 1
  }
});

const useIsFirstRender = () => {
  const isFirstRender = React.useRef(true);
  React.useEffect(() => {
    isFirstRender.current = false;
  }, []);
  return isFirstRender.current;
};

const Skeleton = /*#__PURE__*/forwardRef((props, ref) => {
  const styles = useStyleConfig("Skeleton", props);
  const isFirstRender = useIsFirstRender();
  const {
    startColor,
    endColor,
    isLoaded,
    fadeDuration,
    speed,
    className,
    ...rest
  } = omitThemingProps(props);
  const wasPreviouslyLoaded = usePrevious(isLoaded);

  const _className = cx("chakra-skeleton", className);

  if (isLoaded) {
    const animation = isFirstRender || wasPreviouslyLoaded ? "none" : `${fade} ${fadeDuration}s`;
    return /*#__PURE__*/React.createElement(chakra.div, _extends({
      ref: ref,
      className: _className,
      __css: {
        animation
      }
    }, rest));
  }

  return /*#__PURE__*/React.createElement(StyledSkeleton, _extends({
    ref: ref,
    className: _className
  }, rest, {
    __css: styles
  }));
});
Skeleton.defaultProps = {
  fadeDuration: 0.4,
  speed: 0.8
};

if (__DEV__) {
  Skeleton.displayName = "Skeleton";
}

function range(count) {
  return Array(count).fill(1).map((_, index) => index + 1);
}

const defaultNoOfLines = 3;
const SkeletonText = props => {
  const {
    noOfLines = defaultNoOfLines,
    spacing = "0.5rem",
    skeletonHeight = "0.5rem",
    className,
    startColor,
    endColor,
    isLoaded,
    fadeDuration,
    speed,
    children,
    ...rest
  } = props;
  const noOfLinesValue = useBreakpointValue(typeof noOfLines === "number" ? [noOfLines] : noOfLines) || defaultNoOfLines;
  const numbers = range(noOfLinesValue);

  const getWidth = index => {
    if (noOfLinesValue > 1) {
      return index === numbers.length ? "80%" : "100%";
    }

    return "100%";
  };

  const _className = cx("chakra-skeleton__group", className);

  return /*#__PURE__*/React.createElement(chakra.div, _extends({
    className: _className
  }, rest), numbers.map((number, index) => {
    if (isLoaded && index > 0) {
      // skip other lines
      return null;
    }

    const sizeProps = isLoaded ? null : {
      mb: number === numbers.length ? "0" : spacing,
      width: getWidth(number),
      height: skeletonHeight
    };
    return /*#__PURE__*/React.createElement(Skeleton, _extends({
      key: numbers.length.toString() + number,
      startColor: startColor,
      endColor: endColor,
      isLoaded: isLoaded,
      fadeDuration: fadeDuration,
      speed: speed
    }, sizeProps), // allows animating the children
    index === 0 ? children : undefined);
  }));
};

if (__DEV__) {
  SkeletonText.displayName = "SkeletonText";
}

const SkeletonCircle = ({
  size = "2rem",
  ...rest
}) => /*#__PURE__*/React.createElement(Skeleton, _extends({
  borderRadius: "full",
  boxSize: size
}, rest));

if (__DEV__) {
  SkeletonCircle.displayName = "SkeletonCircle";
}

export { Skeleton, SkeletonCircle, SkeletonText };

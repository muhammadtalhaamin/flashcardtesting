'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var system = require('@chakra-ui/system');
var utils = require('@chakra-ui/utils');
var React = require('react');
var reactUtils = require('@chakra-ui/react-utils');
var hooks = require('@chakra-ui/hooks');
var formControl = require('@chakra-ui/form-control');
var visuallyHidden = require('@chakra-ui/visually-hidden');

function _interopNamespace(e) {
  if (e && e.__esModule) return e;
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n["default"] = e;
  return Object.freeze(n);
}

var React__namespace = /*#__PURE__*/_interopNamespace(React);

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

/**
 * React hook to manage a group of radio inputs
 */
function useRadioGroup(props = {}) {
  const {
    onChange: onChangeProp,
    value: valueProp,
    defaultValue,
    name: nameProp,
    isDisabled,
    isFocusable,
    isNative,
    ...htmlProps
  } = props;
  const [valueState, setValue] = React__namespace.useState(defaultValue || "");
  const [isControlled, value] = hooks.useControllableProp(valueProp, valueState);
  const ref = React__namespace.useRef(null);
  const focus = React__namespace.useCallback(() => {
    const rootNode = ref.current;
    if (!rootNode) return;
    let query = `input:not(:disabled):checked`;
    const firstEnabledAndCheckedInput = rootNode.querySelector(query);

    if (firstEnabledAndCheckedInput) {
      firstEnabledAndCheckedInput.focus();
      return;
    }

    query = `input:not(:disabled)`;
    const firstEnabledInput = rootNode.querySelector(query);
    firstEnabledInput?.focus();
  }, []);
  /**
   * All radio options must use the same name
   */

  const fallbackName = hooks.useId(undefined, `radio`);
  const name = nameProp || fallbackName;
  const onChange = React__namespace.useCallback(eventOrValue => {
    const nextValue = utils.isInputEvent(eventOrValue) ? eventOrValue.target.value : eventOrValue;

    if (!isControlled) {
      setValue(nextValue);
    }

    onChangeProp?.(String(nextValue));
  }, [onChangeProp, isControlled]);
  const getRootProps = React__namespace.useCallback((props = {}, forwardedRef = null) => ({ ...props,
    ref: reactUtils.mergeRefs(forwardedRef, ref),
    role: "radiogroup"
  }), []);
  const getRadioProps = React__namespace.useCallback((props = {}, ref = null) => {
    const checkedKey = isNative ? "checked" : "isChecked";
    return { ...props,
      ref,
      name,
      [checkedKey]: value != null ? props.value === value : undefined,
      onChange,
      "data-radiogroup": true
    };
  }, [isNative, name, onChange, value]);
  return {
    getRootProps,
    getRadioProps,
    name,
    ref,
    focus,
    setValue,
    value,
    onChange,
    isDisabled,
    isFocusable,
    htmlProps
  };
}

const [RadioGroupProvider, useRadioGroupContext] = reactUtils.createContext({
  name: "RadioGroupContext",
  strict: false
});

/**
 * Used for multiple radios which are bound in one group,
 * and it indicates which option is selected.
 *
 * @see Docs https://chakra-ui.com/radio
 */
const RadioGroup = /*#__PURE__*/system.forwardRef((props, ref) => {
  const {
    colorScheme,
    size,
    variant,
    children,
    className,
    isDisabled,
    isFocusable,
    ...rest
  } = props;
  const {
    value,
    onChange,
    getRootProps,
    name,
    htmlProps
  } = useRadioGroup(rest);
  const group = React__namespace.useMemo(() => ({
    name,
    size,
    onChange,
    colorScheme,
    value,
    variant,
    isDisabled,
    isFocusable
  }), [name, size, onChange, colorScheme, value, variant, isDisabled, isFocusable]);
  const groupProps = getRootProps(htmlProps, ref);

  const _className = utils.cx("chakra-radio-group", className);

  return /*#__PURE__*/React__namespace.createElement(RadioGroupProvider, {
    value: group
  }, /*#__PURE__*/React__namespace.createElement(system.chakra.div, _extends({}, groupProps, {
    className: _className
  }), children));
});

if (utils.__DEV__) {
  RadioGroup.displayName = "RadioGroup";
}

/**
 * @todo use the `useClickable` hook here
 * to manage the isFocusable & isDisabled props
 */

function useRadio(props = {}) {
  const {
    defaultIsChecked,
    defaultChecked = defaultIsChecked,
    isChecked: isCheckedProp,
    isFocusable,
    isDisabled: isDisabledProp,
    isReadOnly: isReadOnlyProp,
    isRequired: isRequiredProp,
    onChange,
    isInvalid: isInvalidProp,
    name,
    value,
    id: idProp,
    "data-radiogroup": dataRadioGroup,
    ...htmlProps
  } = props;
  const uuid = hooks.useId(undefined, "radio");
  const formControl$1 = formControl.useFormControlContext();
  const group = useRadioGroupContext();
  const isWithinRadioGroup = !!group || !!dataRadioGroup;
  const isWithinFormControl = !!formControl$1;
  let id = isWithinFormControl && !isWithinRadioGroup ? formControl$1.id : uuid;
  id = idProp ?? id;
  const isDisabled = isDisabledProp ?? formControl$1?.isDisabled;
  const isReadOnly = isReadOnlyProp ?? formControl$1?.isReadOnly;
  const isRequired = isRequiredProp ?? formControl$1?.isRequired;
  const isInvalid = isInvalidProp ?? formControl$1?.isInvalid;
  const [isFocused, setFocused] = hooks.useBoolean();
  const [isHovered, setHovering] = hooks.useBoolean();
  const [isActive, setActive] = hooks.useBoolean();
  const ref = React.useRef(null);
  const [isCheckedState, setChecked] = React.useState(Boolean(defaultChecked));
  const [isControlled, isChecked] = hooks.useControllableProp(isCheckedProp, isCheckedState);
  utils.warn({
    condition: !!defaultIsChecked,
    message: 'The "defaultIsChecked" prop has been deprecated and will be removed in a future version. ' + 'Please use the "defaultChecked" prop instead, which mirrors default React checkbox behavior.'
  });
  const handleChange = React.useCallback(event => {
    if (isReadOnly || isDisabled) {
      event.preventDefault();
      return;
    }

    if (!isControlled) {
      setChecked(event.target.checked);
    }

    onChange?.(event);
  }, [isControlled, isDisabled, isReadOnly, onChange]);
  const onKeyDown = React.useCallback(event => {
    if (event.key === " ") {
      setActive.on();
    }
  }, [setActive]);
  const onKeyUp = React.useCallback(event => {
    if (event.key === " ") {
      setActive.off();
    }
  }, [setActive]);
  const getCheckboxProps = React.useCallback((props = {}, ref = null) => ({ ...props,
    ref,
    "data-active": utils.dataAttr(isActive),
    "data-hover": utils.dataAttr(isHovered),
    "data-disabled": utils.dataAttr(isDisabled),
    "data-invalid": utils.dataAttr(isInvalid),
    "data-checked": utils.dataAttr(isChecked),
    "data-focus": utils.dataAttr(isFocused),
    "data-readonly": utils.dataAttr(isReadOnly),
    "aria-hidden": true,
    onMouseDown: utils.callAllHandlers(props.onMouseDown, setActive.on),
    onMouseUp: utils.callAllHandlers(props.onMouseUp, setActive.off),
    onMouseEnter: utils.callAllHandlers(props.onMouseEnter, setHovering.on),
    onMouseLeave: utils.callAllHandlers(props.onMouseLeave, setHovering.off)
  }), [isActive, isHovered, isDisabled, isInvalid, isChecked, isFocused, isReadOnly, setActive.on, setActive.off, setHovering.on, setHovering.off]);
  const {
    onFocus,
    onBlur
  } = formControl$1 ?? {};
  const getInputProps = React.useCallback((props = {}, forwardedRef = null) => {
    const trulyDisabled = isDisabled && !isFocusable;
    return { ...props,
      id,
      ref: reactUtils.mergeRefs(forwardedRef, ref),
      type: "radio",
      name,
      value,
      onChange: utils.callAllHandlers(props.onChange, handleChange),
      onBlur: utils.callAllHandlers(onBlur, props.onBlur, setFocused.off),
      onFocus: utils.callAllHandlers(onFocus, props.onFocus, setFocused.on),
      onKeyDown: utils.callAllHandlers(props.onKeyDown, onKeyDown),
      onKeyUp: utils.callAllHandlers(props.onKeyUp, onKeyUp),
      checked: isChecked,
      disabled: trulyDisabled,
      readOnly: isReadOnly,
      required: isRequired,
      "aria-invalid": utils.ariaAttr(isInvalid),
      "aria-disabled": utils.ariaAttr(trulyDisabled),
      "aria-required": utils.ariaAttr(isRequired),
      "data-readonly": utils.dataAttr(isReadOnly),
      style: visuallyHidden.visuallyHiddenStyle
    };
  }, [isDisabled, isFocusable, id, name, value, handleChange, onBlur, setFocused, onFocus, onKeyDown, onKeyUp, isChecked, isReadOnly, isRequired, isInvalid]);

  const getLabelProps = (props = {}, ref = null) => ({ ...props,
    ref,
    onMouseDown: utils.callAllHandlers(props.onMouseDown, stop),
    onTouchStart: utils.callAllHandlers(props.onTouchStart, stop),
    "data-disabled": utils.dataAttr(isDisabled),
    "data-checked": utils.dataAttr(isChecked),
    "data-invalid": utils.dataAttr(isInvalid)
  });

  const getRootProps = (props, ref = null) => ({ ...props,
    ref,
    "data-disabled": utils.dataAttr(isDisabled),
    "data-checked": utils.dataAttr(isChecked),
    "data-invalid": utils.dataAttr(isInvalid)
  });

  return {
    state: {
      isInvalid,
      isFocused,
      isChecked,
      isActive,
      isHovered,
      isDisabled,
      isReadOnly,
      isRequired
    },
    getCheckboxProps,
    getInputProps,
    getLabelProps,
    getRootProps,
    htmlProps
  };
}
/**
 * Prevent `onBlur` being fired when the checkbox label is touched
 */

function stop(event) {
  event.preventDefault();
  event.stopPropagation();
}

/**
 * Radio component is used in forms when a user needs to select a single value from
 * several options.
 *
 * @see Docs https://chakra-ui.com/radio
 */
const Radio = /*#__PURE__*/system.forwardRef((props, ref) => {
  const group = useRadioGroupContext();
  const {
    onChange: onChangeProp,
    value: valueProp
  } = props;
  const styles = system.useMultiStyleConfig("Radio", { ...group,
    ...props
  });
  const ownProps = system.omitThemingProps(props);
  const {
    spacing = "0.5rem",
    children,
    isFullWidth,
    isDisabled = group?.isDisabled,
    isFocusable = group?.isFocusable,
    ...rest
  } = ownProps;
  let isChecked = props.isChecked;

  if (group?.value != null && valueProp != null) {
    isChecked = group.value === valueProp;
  }

  let onChange = onChangeProp;

  if (group?.onChange && valueProp != null) {
    onChange = utils.callAll(group.onChange, onChangeProp);
  }

  const name = props?.name ?? group?.name;
  const {
    getInputProps,
    getCheckboxProps,
    getLabelProps,
    getRootProps,
    htmlProps
  } = useRadio({ ...rest,
    isChecked,
    isFocusable,
    isDisabled,
    onChange,
    name
  });
  const [layoutProps, otherProps] = utils.split(htmlProps, system.layoutPropNames);
  const checkboxProps = getCheckboxProps(otherProps);
  const inputProps = getInputProps({}, ref);
  const labelProps = getLabelProps();
  const rootProps = Object.assign({}, layoutProps, getRootProps());
  const rootStyles = {
    width: isFullWidth ? "full" : undefined,
    display: "inline-flex",
    alignItems: "center",
    verticalAlign: "top",
    ...styles.container
  };
  const checkboxStyles = {
    display: "inline-flex",
    alignItems: "center",
    justifyContent: "center",
    flexShrink: 0,
    ...styles.control
  };
  const labelStyles = {
    userSelect: "none",
    marginStart: spacing,
    ...styles.label
  };
  return /*#__PURE__*/React__namespace.createElement(system.chakra.label, _extends({
    className: "chakra-radio"
  }, rootProps, {
    __css: rootStyles
  }), /*#__PURE__*/React__namespace.createElement("input", _extends({
    className: "chakra-radio__input"
  }, inputProps)), /*#__PURE__*/React__namespace.createElement(system.chakra.span, _extends({
    className: "chakra-radio__control"
  }, checkboxProps, {
    __css: checkboxStyles
  })), children && /*#__PURE__*/React__namespace.createElement(system.chakra.span, _extends({
    className: "chakra-radio__label"
  }, labelProps, {
    __css: labelStyles
  }), children));
});

if (utils.__DEV__) {
  Radio.displayName = "Radio";
}

exports.Radio = Radio;
exports.RadioGroup = RadioGroup;
exports.useRadio = useRadio;
exports.useRadioGroup = useRadioGroup;
exports.useRadioGroupContext = useRadioGroupContext;

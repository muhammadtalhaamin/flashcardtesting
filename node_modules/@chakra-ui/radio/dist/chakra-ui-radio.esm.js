import { forwardRef, chakra, useMultiStyleConfig, omitThemingProps, layoutPropNames } from '@chakra-ui/system';
import { isInputEvent, cx, __DEV__, warn, dataAttr, callAllHandlers, ariaAttr, callAll, split } from '@chakra-ui/utils';
import * as React from 'react';
import { useRef, useState, useCallback } from 'react';
import { mergeRefs, createContext } from '@chakra-ui/react-utils';
import { useControllableProp, useId, useBoolean } from '@chakra-ui/hooks';
import { useFormControlContext } from '@chakra-ui/form-control';
import { visuallyHiddenStyle } from '@chakra-ui/visually-hidden';

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

/**
 * React hook to manage a group of radio inputs
 */
function useRadioGroup(props = {}) {
  const {
    onChange: onChangeProp,
    value: valueProp,
    defaultValue,
    name: nameProp,
    isDisabled,
    isFocusable,
    isNative,
    ...htmlProps
  } = props;
  const [valueState, setValue] = React.useState(defaultValue || "");
  const [isControlled, value] = useControllableProp(valueProp, valueState);
  const ref = React.useRef(null);
  const focus = React.useCallback(() => {
    const rootNode = ref.current;
    if (!rootNode) return;
    let query = `input:not(:disabled):checked`;
    const firstEnabledAndCheckedInput = rootNode.querySelector(query);

    if (firstEnabledAndCheckedInput) {
      firstEnabledAndCheckedInput.focus();
      return;
    }

    query = `input:not(:disabled)`;
    const firstEnabledInput = rootNode.querySelector(query);
    firstEnabledInput?.focus();
  }, []);
  /**
   * All radio options must use the same name
   */

  const fallbackName = useId(undefined, `radio`);
  const name = nameProp || fallbackName;
  const onChange = React.useCallback(eventOrValue => {
    const nextValue = isInputEvent(eventOrValue) ? eventOrValue.target.value : eventOrValue;

    if (!isControlled) {
      setValue(nextValue);
    }

    onChangeProp?.(String(nextValue));
  }, [onChangeProp, isControlled]);
  const getRootProps = React.useCallback((props = {}, forwardedRef = null) => ({ ...props,
    ref: mergeRefs(forwardedRef, ref),
    role: "radiogroup"
  }), []);
  const getRadioProps = React.useCallback((props = {}, ref = null) => {
    const checkedKey = isNative ? "checked" : "isChecked";
    return { ...props,
      ref,
      name,
      [checkedKey]: value != null ? props.value === value : undefined,
      onChange,
      "data-radiogroup": true
    };
  }, [isNative, name, onChange, value]);
  return {
    getRootProps,
    getRadioProps,
    name,
    ref,
    focus,
    setValue,
    value,
    onChange,
    isDisabled,
    isFocusable,
    htmlProps
  };
}

const [RadioGroupProvider, useRadioGroupContext] = createContext({
  name: "RadioGroupContext",
  strict: false
});

/**
 * Used for multiple radios which are bound in one group,
 * and it indicates which option is selected.
 *
 * @see Docs https://chakra-ui.com/radio
 */
const RadioGroup = /*#__PURE__*/forwardRef((props, ref) => {
  const {
    colorScheme,
    size,
    variant,
    children,
    className,
    isDisabled,
    isFocusable,
    ...rest
  } = props;
  const {
    value,
    onChange,
    getRootProps,
    name,
    htmlProps
  } = useRadioGroup(rest);
  const group = React.useMemo(() => ({
    name,
    size,
    onChange,
    colorScheme,
    value,
    variant,
    isDisabled,
    isFocusable
  }), [name, size, onChange, colorScheme, value, variant, isDisabled, isFocusable]);
  const groupProps = getRootProps(htmlProps, ref);

  const _className = cx("chakra-radio-group", className);

  return /*#__PURE__*/React.createElement(RadioGroupProvider, {
    value: group
  }, /*#__PURE__*/React.createElement(chakra.div, _extends({}, groupProps, {
    className: _className
  }), children));
});

if (__DEV__) {
  RadioGroup.displayName = "RadioGroup";
}

/**
 * @todo use the `useClickable` hook here
 * to manage the isFocusable & isDisabled props
 */

function useRadio(props = {}) {
  const {
    defaultIsChecked,
    defaultChecked = defaultIsChecked,
    isChecked: isCheckedProp,
    isFocusable,
    isDisabled: isDisabledProp,
    isReadOnly: isReadOnlyProp,
    isRequired: isRequiredProp,
    onChange,
    isInvalid: isInvalidProp,
    name,
    value,
    id: idProp,
    "data-radiogroup": dataRadioGroup,
    ...htmlProps
  } = props;
  const uuid = useId(undefined, "radio");
  const formControl = useFormControlContext();
  const group = useRadioGroupContext();
  const isWithinRadioGroup = !!group || !!dataRadioGroup;
  const isWithinFormControl = !!formControl;
  let id = isWithinFormControl && !isWithinRadioGroup ? formControl.id : uuid;
  id = idProp ?? id;
  const isDisabled = isDisabledProp ?? formControl?.isDisabled;
  const isReadOnly = isReadOnlyProp ?? formControl?.isReadOnly;
  const isRequired = isRequiredProp ?? formControl?.isRequired;
  const isInvalid = isInvalidProp ?? formControl?.isInvalid;
  const [isFocused, setFocused] = useBoolean();
  const [isHovered, setHovering] = useBoolean();
  const [isActive, setActive] = useBoolean();
  const ref = useRef(null);
  const [isCheckedState, setChecked] = useState(Boolean(defaultChecked));
  const [isControlled, isChecked] = useControllableProp(isCheckedProp, isCheckedState);
  warn({
    condition: !!defaultIsChecked,
    message: 'The "defaultIsChecked" prop has been deprecated and will be removed in a future version. ' + 'Please use the "defaultChecked" prop instead, which mirrors default React checkbox behavior.'
  });
  const handleChange = useCallback(event => {
    if (isReadOnly || isDisabled) {
      event.preventDefault();
      return;
    }

    if (!isControlled) {
      setChecked(event.target.checked);
    }

    onChange?.(event);
  }, [isControlled, isDisabled, isReadOnly, onChange]);
  const onKeyDown = useCallback(event => {
    if (event.key === " ") {
      setActive.on();
    }
  }, [setActive]);
  const onKeyUp = useCallback(event => {
    if (event.key === " ") {
      setActive.off();
    }
  }, [setActive]);
  const getCheckboxProps = useCallback((props = {}, ref = null) => ({ ...props,
    ref,
    "data-active": dataAttr(isActive),
    "data-hover": dataAttr(isHovered),
    "data-disabled": dataAttr(isDisabled),
    "data-invalid": dataAttr(isInvalid),
    "data-checked": dataAttr(isChecked),
    "data-focus": dataAttr(isFocused),
    "data-readonly": dataAttr(isReadOnly),
    "aria-hidden": true,
    onMouseDown: callAllHandlers(props.onMouseDown, setActive.on),
    onMouseUp: callAllHandlers(props.onMouseUp, setActive.off),
    onMouseEnter: callAllHandlers(props.onMouseEnter, setHovering.on),
    onMouseLeave: callAllHandlers(props.onMouseLeave, setHovering.off)
  }), [isActive, isHovered, isDisabled, isInvalid, isChecked, isFocused, isReadOnly, setActive.on, setActive.off, setHovering.on, setHovering.off]);
  const {
    onFocus,
    onBlur
  } = formControl ?? {};
  const getInputProps = useCallback((props = {}, forwardedRef = null) => {
    const trulyDisabled = isDisabled && !isFocusable;
    return { ...props,
      id,
      ref: mergeRefs(forwardedRef, ref),
      type: "radio",
      name,
      value,
      onChange: callAllHandlers(props.onChange, handleChange),
      onBlur: callAllHandlers(onBlur, props.onBlur, setFocused.off),
      onFocus: callAllHandlers(onFocus, props.onFocus, setFocused.on),
      onKeyDown: callAllHandlers(props.onKeyDown, onKeyDown),
      onKeyUp: callAllHandlers(props.onKeyUp, onKeyUp),
      checked: isChecked,
      disabled: trulyDisabled,
      readOnly: isReadOnly,
      required: isRequired,
      "aria-invalid": ariaAttr(isInvalid),
      "aria-disabled": ariaAttr(trulyDisabled),
      "aria-required": ariaAttr(isRequired),
      "data-readonly": dataAttr(isReadOnly),
      style: visuallyHiddenStyle
    };
  }, [isDisabled, isFocusable, id, name, value, handleChange, onBlur, setFocused, onFocus, onKeyDown, onKeyUp, isChecked, isReadOnly, isRequired, isInvalid]);

  const getLabelProps = (props = {}, ref = null) => ({ ...props,
    ref,
    onMouseDown: callAllHandlers(props.onMouseDown, stop),
    onTouchStart: callAllHandlers(props.onTouchStart, stop),
    "data-disabled": dataAttr(isDisabled),
    "data-checked": dataAttr(isChecked),
    "data-invalid": dataAttr(isInvalid)
  });

  const getRootProps = (props, ref = null) => ({ ...props,
    ref,
    "data-disabled": dataAttr(isDisabled),
    "data-checked": dataAttr(isChecked),
    "data-invalid": dataAttr(isInvalid)
  });

  return {
    state: {
      isInvalid,
      isFocused,
      isChecked,
      isActive,
      isHovered,
      isDisabled,
      isReadOnly,
      isRequired
    },
    getCheckboxProps,
    getInputProps,
    getLabelProps,
    getRootProps,
    htmlProps
  };
}
/**
 * Prevent `onBlur` being fired when the checkbox label is touched
 */

function stop(event) {
  event.preventDefault();
  event.stopPropagation();
}

/**
 * Radio component is used in forms when a user needs to select a single value from
 * several options.
 *
 * @see Docs https://chakra-ui.com/radio
 */
const Radio = /*#__PURE__*/forwardRef((props, ref) => {
  const group = useRadioGroupContext();
  const {
    onChange: onChangeProp,
    value: valueProp
  } = props;
  const styles = useMultiStyleConfig("Radio", { ...group,
    ...props
  });
  const ownProps = omitThemingProps(props);
  const {
    spacing = "0.5rem",
    children,
    isFullWidth,
    isDisabled = group?.isDisabled,
    isFocusable = group?.isFocusable,
    ...rest
  } = ownProps;
  let isChecked = props.isChecked;

  if (group?.value != null && valueProp != null) {
    isChecked = group.value === valueProp;
  }

  let onChange = onChangeProp;

  if (group?.onChange && valueProp != null) {
    onChange = callAll(group.onChange, onChangeProp);
  }

  const name = props?.name ?? group?.name;
  const {
    getInputProps,
    getCheckboxProps,
    getLabelProps,
    getRootProps,
    htmlProps
  } = useRadio({ ...rest,
    isChecked,
    isFocusable,
    isDisabled,
    onChange,
    name
  });
  const [layoutProps, otherProps] = split(htmlProps, layoutPropNames);
  const checkboxProps = getCheckboxProps(otherProps);
  const inputProps = getInputProps({}, ref);
  const labelProps = getLabelProps();
  const rootProps = Object.assign({}, layoutProps, getRootProps());
  const rootStyles = {
    width: isFullWidth ? "full" : undefined,
    display: "inline-flex",
    alignItems: "center",
    verticalAlign: "top",
    ...styles.container
  };
  const checkboxStyles = {
    display: "inline-flex",
    alignItems: "center",
    justifyContent: "center",
    flexShrink: 0,
    ...styles.control
  };
  const labelStyles = {
    userSelect: "none",
    marginStart: spacing,
    ...styles.label
  };
  return /*#__PURE__*/React.createElement(chakra.label, _extends({
    className: "chakra-radio"
  }, rootProps, {
    __css: rootStyles
  }), /*#__PURE__*/React.createElement("input", _extends({
    className: "chakra-radio__input"
  }, inputProps)), /*#__PURE__*/React.createElement(chakra.span, _extends({
    className: "chakra-radio__control"
  }, checkboxProps, {
    __css: checkboxStyles
  })), children && /*#__PURE__*/React.createElement(chakra.span, _extends({
    className: "chakra-radio__label"
  }, labelProps, {
    __css: labelStyles
  }), children));
});

if (__DEV__) {
  Radio.displayName = "Radio";
}

export { Radio, RadioGroup, useRadio, useRadioGroup, useRadioGroupContext };

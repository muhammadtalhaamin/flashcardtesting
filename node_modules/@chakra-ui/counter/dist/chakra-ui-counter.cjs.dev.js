'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var hooks = require('@chakra-ui/hooks');
var utils = require('@chakra-ui/utils');
var react = require('react');

function useCounter(props = {}) {
  const {
    onChange,
    precision: precisionProp,
    defaultValue,
    value: valueProp,
    step: stepProp = 1,
    min = utils.minSafeInteger,
    max = utils.maxSafeInteger,
    keepWithinRange = true
  } = props;
  const onChangeProp = hooks.useCallbackRef(onChange);
  const [valueState, setValue] = react.useState(() => {
    if (defaultValue == null) return "";
    return cast(defaultValue, stepProp, precisionProp) ?? "";
  });
  /**
   * Because the component that consumes this hook can be controlled or uncontrolled
   * we'll keep track of that
   */

  const [isControlled, value] = hooks.useControllableProp(valueProp, valueState);
  const decimalPlaces = getDecimalPlaces(parse(value), stepProp);
  const precision = precisionProp ?? decimalPlaces;
  const update = react.useCallback(next => {
    if (next === value) return;

    if (!isControlled) {
      setValue(next.toString());
    }

    onChangeProp?.(next.toString(), parse(next));
  }, [onChangeProp, isControlled, value]); // Function to clamp the value and round it to the precision

  const clamp = react.useCallback(value => {
    let nextValue = value;

    if (keepWithinRange) {
      nextValue = utils.clampValue(nextValue, min, max);
    }

    return utils.toPrecision(nextValue, precision);
  }, [precision, keepWithinRange, max, min]);
  const increment = react.useCallback((step = stepProp) => {
    let next;
    /**
     * Let's follow the native browser behavior for
     * scenarios where the input starts empty ("")
     */

    if (value === "") {
      /**
       * If `min` is set, native input, starts at the `min`.
       * Else, it starts at `step`
       */
      next = parse(step);
    } else {
      next = parse(value) + step;
    }

    next = clamp(next);
    update(next);
  }, [clamp, stepProp, update, value]);
  const decrement = react.useCallback((step = stepProp) => {
    let next; // Same thing here. We'll follow native implementation

    if (value === "") {
      next = parse(-step);
    } else {
      next = parse(value) - step;
    }

    next = clamp(next);
    update(next);
  }, [clamp, stepProp, update, value]);
  const reset = react.useCallback(() => {
    let next;

    if (defaultValue == null) {
      next = "";
    } else {
      next = cast(defaultValue, stepProp, precisionProp) ?? min;
    }

    update(next);
  }, [defaultValue, precisionProp, stepProp, update, min]);
  const castValue = react.useCallback(value => {
    const nextValue = cast(value, stepProp, precision) ?? min;
    update(nextValue);
  }, [precision, stepProp, update, min]);
  const valueAsNumber = parse(value);
  /**
   * Common range checks
   */

  const isOutOfRange = valueAsNumber > max || valueAsNumber < min;
  const isAtMax = valueAsNumber === max;
  const isAtMin = valueAsNumber === min;
  return {
    isOutOfRange,
    isAtMax,
    isAtMin,
    precision,
    value,
    valueAsNumber,
    update,
    reset,
    increment,
    decrement,
    clamp,
    cast: castValue,
    setValue
  };
}

function parse(value) {
  return parseFloat(value.toString().replace(/[^\w.-]+/g, ""));
}

function getDecimalPlaces(value, step) {
  return Math.max(utils.countDecimalPlaces(step), utils.countDecimalPlaces(value));
}

function cast(value, step, precision) {
  const parsedValue = parse(value);
  if (Number.isNaN(parsedValue)) return undefined;
  const decimalPlaces = getDecimalPlaces(parsedValue, step);
  return utils.toPrecision(parsedValue, precision ?? decimalPlaces);
}

exports.useCounter = useCounter;

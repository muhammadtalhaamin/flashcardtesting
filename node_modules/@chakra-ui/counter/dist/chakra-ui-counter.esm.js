import { useCallbackRef, useControllableProp } from '@chakra-ui/hooks';
import { countDecimalPlaces, clampValue, toPrecision, minSafeInteger, maxSafeInteger } from '@chakra-ui/utils';
import { useState, useCallback } from 'react';

function useCounter(props = {}) {
  const {
    onChange,
    precision: precisionProp,
    defaultValue,
    value: valueProp,
    step: stepProp = 1,
    min = minSafeInteger,
    max = maxSafeInteger,
    keepWithinRange = true
  } = props;
  const onChangeProp = useCallbackRef(onChange);
  const [valueState, setValue] = useState(() => {
    if (defaultValue == null) return "";
    return cast(defaultValue, stepProp, precisionProp) ?? "";
  });
  /**
   * Because the component that consumes this hook can be controlled or uncontrolled
   * we'll keep track of that
   */

  const [isControlled, value] = useControllableProp(valueProp, valueState);
  const decimalPlaces = getDecimalPlaces(parse(value), stepProp);
  const precision = precisionProp ?? decimalPlaces;
  const update = useCallback(next => {
    if (next === value) return;

    if (!isControlled) {
      setValue(next.toString());
    }

    onChangeProp?.(next.toString(), parse(next));
  }, [onChangeProp, isControlled, value]); // Function to clamp the value and round it to the precision

  const clamp = useCallback(value => {
    let nextValue = value;

    if (keepWithinRange) {
      nextValue = clampValue(nextValue, min, max);
    }

    return toPrecision(nextValue, precision);
  }, [precision, keepWithinRange, max, min]);
  const increment = useCallback((step = stepProp) => {
    let next;
    /**
     * Let's follow the native browser behavior for
     * scenarios where the input starts empty ("")
     */

    if (value === "") {
      /**
       * If `min` is set, native input, starts at the `min`.
       * Else, it starts at `step`
       */
      next = parse(step);
    } else {
      next = parse(value) + step;
    }

    next = clamp(next);
    update(next);
  }, [clamp, stepProp, update, value]);
  const decrement = useCallback((step = stepProp) => {
    let next; // Same thing here. We'll follow native implementation

    if (value === "") {
      next = parse(-step);
    } else {
      next = parse(value) - step;
    }

    next = clamp(next);
    update(next);
  }, [clamp, stepProp, update, value]);
  const reset = useCallback(() => {
    let next;

    if (defaultValue == null) {
      next = "";
    } else {
      next = cast(defaultValue, stepProp, precisionProp) ?? min;
    }

    update(next);
  }, [defaultValue, precisionProp, stepProp, update, min]);
  const castValue = useCallback(value => {
    const nextValue = cast(value, stepProp, precision) ?? min;
    update(nextValue);
  }, [precision, stepProp, update, min]);
  const valueAsNumber = parse(value);
  /**
   * Common range checks
   */

  const isOutOfRange = valueAsNumber > max || valueAsNumber < min;
  const isAtMax = valueAsNumber === max;
  const isAtMin = valueAsNumber === min;
  return {
    isOutOfRange,
    isAtMax,
    isAtMin,
    precision,
    value,
    valueAsNumber,
    update,
    reset,
    increment,
    decrement,
    clamp,
    cast: castValue,
    setValue
  };
}

function parse(value) {
  return parseFloat(value.toString().replace(/[^\w.-]+/g, ""));
}

function getDecimalPlaces(value, step) {
  return Math.max(countDecimalPlaces(step), countDecimalPlaces(value));
}

function cast(value, step, precision) {
  const parsedValue = parse(value);
  if (Number.isNaN(parsedValue)) return undefined;
  const decimalPlaces = getDecimalPlaces(parsedValue, step);
  return toPrecision(parsedValue, precision ?? decimalPlaces);
}

export { useCounter };

'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var tinycolor = require('@ctrl/tinycolor');
var utils = require('@chakra-ui/utils');

/**
 * Get the color raw value from theme
 * @param theme - the theme object
 * @param color - the color path ("green.200")
 * @param fallback - the fallback color
 */

const getColor = (theme, color, fallback) => {
  const hex = utils.memoizedGet(theme, `colors.${color}`, color);
  const {
    isValid
  } = new tinycolor.TinyColor(hex);
  return isValid ? hex : fallback;
};
/**
 * Determines if the tone of given color is "light" or "dark"
 * @param color - the color in hex, rgb, or hsl
 */

const tone = color => theme => {
  const hex = getColor(theme, color);
  const isDark = new tinycolor.TinyColor(hex).isDark();
  return isDark ? "dark" : "light";
};
/**
 * Determines if a color tone is "dark"
 * @param color - the color in hex, rgb, or hsl
 */

const isDark = color => theme => tone(color)(theme) === "dark";
/**
 * Determines if a color tone is "light"
 * @param color - the color in hex, rgb, or hsl
 */

const isLight = color => theme => tone(color)(theme) === "light";
/**
 * Make a color transparent
 * @param color - the color in hex, rgb, or hsl
 * @param opacity - the amount of opacity the color should have (0-1)
 */

const transparentize = (color, opacity) => theme => {
  const raw = getColor(theme, color);
  return new tinycolor.TinyColor(raw).setAlpha(opacity).toRgbString();
};
/**
 * Add white to a color
 * @param color - the color in hex, rgb, or hsl
 * @param amount - the amount white to add (0-100)
 */

const whiten = (color, amount) => theme => {
  const raw = getColor(theme, color);
  return new tinycolor.TinyColor(raw).mix("#fff", amount).toHexString();
};
/**
 * Add black to a color
 * @param color - the color in hex, rgb, or hsl
 * @param amount - the amount black to add (0-100)
 */

const blacken = (color, amount) => theme => {
  const raw = getColor(theme, color);
  return new tinycolor.TinyColor(raw).mix("#000", amount).toHexString();
};
/**
 * Darken a specified color
 * @param color - the color in hex, rgb, or hsl
 * @param amount - the amount to darken (0-100)
 */

const darken = (color, amount) => theme => {
  const raw = getColor(theme, color);
  return new tinycolor.TinyColor(raw).darken(amount).toHexString();
};
/**
 * Lighten a specified color
 * @param color - the color in hex, rgb, or hsl
 * @param amount - the amount to lighten (0-100)
 */

const lighten = (color, amount) => theme => new tinycolor.TinyColor(getColor(theme, color)).lighten(amount).toHexString();
/**
 * Checks the contract ratio of between 2 colors,
 * based on the Web Content Accessibility Guidelines (Version 2.0).
 *
 * @param fg - the foreground or text color
 * @param bg - the background color
 */

const contrast = (fg, bg) => theme => tinycolor.readability(getColor(theme, bg), getColor(theme, fg));
/**
 * Checks if a color meets the Web Content Accessibility
 * Guidelines (Version 2.0) for constract ratio.
 *
 * @param fg - the foreground or text color
 * @param bg - the background color
 */

const isAccessible = (textColor, bgColor, options) => theme => tinycolor.isReadable(getColor(theme, bgColor), getColor(theme, textColor), options);
const complementary = color => theme => new tinycolor.TinyColor(getColor(theme, color)).complement().toHexString();
function generateStripe(size = "1rem", color = "rgba(255, 255, 255, 0.15)") {
  return {
    backgroundImage: `linear-gradient(
    45deg,
    ${color} 25%,
    transparent 25%,
    transparent 50%,
    ${color} 50%,
    ${color} 75%,
    transparent 75%,
    transparent
  )`,
    backgroundSize: `${size} ${size}`
  };
}
function randomColor(opts) {
  const fallback = tinycolor.random().toHexString();

  if (!opts || utils.isEmptyObject(opts)) {
    return fallback;
  }

  if (opts.string && opts.colors) {
    return randomColorFromList(opts.string, opts.colors);
  }

  if (opts.string && !opts.colors) {
    return randomColorFromString(opts.string);
  }

  if (opts.colors && !opts.string) {
    return randomFromList(opts.colors);
  }

  return fallback;
}

function randomColorFromString(str) {
  let hash = 0;
  if (str.length === 0) return hash.toString();

  for (let i = 0; i < str.length; i += 1) {
    hash = str.charCodeAt(i) + ((hash << 5) - hash);
    hash = hash & hash;
  }

  let color = "#";

  for (let j = 0; j < 3; j += 1) {
    const value = hash >> j * 8 & 255;
    color += `00${value.toString(16)}`.substr(-2);
  }

  return color;
}

function randomColorFromList(str, list) {
  let index = 0;
  if (str.length === 0) return list[0];

  for (let i = 0; i < str.length; i += 1) {
    index = str.charCodeAt(i) + ((index << 5) - index);
    index = index & index;
  }

  index = (index % list.length + list.length) % list.length;
  return list[index];
}

function randomFromList(list) {
  return list[Math.floor(Math.random() * list.length)];
}

function mode(light, dark) {
  return props => props.colorMode === "dark" ? dark : light;
}
function orient(options) {
  const {
    orientation,
    vertical,
    horizontal
  } = options;
  if (!orientation) return {};
  return orientation === "vertical" ? vertical : horizontal;
}

const createBreakpoints = config => {
  utils.warn({
    condition: true,
    message: [`[chakra-ui]: createBreakpoints(...) will be deprecated pretty soon`, `simply pass the breakpoints as an object. Remove the createBreakpoint(..) call`].join("")
  });
  return {
    base: "0em",
    ...config
  };
};

/**
 * Used to define the anatomy/parts of a component in a way that provides
 * a consistent API for `className`, css selector and `theming`.
 */

class Anatomy {
  constructor(name) {
    this.name = name;
    this.map = {};
    this.called = false;

    this.assert = () => {
      if (!this.called) {
        this.called = true;
        return;
      }

      throw new Error("[anatomy] .part(...) should only be called once. Did you mean to use .extend(...) ?");
    };

    this.parts = (...values) => {
      this.assert();

      for (const part of values) {
        this.map[part] = this.toPart(part);
      }

      return this;
    };

    this.extend = (...parts) => {
      for (const part of parts) {
        if (part in this.map) continue;
        this.map[part] = this.toPart(part);
      }

      return this;
    };

    this.toPart = part => {
      const el = ["container", "root"].includes(part ?? "") ? [this.name] : [this.name, part];
      const attr = el.filter(Boolean).join("__");
      const className = `chakra-${attr}`;
      const partObj = {
        className,
        selector: `.${className}`,
        toString: () => part
      };
      return partObj;
    };

    this.__type = {};
  }
  /**
   * Prevents user from calling `.parts` multiple times.
   * It should only be called once.
   */


  /**
   * Get all selectors for the component anatomy
   */
  get selectors() {
    const value = utils.fromEntries(Object.entries(this.map).map(([key, part]) => [key, part.selector]));
    return value;
  }
  /**
   * Get all classNames for the component anatomy
   */


  get classNames() {
    const value = utils.fromEntries(Object.entries(this.map).map(([key, part]) => [key, part.className]));
    return value;
  }
  /**
   * Get all parts as array of string
   */


  get keys() {
    return Object.keys(this.map);
  }
  /**
   * Creates the part object for the given part
   */


}
function anatomy(name) {
  return new Anatomy(name);
}

function toRef(operand) {
  if (utils.isObject(operand) && operand.reference) {
    return operand.reference;
  }

  return String(operand);
}

const toExpr = (operator, ...operands) => operands.map(toRef).join(` ${operator} `).replace(/calc/g, "");

const add = (...operands) => `calc(${toExpr("+", ...operands)})`;

const subtract = (...operands) => `calc(${toExpr("-", ...operands)})`;

const multiply = (...operands) => `calc(${toExpr("*", ...operands)})`;

const divide = (...operands) => `calc(${toExpr("/", ...operands)})`;

const negate = x => {
  const value = toRef(x);

  if (value != null && !Number.isNaN(parseFloat(value))) {
    return String(value).startsWith("-") ? String(value).slice(1) : `-${value}`;
  }

  return multiply(value, -1);
};

const calc = Object.assign(x => ({
  add: (...operands) => calc(add(x, ...operands)),
  subtract: (...operands) => calc(subtract(x, ...operands)),
  multiply: (...operands) => calc(multiply(x, ...operands)),
  divide: (...operands) => calc(divide(x, ...operands)),
  negate: () => calc(negate(x)),
  toString: () => x.toString()
}), {
  add,
  subtract,
  multiply,
  divide,
  negate
});

function isDecimal(value) {
  return !Number.isInteger(parseFloat(value.toString()));
}

function replaceWhiteSpace(value, replaceValue = "-") {
  return value.replace(/\s+/g, replaceValue);
}

function escape(value) {
  const valueStr = replaceWhiteSpace(value.toString());
  if (valueStr.includes("\\.")) return value;
  return isDecimal(value) ? valueStr.replace(".", `\\.`) : value;
}

function addPrefix(value, prefix = "") {
  return [prefix, escape(value)].filter(Boolean).join("-");
}
function toVarRef(name, fallback) {
  return `var(${escape(name)}${fallback ? `, ${fallback}` : ""})`;
}
function toVar(value, prefix = "") {
  return `--${addPrefix(value, prefix)}`;
}
function cssVar(name, options) {
  const cssVariable = toVar(name, options?.prefix);
  return {
    variable: cssVariable,
    reference: toVarRef(cssVariable, getFallback(options?.fallback))
  };
}

function getFallback(fallback) {
  if (typeof fallback === "string") return fallback;
  return fallback?.reference;
}

Object.defineProperty(exports, 'runIfFn', {
  enumerable: true,
  get: function () { return utils.runIfFn; }
});
exports.Anatomy = Anatomy;
exports.addPrefix = addPrefix;
exports.anatomy = anatomy;
exports.blacken = blacken;
exports.calc = calc;
exports.complementary = complementary;
exports.contrast = contrast;
exports.createBreakpoints = createBreakpoints;
exports.cssVar = cssVar;
exports.darken = darken;
exports.generateStripe = generateStripe;
exports.getColor = getColor;
exports.isAccessible = isAccessible;
exports.isDark = isDark;
exports.isDecimal = isDecimal;
exports.isLight = isLight;
exports.lighten = lighten;
exports.mode = mode;
exports.orient = orient;
exports.randomColor = randomColor;
exports.toVar = toVar;
exports.toVarRef = toVarRef;
exports.tone = tone;
exports.transparentize = transparentize;
exports.whiten = whiten;

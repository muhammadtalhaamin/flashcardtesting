import { useTheme } from '@chakra-ui/system';
import { isBrowser, __DEV__, memoizedGet, isNumber, breakpoints, isArray, fromEntries, arrayToObjectNotation } from '@chakra-ui/utils';
import * as React from 'react';
import React__default from 'react';
import { useEnvironment } from '@chakra-ui/react-env';

const useSafeLayoutEffect = isBrowser ? React.useLayoutEffect : React.useEffect;
/**
 * React hook that tracks state of a CSS media query
 *
 * @param query the media query to match
 */

function useMediaQuery(query) {
  const env = useEnvironment();
  const queries = Array.isArray(query) ? query : [query];
  const isSupported = isBrowser && "matchMedia" in env.window;
  const [matches, setMatches] = React.useState(queries.map(query => isSupported ? !!env.window.matchMedia(query).matches : false));
  useSafeLayoutEffect(() => {
    if (!isSupported) return undefined;
    const mediaQueryList = queries.map(query => env.window.matchMedia(query));
    const listenerList = mediaQueryList.map(() => {
      const listener = () => {
        const isEqual = (prev, curr) => prev.length === curr.length && prev.every((elem, idx) => elem === curr[idx]);

        const currentMatches = mediaQueryList.map(mediaQuery => mediaQuery.matches);

        if (!isEqual(matches, currentMatches)) {
          setMatches(currentMatches);
        }
      };

      env.window.addEventListener("resize", listener);
      return listener;
    });
    return () => {
      mediaQueryList.forEach((_, index) => {
        env.window.removeEventListener("resize", listenerList[index]);
      });
    };
  }, [query]);
  return matches;
}

/**
 * Visibility
 *
 * React component to control the visibility of its
 * children based on the current breakpoint
 */
const Visibility = props => {
  const {
    breakpoint,
    hide,
    children
  } = props;
  const [show] = useMediaQuery(breakpoint);
  const isVisible = hide ? !show : show;
  const rendered = isVisible ? children : null;
  return rendered;
};

const Hide = props => {
  const {
    children
  } = props;
  const query = useQuery(props);
  return /*#__PURE__*/React.createElement(Visibility, {
    breakpoint: query,
    hide: true
  }, children);
};

if (__DEV__) {
  Hide.displayName = "Hide";
}

const Show = props => {
  const {
    children
  } = props;
  const query = useQuery(props);
  return /*#__PURE__*/React.createElement(Visibility, {
    breakpoint: query
  }, children);
};

if (__DEV__) {
  Show.displayName = "Show";
}

const getBreakpoint = (theme, value) => memoizedGet(theme, `breakpoints.${value}`, value);

function useQuery(props) {
  const {
    breakpoint = "",
    below,
    above
  } = props;
  const theme = useTheme();
  const bpBelow = getBreakpoint(theme, below);
  const bpAbove = getBreakpoint(theme, above);
  let query = breakpoint;

  if (bpBelow) {
    query = `(max-width: ${bpBelow})`;
  } else if (bpAbove) {
    query = `(min-width: ${bpAbove})`;
  }

  return query;
}

/**
 * React hook used to get the user's animation preference.
 */

function usePrefersReducedMotion() {
  const [prefersReducedMotion] = useMediaQuery("(prefers-reduced-motion: reduce)");
  return prefersReducedMotion;
}
/**
 * React hook for getting the user's color mode preference.
 */

function useColorModePreference() {
  const [isDark, isLight] = useMediaQuery(["(prefers-color-scheme: light)", "(prefers-color-scheme: dark)"]);
  if (isLight) return "light";
  if (isDark) return "dark";
  return undefined;
}

function createMediaQueries(breakpoints) {
  return Object.entries(breakpoints) // sort css units in ascending order to ensure media queries are generated
  // in the correct order and reference to each other correctly aswell
  .sort((a, b) => Number.parseInt(a[1], 10) > Number.parseInt(b[1], 10) ? 1 : -1).map(([breakpoint, minWidth], index, arr) => {
    // given a following breakpoint
    const next = arr[index + 1]; // this breakpoint must end prior the threshold of the next

    const maxWidth = next ? next[1] : undefined;
    const query = createMediaQueryString(minWidth, maxWidth);
    return {
      minWidth,
      maxWidth,
      breakpoint,
      query
    };
  });
}
/**
 * Create a media query string from the breakpoints,
 * using a combination of `min-width` and `max-width`.
 */

function createMediaQueryString(minWidth, maxWidth) {
  const hasMinWidth = parseInt(minWidth, 10) >= 0;

  if (!hasMinWidth && !maxWidth) {
    return "";
  }

  let query = `(min-width: ${toMediaString(minWidth)})`;

  if (!maxWidth) {
    return query;
  }

  if (query) {
    query += " and ";
  }

  query += `(max-width: ${toMediaString(subtract(maxWidth))})`;
  return query;
}

const measurementRegex = /(\d+\.?\d*)/u;

const calculateMeasurement = (value, modifier) => {
  if (typeof value === "number") {
    return `${value + modifier}`;
  }

  return value.replace(measurementRegex, match => `${parseFloat(match) + modifier}`);
};
/**
 * 0.01 and 0.1 are too small of a difference for `px` breakpoint values
 *
 * @see https://github.com/chakra-ui/chakra-ui/issues/2188#issuecomment-712774785
 */


function subtract(value) {
  return calculateMeasurement(value, value.endsWith("px") ? -1 : -0.01);
}
/**
 * Convert media query value to string
 */


function toMediaString(value) {
  return isNumber(value) ? `${value}px` : value;
}

/**
 * React hook used to get the current responsive media breakpoint.
 *
 * @param defaultBreakpoint default breakpoint name
 * (in non-window environments like SSR)
 *
 * For SSR, you can use a package like [is-mobile](https://github.com/kaimallea/isMobile)
 * to get the default breakpoint value from the user-agent
 */
function useBreakpoint(defaultBreakpoint) {
  const {
    breakpoints
  } = useTheme();
  const env = useEnvironment();
  const mediaQueries = React__default.useMemo(() => createMediaQueries({
    base: "0px",
    ...breakpoints
  }), [breakpoints]);
  const [currentBreakpoint, setCurrentBreakpoint] = React__default.useState(() => {
    if (!defaultBreakpoint) {
      return undefined;
    }

    const mediaQuery = mediaQueries.find(({
      breakpoint
    }) => breakpoint === defaultBreakpoint);

    if (mediaQuery) {
      const {
        query,
        ...breakpoint
      } = mediaQuery;
      return breakpoint;
    }

    return undefined;
  });
  const current = currentBreakpoint?.breakpoint;
  const update = React__default.useCallback((query, breakpoint) => {
    if (query.matches && current !== breakpoint.breakpoint) {
      setCurrentBreakpoint(breakpoint);
    }
  }, [current]);
  React__default.useEffect(() => {
    const listeners = new Set();
    mediaQueries.forEach(({
      query,
      ...breakpoint
    }) => {
      const mediaQuery = env.window.matchMedia(query); // trigger an initial update to determine media query

      update(mediaQuery, breakpoint);

      const handleChange = () => {
        update(mediaQuery, breakpoint);
      }; // add media query-listener


      mediaQuery.addListener(handleChange); // push the media query list handleChange
      // so we can use it to remove Listener

      listeners.add({
        mediaQuery,
        handleChange
      });
      return () => {
        // clean up 1
        mediaQuery.removeListener(handleChange);
      };
    });
    return () => {
      // clean up 2: for safety
      listeners.forEach(({
        mediaQuery,
        handleChange
      }) => {
        mediaQuery.removeListener(handleChange);
      });
      listeners.clear();
    };
  }, [mediaQueries, breakpoints, update, env.window]);
  return current;
}

function getClosestValue(values, breakpoint, breakpoints$1 = breakpoints) {
  let index = Object.keys(values).indexOf(breakpoint);

  if (index !== -1) {
    return values[breakpoint];
  }

  let stopIndex = breakpoints$1.indexOf(breakpoint);

  while (stopIndex >= 0) {
    const key = breakpoints$1[stopIndex];

    if (values[key] != null) {
      index = stopIndex;
      break;
    }

    stopIndex -= 1;
  }

  if (index !== -1) {
    const key = breakpoints$1[index];
    return values[key];
  }

  return undefined;
}

/**
 * React hook for getting the value for the current breakpoint from the
 * provided responsive values object.
 *
 * @param values
 * @param defaultBreakpoint default breakpoint name
 * (in non-window environments like SSR)
 *
 * For SSR, you can use a package like [is-mobile](https://github.com/kaimallea/isMobile)
 * to get the default breakpoint value from the user-agent
 *
 * @example
 * const width = useBreakpointValue({ base: '150px', md: '250px' })
 */

function useBreakpointValue(values, defaultBreakpoint) {
  const breakpoint = useBreakpoint(defaultBreakpoint);
  const theme = useTheme();
  if (!breakpoint) return undefined;
  /**
   * Get the non-number breakpoint keys from the provided breakpoints
   */

  const breakpoints = Object.keys(theme.breakpoints);
  const obj = isArray(values) ? fromEntries(Object.entries(arrayToObjectNotation(values, breakpoints)).map(([key, value]) => [key, value])) : values;
  return getClosestValue(obj, breakpoint, breakpoints);
}

export { Hide, Show, useBreakpoint, useBreakpointValue, useColorModePreference, useMediaQuery, usePrefersReducedMotion, useQuery };

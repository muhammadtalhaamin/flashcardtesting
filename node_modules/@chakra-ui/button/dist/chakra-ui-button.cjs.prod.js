'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var hooks = require('@chakra-ui/hooks');
var system = require('@chakra-ui/system');
var utils = require('@chakra-ui/utils');
var React = require('react');
var reactUtils = require('@chakra-ui/react-utils');
var spinner = require('@chakra-ui/spinner');

function _interopNamespace(e) {
  if (e && e.__esModule) return e;
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n["default"] = e;
  return Object.freeze(n);
}

var React__namespace = /*#__PURE__*/_interopNamespace(React);

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

const [ButtonGroupProvider, useButtonGroup] = reactUtils.createContext({
  strict: false,
  name: "ButtonGroupContext"
});
const ButtonGroup = /*#__PURE__*/system.forwardRef((props, ref) => {
  const {
    size,
    colorScheme,
    variant,
    className,
    spacing = "0.5rem",
    isAttached,
    isDisabled,
    ...rest
  } = props;

  const _className = utils.cx("chakra-button__group", className);

  const context = React__namespace.useMemo(() => ({
    size,
    colorScheme,
    variant,
    isDisabled
  }), [size, colorScheme, variant, isDisabled]);
  let groupStyles = {
    display: "inline-flex"
  };

  if (isAttached) {
    groupStyles = { ...groupStyles,
      "> *:first-of-type:not(:last-of-type)": {
        borderEndRadius: 0
      },
      "> *:not(:first-of-type):not(:last-of-type)": {
        borderRadius: 0
      },
      "> *:not(:first-of-type):last-of-type": {
        borderStartRadius: 0
      }
    };
  } else {
    groupStyles = { ...groupStyles,
      "& > *:not(style) ~ *:not(style)": {
        marginStart: spacing
      }
    };
  }

  return /*#__PURE__*/React__namespace.createElement(ButtonGroupProvider, {
    value: context
  }, /*#__PURE__*/React__namespace.createElement(system.chakra.div, _extends({
    ref: ref,
    role: "group",
    __css: groupStyles,
    className: _className
  }, rest)));
});

if (utils.__DEV__) {
  ButtonGroup.displayName = "ButtonGroup";
}

const ButtonSpinner = props => {
  const {
    label,
    placement,
    spacing,
    children = /*#__PURE__*/React__namespace.createElement(spinner.Spinner, {
      color: "currentColor",
      width: "1em",
      height: "1em"
    }),
    className,
    __css,
    ...rest
  } = props;

  const _className = utils.cx("chakra-button__spinner", className);

  const marginProp = placement === "start" ? "marginEnd" : "marginStart";
  const spinnerStyles = React__namespace.useMemo(() => ({
    display: "flex",
    alignItems: "center",
    position: label ? "relative" : "absolute",
    [marginProp]: label ? "0.5rem" : 0,
    fontSize: "1em",
    lineHeight: "normal",
    ...__css
  }), [__css, label, marginProp]);
  return /*#__PURE__*/React__namespace.createElement(system.chakra.div, _extends({
    className: _className
  }, rest, {
    __css: spinnerStyles
  }), children);
};

if (utils.__DEV__) {
  ButtonSpinner.displayName = "ButtonSpinner";
}

const ButtonIcon = props => {
  const {
    children,
    className,
    ...rest
  } = props;

  const _children = /*#__PURE__*/React__namespace.isValidElement(children) ? /*#__PURE__*/React__namespace.cloneElement(children, {
    "aria-hidden": true,
    focusable: false
  }) : children;

  const _className = utils.cx("chakra-button__icon", className);

  return /*#__PURE__*/React__namespace.createElement(system.chakra.span, _extends({
    display: "inline-flex",
    alignSelf: "center",
    flexShrink: 0
  }, rest, {
    className: _className
  }), _children);
};

if (utils.__DEV__) {
  ButtonIcon.displayName = "ButtonIcon";
}

function useButtonType(value) {
  const [isButton, setIsButton] = React__namespace.useState(!value);
  const refCallback = React__namespace.useCallback(node => {
    if (!node) return;
    setIsButton(node.tagName === "BUTTON");
  }, []);
  const type = isButton ? "button" : undefined;
  return {
    ref: refCallback,
    type
  };
}

const Button = /*#__PURE__*/system.forwardRef((props, ref) => {
  const group = useButtonGroup();
  const styles = system.useStyleConfig("Button", { ...group,
    ...props
  });
  const {
    isDisabled = group?.isDisabled,
    isLoading,
    isActive,
    isFullWidth,
    children,
    leftIcon,
    rightIcon,
    loadingText,
    iconSpacing = "0.5rem",
    type,
    spinner,
    spinnerPlacement = "start",
    className,
    as,
    ...rest
  } = system.omitThemingProps(props);
  /**
   * When button is used within ButtonGroup (i.e flushed with sibling buttons),
   * it is important to add a `zIndex` on focus.
   *
   * So let's read the component styles and then add `zIndex` to it.
   */

  const buttonStyles = React__namespace.useMemo(() => {
    const _focus = utils.mergeWith({}, styles?.["_focus"] ?? {}, {
      zIndex: 1
    });

    return {
      display: "inline-flex",
      appearance: "none",
      alignItems: "center",
      justifyContent: "center",
      userSelect: "none",
      position: "relative",
      whiteSpace: "nowrap",
      verticalAlign: "middle",
      outline: "none",
      width: isFullWidth ? "100%" : "auto",
      ...styles,
      ...(!!group && {
        _focus
      })
    };
  }, [styles, group, isFullWidth]);
  const {
    ref: _ref,
    type: defaultType
  } = useButtonType(as);
  const contentProps = {
    rightIcon,
    leftIcon,
    iconSpacing,
    children
  };
  return /*#__PURE__*/React__namespace.createElement(system.chakra.button, _extends({
    disabled: isDisabled || isLoading,
    ref: hooks.useMergeRefs(ref, _ref),
    as: as,
    type: type ?? defaultType,
    "data-active": utils.dataAttr(isActive),
    "data-loading": utils.dataAttr(isLoading),
    __css: buttonStyles,
    className: utils.cx("chakra-button", className)
  }, rest), isLoading && spinnerPlacement === "start" && /*#__PURE__*/React__namespace.createElement(ButtonSpinner, {
    className: "chakra-button__spinner--start",
    label: loadingText,
    placement: "start"
  }, spinner), isLoading ? loadingText || /*#__PURE__*/React__namespace.createElement(system.chakra.span, {
    opacity: 0
  }, /*#__PURE__*/React__namespace.createElement(ButtonContent, contentProps)) : /*#__PURE__*/React__namespace.createElement(ButtonContent, contentProps), isLoading && spinnerPlacement === "end" && /*#__PURE__*/React__namespace.createElement(ButtonSpinner, {
    className: "chakra-button__spinner--end",
    label: loadingText,
    placement: "end"
  }, spinner));
});

if (utils.__DEV__) {
  Button.displayName = "Button";
}

function ButtonContent(props) {
  const {
    leftIcon,
    rightIcon,
    children,
    iconSpacing
  } = props;
  return /*#__PURE__*/React__namespace.createElement(React__namespace.Fragment, null, leftIcon && /*#__PURE__*/React__namespace.createElement(ButtonIcon, {
    marginEnd: iconSpacing
  }, leftIcon), children, rightIcon && /*#__PURE__*/React__namespace.createElement(ButtonIcon, {
    marginStart: iconSpacing
  }, rightIcon));
}

const IconButton = /*#__PURE__*/system.forwardRef((props, ref) => {
  const {
    icon,
    children,
    isRound,
    "aria-label": ariaLabel,
    ...rest
  } = props;
  /**
   * Passing the icon as prop or children should work
   */

  const element = icon || children;

  const _children = /*#__PURE__*/React__namespace.isValidElement(element) ? /*#__PURE__*/React__namespace.cloneElement(element, {
    "aria-hidden": true,
    focusable: false
  }) : null;

  return /*#__PURE__*/React__namespace.createElement(Button, _extends({
    padding: "0",
    borderRadius: isRound ? "full" : undefined,
    ref: ref,
    "aria-label": ariaLabel
  }, rest), _children);
});

if (utils.__DEV__) {
  IconButton.displayName = "IconButton";
}

exports.Button = Button;
exports.ButtonGroup = ButtonGroup;
exports.ButtonSpinner = ButtonSpinner;
exports.IconButton = IconButton;
exports.useButtonGroup = useButtonGroup;

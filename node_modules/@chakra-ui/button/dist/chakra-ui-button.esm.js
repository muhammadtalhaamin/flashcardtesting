import { useMergeRefs } from '@chakra-ui/hooks';
import { forwardRef, chakra, useStyleConfig, omitThemingProps } from '@chakra-ui/system';
import { cx, __DEV__, mergeWith, dataAttr } from '@chakra-ui/utils';
import * as React from 'react';
import { createContext } from '@chakra-ui/react-utils';
import { Spinner } from '@chakra-ui/spinner';

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

const [ButtonGroupProvider, useButtonGroup] = createContext({
  strict: false,
  name: "ButtonGroupContext"
});
const ButtonGroup = /*#__PURE__*/forwardRef((props, ref) => {
  const {
    size,
    colorScheme,
    variant,
    className,
    spacing = "0.5rem",
    isAttached,
    isDisabled,
    ...rest
  } = props;

  const _className = cx("chakra-button__group", className);

  const context = React.useMemo(() => ({
    size,
    colorScheme,
    variant,
    isDisabled
  }), [size, colorScheme, variant, isDisabled]);
  let groupStyles = {
    display: "inline-flex"
  };

  if (isAttached) {
    groupStyles = { ...groupStyles,
      "> *:first-of-type:not(:last-of-type)": {
        borderEndRadius: 0
      },
      "> *:not(:first-of-type):not(:last-of-type)": {
        borderRadius: 0
      },
      "> *:not(:first-of-type):last-of-type": {
        borderStartRadius: 0
      }
    };
  } else {
    groupStyles = { ...groupStyles,
      "& > *:not(style) ~ *:not(style)": {
        marginStart: spacing
      }
    };
  }

  return /*#__PURE__*/React.createElement(ButtonGroupProvider, {
    value: context
  }, /*#__PURE__*/React.createElement(chakra.div, _extends({
    ref: ref,
    role: "group",
    __css: groupStyles,
    className: _className
  }, rest)));
});

if (__DEV__) {
  ButtonGroup.displayName = "ButtonGroup";
}

const ButtonSpinner = props => {
  const {
    label,
    placement,
    spacing,
    children = /*#__PURE__*/React.createElement(Spinner, {
      color: "currentColor",
      width: "1em",
      height: "1em"
    }),
    className,
    __css,
    ...rest
  } = props;

  const _className = cx("chakra-button__spinner", className);

  const marginProp = placement === "start" ? "marginEnd" : "marginStart";
  const spinnerStyles = React.useMemo(() => ({
    display: "flex",
    alignItems: "center",
    position: label ? "relative" : "absolute",
    [marginProp]: label ? "0.5rem" : 0,
    fontSize: "1em",
    lineHeight: "normal",
    ...__css
  }), [__css, label, marginProp]);
  return /*#__PURE__*/React.createElement(chakra.div, _extends({
    className: _className
  }, rest, {
    __css: spinnerStyles
  }), children);
};

if (__DEV__) {
  ButtonSpinner.displayName = "ButtonSpinner";
}

const ButtonIcon = props => {
  const {
    children,
    className,
    ...rest
  } = props;

  const _children = /*#__PURE__*/React.isValidElement(children) ? /*#__PURE__*/React.cloneElement(children, {
    "aria-hidden": true,
    focusable: false
  }) : children;

  const _className = cx("chakra-button__icon", className);

  return /*#__PURE__*/React.createElement(chakra.span, _extends({
    display: "inline-flex",
    alignSelf: "center",
    flexShrink: 0
  }, rest, {
    className: _className
  }), _children);
};

if (__DEV__) {
  ButtonIcon.displayName = "ButtonIcon";
}

function useButtonType(value) {
  const [isButton, setIsButton] = React.useState(!value);
  const refCallback = React.useCallback(node => {
    if (!node) return;
    setIsButton(node.tagName === "BUTTON");
  }, []);
  const type = isButton ? "button" : undefined;
  return {
    ref: refCallback,
    type
  };
}

const Button = /*#__PURE__*/forwardRef((props, ref) => {
  const group = useButtonGroup();
  const styles = useStyleConfig("Button", { ...group,
    ...props
  });
  const {
    isDisabled = group?.isDisabled,
    isLoading,
    isActive,
    isFullWidth,
    children,
    leftIcon,
    rightIcon,
    loadingText,
    iconSpacing = "0.5rem",
    type,
    spinner,
    spinnerPlacement = "start",
    className,
    as,
    ...rest
  } = omitThemingProps(props);
  /**
   * When button is used within ButtonGroup (i.e flushed with sibling buttons),
   * it is important to add a `zIndex` on focus.
   *
   * So let's read the component styles and then add `zIndex` to it.
   */

  const buttonStyles = React.useMemo(() => {
    const _focus = mergeWith({}, styles?.["_focus"] ?? {}, {
      zIndex: 1
    });

    return {
      display: "inline-flex",
      appearance: "none",
      alignItems: "center",
      justifyContent: "center",
      userSelect: "none",
      position: "relative",
      whiteSpace: "nowrap",
      verticalAlign: "middle",
      outline: "none",
      width: isFullWidth ? "100%" : "auto",
      ...styles,
      ...(!!group && {
        _focus
      })
    };
  }, [styles, group, isFullWidth]);
  const {
    ref: _ref,
    type: defaultType
  } = useButtonType(as);
  const contentProps = {
    rightIcon,
    leftIcon,
    iconSpacing,
    children
  };
  return /*#__PURE__*/React.createElement(chakra.button, _extends({
    disabled: isDisabled || isLoading,
    ref: useMergeRefs(ref, _ref),
    as: as,
    type: type ?? defaultType,
    "data-active": dataAttr(isActive),
    "data-loading": dataAttr(isLoading),
    __css: buttonStyles,
    className: cx("chakra-button", className)
  }, rest), isLoading && spinnerPlacement === "start" && /*#__PURE__*/React.createElement(ButtonSpinner, {
    className: "chakra-button__spinner--start",
    label: loadingText,
    placement: "start"
  }, spinner), isLoading ? loadingText || /*#__PURE__*/React.createElement(chakra.span, {
    opacity: 0
  }, /*#__PURE__*/React.createElement(ButtonContent, contentProps)) : /*#__PURE__*/React.createElement(ButtonContent, contentProps), isLoading && spinnerPlacement === "end" && /*#__PURE__*/React.createElement(ButtonSpinner, {
    className: "chakra-button__spinner--end",
    label: loadingText,
    placement: "end"
  }, spinner));
});

if (__DEV__) {
  Button.displayName = "Button";
}

function ButtonContent(props) {
  const {
    leftIcon,
    rightIcon,
    children,
    iconSpacing
  } = props;
  return /*#__PURE__*/React.createElement(React.Fragment, null, leftIcon && /*#__PURE__*/React.createElement(ButtonIcon, {
    marginEnd: iconSpacing
  }, leftIcon), children, rightIcon && /*#__PURE__*/React.createElement(ButtonIcon, {
    marginStart: iconSpacing
  }, rightIcon));
}

const IconButton = /*#__PURE__*/forwardRef((props, ref) => {
  const {
    icon,
    children,
    isRound,
    "aria-label": ariaLabel,
    ...rest
  } = props;
  /**
   * Passing the icon as prop or children should work
   */

  const element = icon || children;

  const _children = /*#__PURE__*/React.isValidElement(element) ? /*#__PURE__*/React.cloneElement(element, {
    "aria-hidden": true,
    focusable: false
  }) : null;

  return /*#__PURE__*/React.createElement(Button, _extends({
    padding: "0",
    borderRadius: isRound ? "full" : undefined,
    ref: ref,
    "aria-label": ariaLabel
  }, rest), _children);
});

if (__DEV__) {
  IconButton.displayName = "IconButton";
}

export { Button, ButtonGroup, ButtonSpinner, IconButton, useButtonGroup };

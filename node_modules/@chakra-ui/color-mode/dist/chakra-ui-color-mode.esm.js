import { useEnvironment } from '@chakra-ui/react-env';
import { noop, isBrowser, __DEV__ } from '@chakra-ui/utils';
import * as React from 'react';

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

const classNames = {
  light: "chakra-ui-light",
  dark: "chakra-ui-dark"
};

/**
 * SSR: Graceful fallback for the `body` element
 */
const mockBody = {
  classList: {
    add: noop,
    remove: noop
  }
};

const getBody = document => isBrowser ? document.body : mockBody;
/**
 * Function to add/remove class from `body` based on color mode
 */


function syncBodyClassName(isDark, document) {
  const body = getBody(document);
  body.classList.add(isDark ? classNames.dark : classNames.light);
  body.classList.remove(isDark ? classNames.light : classNames.dark);
}
/**
 * Check if JS media query matches the query string passed
 */

function getMediaQuery(query) {
  const mediaQueryList = window.matchMedia?.(query);

  if (!mediaQueryList) {
    return undefined;
  }

  return !!mediaQueryList.media === mediaQueryList.matches;
}

const queries = {
  light: "(prefers-color-scheme: light)",
  dark: "(prefers-color-scheme: dark)"
};

function getColorScheme(fallback) {
  const isDark = getMediaQuery(queries.dark) ?? fallback === "dark";
  return isDark ? "dark" : "light";
}
/**
 * Adds system os color mode listener, and run the callback
 * once preference changes
 */

function addListener(fn) {
  if (!("matchMedia" in window)) {
    return noop;
  }

  const mediaQueryList = window.matchMedia(queries.dark);

  const listener = () => {
    fn(mediaQueryList.matches ? "dark" : "light", true);
  };

  mediaQueryList.addEventListener("change", listener);
  return () => {
    mediaQueryList.removeEventListener("change", listener);
  };
}
const root = {
  get: () => document.documentElement.style.getPropertyValue("--chakra-ui-color-mode"),
  set: mode => {
    if (isBrowser) {
      document.documentElement.style.setProperty("--chakra-ui-color-mode", mode);
    }
  }
};

const hasSupport = () => typeof Storage !== "undefined";

const storageKey = "chakra-ui-color-mode";

/**
 * Simple object to handle read-write to localStorage
 */
const localStorageManager = {
  get(init) {
    if (!hasSupport()) return init;

    try {
      const value = localStorage.getItem(storageKey);
      return value ?? init;
    } catch (error) {
      if (__DEV__) {
        console.log(error);
      }

      return init;
    }
  },

  set(value) {
    if (!hasSupport()) return;

    try {
      localStorage.setItem(storageKey, value);
    } catch (error) {
      if (__DEV__) {
        console.log(error);
      }
    }
  },

  type: "localStorage"
};
/**
 * Simple object to handle read-write to cookies
 */

const cookieStorageManager = (cookies = "") => ({
  get(init) {
    const match = cookies.match(new RegExp(`(^| )${storageKey}=([^;]+)`));

    if (match) {
      return match[2];
    }

    return init;
  },

  set(value) {
    document.cookie = `${storageKey}=${value}; max-age=31536000; path=/`;
  },

  type: "cookie"
});

const ColorModeContext = /*#__PURE__*/React.createContext({});

if (__DEV__) {
  ColorModeContext.displayName = "ColorModeContext";
}
/**
 * React hook that reads from `ColorModeProvider` context
 * Returns the color mode and function to toggle it
 */


const useColorMode = () => {
  const context = React.useContext(ColorModeContext);

  if (context === undefined) {
    throw new Error("useColorMode must be used within a ColorModeProvider");
  }

  return context;
};

/**
 * Provides context for the color mode based on config in `theme`
 * Returns the color mode and function to toggle the color mode
 */
function ColorModeProvider(props) {
  const {
    value,
    children,
    options: {
      useSystemColorMode,
      initialColorMode
    },
    colorModeManager = localStorageManager
  } = props;
  const defaultColorMode = initialColorMode === "dark" ? "dark" : "light";
  /**
   * Only attempt to retrieve if we're on the server. Else this will result
   * in a hydration mismatch warning and partially invalid visuals.
   *
   * Else fallback safely to `theme.config.initialColormode` (default light)
   */

  const [colorMode, rawSetColorMode] = React.useState(colorModeManager.type === "cookie" ? colorModeManager.get(defaultColorMode) : defaultColorMode);
  const {
    document
  } = useEnvironment();
  React.useEffect(() => {
    /**
     * Since we cannot initially retrieve localStorage to due above mentioned
     * reasons, do so after hydration.
     *
     * Priority:
     * - if `useSystemColorMode` is true system-color will be used as default - initial
     * colormode is the fallback if system color mode isn't resolved
     *
     * - if `--chakra-ui-color-mode` is defined through e.g. `ColorModeScript` this
     * will be used
     *
     * - if `colorModeManager` = `localStorage` and a value is defined for
     * `chakra-ui-color-mode` this will be used
     *
     * - if `initialColorMode` = `system` system-color will be used as default -
     * initial colormode is the fallback if system color mode isn't resolved
     *
     * - if `initialColorMode` = `'light'|'dark'` the corresponding value will be used
     */
    if (isBrowser && colorModeManager.type === "localStorage") {
      const systemColorWithFallback = getColorScheme(defaultColorMode);

      if (useSystemColorMode) {
        return rawSetColorMode(systemColorWithFallback);
      }

      const rootGet = root.get();
      const colorManagerGet = colorModeManager.get();

      if (rootGet) {
        return rawSetColorMode(rootGet);
      }

      if (colorManagerGet) {
        return rawSetColorMode(colorManagerGet);
      }

      if (initialColorMode === "system") {
        return rawSetColorMode(systemColorWithFallback);
      }

      return rawSetColorMode(defaultColorMode);
    }
  }, [colorModeManager, useSystemColorMode, defaultColorMode, initialColorMode]);
  React.useEffect(() => {
    const isDark = colorMode === "dark";
    syncBodyClassName(isDark, document);
    root.set(isDark ? "dark" : "light");
  }, [colorMode, document]);
  const setColorMode = React.useCallback((value, isListenerEvent = false) => {
    if (!isListenerEvent) {
      colorModeManager.set(value);
    } else if (colorModeManager.get() && !useSystemColorMode) return;

    rawSetColorMode(value);
  }, [colorModeManager, useSystemColorMode]);
  const toggleColorMode = React.useCallback(() => {
    setColorMode(colorMode === "light" ? "dark" : "light");
  }, [colorMode, setColorMode]);
  React.useEffect(() => {
    const shouldUseSystemListener = useSystemColorMode || initialColorMode === "system";
    let removeListener;

    if (shouldUseSystemListener) {
      removeListener = addListener(setColorMode);
    }

    return () => {
      if (removeListener && shouldUseSystemListener) {
        removeListener();
      }
    };
  }, [setColorMode, useSystemColorMode, initialColorMode]); // presence of `value` indicates a controlled context

  const context = React.useMemo(() => ({
    colorMode: value ?? colorMode,
    toggleColorMode: value ? noop : toggleColorMode,
    setColorMode: value ? noop : setColorMode
  }), [colorMode, setColorMode, toggleColorMode, value]);
  return /*#__PURE__*/React.createElement(ColorModeContext.Provider, {
    value: context
  }, children);
}

if (__DEV__) {
  ColorModeProvider.displayName = "ColorModeProvider";
}
/**
 * Locks the color mode to `dark`, without any way to change it.
 */


const DarkMode = props => /*#__PURE__*/React.createElement(ColorModeContext.Provider, _extends({
  value: {
    colorMode: "dark",
    toggleColorMode: noop,
    setColorMode: noop
  }
}, props));

if (__DEV__) {
  DarkMode.displayName = "DarkMode";
}
/**
 * Locks the color mode to `light` without any way to change it.
 */


const LightMode = props => /*#__PURE__*/React.createElement(ColorModeContext.Provider, _extends({
  value: {
    colorMode: "light",
    toggleColorMode: noop,
    setColorMode: noop
  }
}, props));

if (__DEV__) {
  LightMode.displayName = "LightMode";
}
/**
 * Change value based on color mode.
 *
 * @param light the light mode value
 * @param dark the dark mode value
 *
 * @example
 *
 * ```js
 * const Icon = useColorModeValue(MoonIcon, SunIcon)
 * ```
 */


function useColorModeValue(light, dark) {
  const {
    colorMode
  } = useColorMode();
  return colorMode === "dark" ? dark : light;
}

function setScript(initialValue) {
  const mql = window.matchMedia("(prefers-color-scheme: dark)");
  const systemPreference = mql.matches ? "dark" : "light";
  let persistedPreference;

  try {
    persistedPreference = localStorage.getItem("chakra-ui-color-mode");
  } catch (error) {
    console.log("Chakra UI: localStorage is not available. Color mode persistence might not work as expected");
  }

  const isInStorage = typeof persistedPreference === "string";
  let colorMode;

  if (isInStorage) {
    colorMode = persistedPreference;
  } else {
    colorMode = initialValue === "system" ? systemPreference : initialValue;
  }

  if (colorMode) {
    const root = document.documentElement;
    root.style.setProperty("--chakra-ui-color-mode", colorMode);
  }
}

/**
 * Script to add to the root of your application when using localStorage,
 * to help prevent flash of color mode that can happen during page load.
 */
const ColorModeScript = props => {
  const {
    initialColorMode = "light"
  } = props;
  const html = `(${String(setScript)})('${initialColorMode}')`;
  return /*#__PURE__*/React.createElement("script", {
    nonce: props.nonce,
    dangerouslySetInnerHTML: {
      __html: html
    }
  });
};

export { ColorModeContext, ColorModeProvider, ColorModeScript, DarkMode, LightMode, cookieStorageManager, localStorageManager, setScript, storageKey, useColorMode, useColorModeValue };

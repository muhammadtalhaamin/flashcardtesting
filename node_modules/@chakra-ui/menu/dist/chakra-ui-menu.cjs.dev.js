'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var system = require('@chakra-ui/system');
var utils = require('@chakra-ui/utils');
var framerMotion = require('framer-motion');
var React = require('react');
var clickable = require('@chakra-ui/clickable');
var descendant = require('@chakra-ui/descendant');
var hooks = require('@chakra-ui/hooks');
var popper = require('@chakra-ui/popper');
var reactUtils = require('@chakra-ui/react-utils');

function _interopNamespace(e) {
  if (e && e.__esModule) return e;
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n["default"] = e;
  return Object.freeze(n);
}

var React__namespace = /*#__PURE__*/_interopNamespace(React);

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

/* -------------------------------------------------------------------------------------------------
 * Create context to track descendants and their indices
 * -----------------------------------------------------------------------------------------------*/

const [MenuDescendantsProvider, useMenuDescendantsContext, useMenuDescendants, useMenuDescendant] = descendant.createDescendantContext();
/* -------------------------------------------------------------------------------------------------
 * Create context to track menu state and logic
 * -----------------------------------------------------------------------------------------------*/

const [MenuProvider, useMenuContext] = reactUtils.createContext({
  strict: false,
  name: "MenuContext"
});
/* -------------------------------------------------------------------------------------------------
 * useMenu hook
 * -----------------------------------------------------------------------------------------------*/

/**
 * React Hook to manage a menu
 *
 * It provides the logic and will be used with react context
 * to propagate its return value to all children
 */
function useMenu(props = {}) {
  const {
    id,
    closeOnSelect = true,
    closeOnBlur = true,
    autoSelect = true,
    isLazy,
    isOpen: isOpenProp,
    defaultIsOpen,
    onClose: onCloseProp,
    onOpen: onOpenProp,
    placement = "bottom-start",
    lazyBehavior = "unmount",
    direction,
    computePositionOnMount = false,
    ...popperProps
  } = props;
  /**
   * Prepare the reference to the menu and disclosure
   */

  const menuRef = React__namespace.useRef(null);
  const buttonRef = React__namespace.useRef(null);
  /**
   * Context to register all menu item nodes
   */

  const descendants = useMenuDescendants();
  const focusMenu = React__namespace.useCallback(() => {
    utils.focus(menuRef.current, {
      nextTick: true,
      selectTextIfInput: false
    });
  }, []);
  const focusFirstItem = React__namespace.useCallback(() => {
    const id = setTimeout(() => {
      const first = descendants.firstEnabled();
      if (first) setFocusedIndex(first.index);
    });
    timeoutIds.current.add(id);
  }, [descendants]);
  const focusLastItem = React__namespace.useCallback(() => {
    const id = setTimeout(() => {
      const last = descendants.lastEnabled();
      if (last) setFocusedIndex(last.index);
    });
    timeoutIds.current.add(id);
  }, [descendants]);
  const onOpenInternal = React__namespace.useCallback(() => {
    onOpenProp?.();

    if (autoSelect) {
      focusFirstItem();
    } else {
      focusMenu();
    }
  }, [autoSelect, focusFirstItem, focusMenu, onOpenProp]);
  const {
    isOpen,
    onOpen,
    onClose,
    onToggle
  } = hooks.useDisclosure({
    isOpen: isOpenProp,
    defaultIsOpen,
    onClose: onCloseProp,
    onOpen: onOpenInternal
  });
  hooks.useOutsideClick({
    enabled: isOpen && closeOnBlur,
    ref: menuRef,
    handler: event => {
      if (!buttonRef.current?.contains(event.target)) {
        onClose();
      }
    }
  });
  /**
   * Add some popper.js for dynamic positioning
   */

  const popper$1 = popper.usePopper({ ...popperProps,
    enabled: isOpen || computePositionOnMount,
    placement,
    direction
  });
  const [focusedIndex, setFocusedIndex] = React__namespace.useState(-1);
  /**
   * Focus the button when we close the menu
   */

  hooks.useUpdateEffect(() => {
    if (!isOpen) {
      setFocusedIndex(-1);
    }
  }, [isOpen]);
  hooks.useFocusOnHide(menuRef, {
    focusRef: buttonRef,
    visible: isOpen,
    shouldFocus: true
  });
  /**
   * Generate unique ids for menu's list and button
   */

  const [buttonId, menuId] = hooks.useIds(id, `menu-button`, `menu-list`);
  const openAndFocusMenu = React__namespace.useCallback(() => {
    onOpen();
    focusMenu();
  }, [onOpen, focusMenu]);
  const timeoutIds = React__namespace.useRef(new Set([]));
  hooks.useUnmountEffect(() => {
    timeoutIds.current.forEach(id => clearTimeout(id));
    timeoutIds.current.clear();
  });
  const openAndFocusFirstItem = React__namespace.useCallback(() => {
    onOpen();
    focusFirstItem();
  }, [focusFirstItem, onOpen]);
  const openAndFocusLastItem = React__namespace.useCallback(() => {
    onOpen();
    focusLastItem();
  }, [onOpen, focusLastItem]);
  const refocus = React__namespace.useCallback(() => {
    const doc = utils.getOwnerDocument(menuRef.current);
    const hasFocusWithin = menuRef.current?.contains(doc.activeElement);
    const shouldRefocus = isOpen && !hasFocusWithin;
    if (!shouldRefocus) return;
    const node = descendants.item(focusedIndex)?.node;

    if (node) {
      utils.focus(node, {
        selectTextIfInput: false,
        preventScroll: false
      });
    }
  }, [isOpen, focusedIndex, descendants]);
  return {
    openAndFocusMenu,
    openAndFocusFirstItem,
    openAndFocusLastItem,
    onTransitionEnd: refocus,
    descendants,
    popper: popper$1,
    buttonId,
    menuId,
    forceUpdate: popper$1.forceUpdate,
    orientation: "vertical",
    isOpen,
    onToggle,
    onOpen,
    onClose,
    menuRef,
    buttonRef,
    focusedIndex,
    closeOnSelect,
    closeOnBlur,
    autoSelect,
    setFocusedIndex,
    isLazy,
    lazyBehavior
  };
}

/**
 * React Hook to manage a menu button.
 *
 * The assumption here is that the `useMenu` hook is used
 * in a component higher up the tree, and its return value
 * is passed as `context` to this hook.
 */
function useMenuButton(props = {}, externalRef = null) {
  const menu = useMenuContext();
  const {
    onToggle,
    popper,
    openAndFocusFirstItem,
    openAndFocusLastItem
  } = menu;
  const onKeyDown = React__namespace.useCallback(event => {
    const eventKey = utils.normalizeEventKey(event);
    const keyMap = {
      Enter: openAndFocusFirstItem,
      ArrowDown: openAndFocusFirstItem,
      ArrowUp: openAndFocusLastItem
    };
    const action = keyMap[eventKey];

    if (action) {
      event.preventDefault();
      event.stopPropagation();
      action(event);
    }
  }, [openAndFocusFirstItem, openAndFocusLastItem]);
  return { ...props,
    ref: reactUtils.mergeRefs(menu.buttonRef, externalRef, popper.referenceRef),
    id: menu.buttonId,
    "data-active": utils.dataAttr(menu.isOpen),
    "aria-expanded": menu.isOpen,
    "aria-haspopup": "menu",
    "aria-controls": menu.menuId,
    onClick: utils.callAllHandlers(props.onClick, onToggle),
    onKeyDown: utils.callAllHandlers(props.onKeyDown, onKeyDown)
  };
}

function isTargetMenuItem(target) {
  // this will catch `menuitem`, `menuitemradio`, `menuitemcheckbox`
  return utils.isHTMLElement(target) && !!target.getAttribute("role")?.startsWith("menuitem");
}
/* -------------------------------------------------------------------------------------------------
 * useMenuList
 * -----------------------------------------------------------------------------------------------*/


/**
 * React Hook to manage a menu list.
 *
 * The assumption here is that the `useMenu` hook is used
 * in a component higher up the tree, and its return value
 * is passed as `context` to this hook.
 */
function useMenuList(props = {}, ref = null) {
  const menu = useMenuContext();

  if (!menu) {
    throw new Error(`useMenuContext: context is undefined. Seems you forgot to wrap component within <Menu>`);
  }

  const {
    focusedIndex,
    setFocusedIndex,
    menuRef,
    isOpen,
    onClose,
    menuId,
    isLazy,
    lazyBehavior
  } = menu;
  const descendants = useMenuDescendantsContext();
  /**
   * Hook that creates a keydown event handler that listens
   * to printable keyboard character press
   */

  const createTypeaheadHandler = hooks.useShortcut({
    preventDefault: event => event.key !== " " && isTargetMenuItem(event.target)
  });
  const onKeyDown = React__namespace.useCallback(event => {
    const eventKey = utils.normalizeEventKey(event);
    const keyMap = {
      Tab: event => event.preventDefault(),
      Escape: onClose,
      ArrowDown: () => {
        const next = descendants.nextEnabled(focusedIndex);
        if (next) setFocusedIndex(next.index);
      },
      ArrowUp: () => {
        const prev = descendants.prevEnabled(focusedIndex);
        if (prev) setFocusedIndex(prev.index);
      }
    };
    const fn = keyMap[eventKey];

    if (fn) {
      event.preventDefault();
      fn(event);
      return;
    }
    /**
     * Typeahead: Based on current character pressed,
     * find the next item to be selected
     */


    const onTypeahead = createTypeaheadHandler(character => {
      const nextItem = utils.getNextItemFromSearch(descendants.values(), character, item => item?.node?.textContent ?? "", descendants.item(focusedIndex));

      if (nextItem) {
        const index = descendants.indexOf(nextItem.node);
        setFocusedIndex(index);
      }
    });

    if (isTargetMenuItem(event.target)) {
      onTypeahead(event);
    }
  }, [descendants, focusedIndex, createTypeaheadHandler, onClose, setFocusedIndex]);
  const hasBeenOpened = React__namespace.useRef(false);

  if (isOpen) {
    hasBeenOpened.current = true;
  }

  const shouldRenderChildren = utils.determineLazyBehavior({
    hasBeenSelected: hasBeenOpened.current,
    isLazy,
    lazyBehavior,
    isSelected: isOpen
  });
  return { ...props,
    ref: reactUtils.mergeRefs(menuRef, ref),
    children: shouldRenderChildren ? props.children : null,
    tabIndex: -1,
    role: "menu",
    id: menuId,
    style: { ...props.style,
      transformOrigin: "var(--popper-transform-origin)"
    },
    "aria-orientation": "vertical",
    onKeyDown: utils.callAllHandlers(props.onKeyDown, onKeyDown)
  };
}
/* -------------------------------------------------------------------------------------------------
 * useMenuPosition: Composes usePopper to position the menu
 * -----------------------------------------------------------------------------------------------*/

function useMenuPositioner(props = {}) {
  const {
    popper,
    isOpen
  } = useMenuContext();
  return popper.getPopperProps({ ...props,
    style: {
      visibility: isOpen ? "visible" : "hidden",
      ...props.style
    }
  });
}
/* -------------------------------------------------------------------------------------------------
 * useMenuItem: Hook for each menu item within the menu list.
   We also use it in `useMenuItemOption`
 * -----------------------------------------------------------------------------------------------*/

function useMenuItem(props = {}, externalRef = null) {
  const {
    onMouseEnter: onMouseEnterProp,
    onMouseMove: onMouseMoveProp,
    onMouseLeave: onMouseLeaveProp,
    onClick: onClickProp,
    isDisabled,
    isFocusable,
    closeOnSelect,
    ...htmlProps
  } = props;
  const menu = useMenuContext();
  const {
    setFocusedIndex,
    focusedIndex,
    closeOnSelect: menuCloseOnSelect,
    onClose,
    menuRef,
    isOpen,
    menuId
  } = menu;
  const ref = React__namespace.useRef(null);
  const id = `${menuId}-menuitem-${hooks.useId()}`;
  /**
   * Register the menuitem's node into the domContext
   */

  const {
    index,
    register
  } = useMenuDescendant({
    disabled: isDisabled && !isFocusable
  });
  const onMouseEnter = React__namespace.useCallback(event => {
    onMouseEnterProp?.(event);
    if (isDisabled) return;
    setFocusedIndex(index);
  }, [setFocusedIndex, index, isDisabled, onMouseEnterProp]);
  const onMouseMove = React__namespace.useCallback(event => {
    onMouseMoveProp?.(event);

    if (ref.current && !utils.isActiveElement(ref.current)) {
      onMouseEnter(event);
    }
  }, [onMouseEnter, onMouseMoveProp]);
  const onMouseLeave = React__namespace.useCallback(event => {
    onMouseLeaveProp?.(event);
    if (isDisabled) return;
    setFocusedIndex(-1);
  }, [setFocusedIndex, isDisabled, onMouseLeaveProp]);
  const onClick = React__namespace.useCallback(event => {
    onClickProp?.(event);
    if (!isTargetMenuItem(event.currentTarget)) return;
    /**
     * Close menu and parent menus, allowing the MenuItem
     * to override its parent menu's `closeOnSelect` prop.
     */

    if (closeOnSelect ?? menuCloseOnSelect) {
      onClose();
    }
  }, [onClose, onClickProp, menuCloseOnSelect, closeOnSelect]);
  const isFocused = index === focusedIndex;
  const trulyDisabled = isDisabled && !isFocusable;
  hooks.useUpdateEffect(() => {
    if (!isOpen) return;

    if (isFocused && !trulyDisabled && ref.current) {
      utils.focus(ref.current, {
        nextTick: true,
        selectTextIfInput: false,
        preventScroll: false
      });
    } else if (menuRef.current && !utils.isActiveElement(menuRef.current)) {
      utils.focus(menuRef.current, {
        preventScroll: false
      });
    }
  }, [isFocused, trulyDisabled, menuRef, isOpen]);
  const clickableProps = clickable.useClickable({
    onClick,
    onMouseEnter,
    onMouseMove,
    onMouseLeave,
    ref: reactUtils.mergeRefs(register, ref, externalRef),
    isDisabled,
    isFocusable
  });
  return { ...htmlProps,
    ...clickableProps,
    id,
    role: "menuitem",
    tabIndex: isFocused ? 0 : -1
  };
}
/* -------------------------------------------------------------------------------------------------
 * useMenuOption: Composes useMenuItem to provide a selectable/checkable menu item
 * -----------------------------------------------------------------------------------------------*/

function useMenuOption(props = {}, ref = null) {
  const {
    type = "radio",
    isChecked,
    ...rest
  } = props;
  const ownProps = useMenuItem(rest, ref);
  return { ...ownProps,
    role: `menuitem${type}`,
    "aria-checked": isChecked
  };
}
/* -------------------------------------------------------------------------------------------------
 * useMenuOptionGroup: Manages the state of multiple selectable menuitem or menu option
 * -----------------------------------------------------------------------------------------------*/

function useMenuOptionGroup(props = {}) {
  const {
    children,
    type = "radio",
    value: valueProp,
    defaultValue,
    onChange: onChangeProp,
    ...htmlProps
  } = props;
  const isRadio = type === "radio";
  const fallback = isRadio ? "" : [];
  const [value, setValue] = hooks.useControllableState({
    defaultValue: defaultValue ?? fallback,
    value: valueProp,
    onChange: onChangeProp
  });
  const onChange = React__namespace.useCallback(selectedValue => {
    if (type === "radio" && utils.isString(value)) {
      setValue(selectedValue);
    }

    if (type === "checkbox" && utils.isArray(value)) {
      const nextValue = value.includes(selectedValue) ? utils.removeItem(value, selectedValue) : utils.addItem(value, selectedValue);
      setValue(nextValue);
    }
  }, [value, setValue, type]);
  const validChildren = reactUtils.getValidChildren(children);
  const clones = validChildren.map(child => {
    /**
     * We've added an internal `id` to each `MenuItemOption`,
     * let's use that for type-checking.
     *
     * We can't rely on displayName or the element's type since
     * they can be changed by the user.
     */
    if (child.type.id !== "MenuItemOption") return child;

    const onClick = event => {
      onChange(child.props.value);
      child.props.onClick?.(event);
    };

    const isChecked = type === "radio" ? child.props.value === value : value.includes(child.props.value);
    return /*#__PURE__*/React__namespace.cloneElement(child, {
      type,
      onClick,
      isChecked
    });
  });
  return { ...htmlProps,
    children: clones
  };
}
function useMenuState() {
  const {
    isOpen,
    onClose
  } = useMenuContext();
  return {
    isOpen,
    onClose
  };
}

/**
 * Menu provides context, state, and focus management
 * to its sub-components. It doesn't render any DOM node.
 */
const Menu = props => {
  const {
    children
  } = props;
  const styles = system.useMultiStyleConfig("Menu", props);
  const ownProps = system.omitThemingProps(props);
  const {
    direction
  } = system.useTheme();
  const {
    descendants,
    ...ctx
  } = useMenu({ ...ownProps,
    direction
  });
  const context = React__namespace.useMemo(() => ctx, [ctx]);
  const {
    isOpen,
    onClose,
    forceUpdate
  } = context;
  return /*#__PURE__*/React__namespace.createElement(MenuDescendantsProvider, {
    value: descendants
  }, /*#__PURE__*/React__namespace.createElement(MenuProvider, {
    value: context
  }, /*#__PURE__*/React__namespace.createElement(system.StylesProvider, {
    value: styles
  }, utils.runIfFn(children, {
    isOpen,
    onClose,
    forceUpdate
  }))));
};

if (utils.__DEV__) {
  Menu.displayName = "Menu";
}

const StyledMenuButton = /*#__PURE__*/system.forwardRef((props, ref) => {
  const styles = system.useStyles();
  return /*#__PURE__*/React__namespace.createElement(system.chakra.button, _extends({
    ref: ref
  }, props, {
    __css: {
      display: "inline-flex",
      appearance: "none",
      alignItems: "center",
      outline: 0,
      ...styles.button
    }
  }));
});
/**
 * The trigger for the menu list. Must be a direct child of `Menu`.
 */

const MenuButton = /*#__PURE__*/system.forwardRef((props, ref) => {
  const {
    children,
    as: As,
    ...rest
  } = props;
  const buttonProps = useMenuButton(rest, ref);
  const Element = As || StyledMenuButton;
  return /*#__PURE__*/React__namespace.createElement(Element, _extends({}, buttonProps, {
    className: utils.cx("chakra-menu__menu-button", props.className)
  }), /*#__PURE__*/React__namespace.createElement(system.chakra.span, {
    __css: {
      pointerEvents: "none",
      flex: "1 1 auto",
      minW: 0
    }
  }, props.children));
});

if (utils.__DEV__) {
  MenuButton.displayName = "MenuButton";
}

const motionVariants = {
  enter: {
    visibility: "visible",
    opacity: 1,
    scale: 1,
    transition: {
      duration: 0.2,
      ease: [0.4, 0, 0.2, 1]
    }
  },
  exit: {
    transitionEnd: {
      visibility: "hidden"
    },
    opacity: 0,
    scale: 0.8,
    transition: {
      duration: 0.1,
      easings: "easeOut"
    }
  }
}; // @future: only call `motion(chakra.div)` when we drop framer-motion v3 support

const MotionDiv = "custom" in framerMotion.motion ? framerMotion.motion.custom(system.chakra.div) : framerMotion.motion(system.chakra.div);
const MenuList = /*#__PURE__*/system.forwardRef((props, ref) => {
  const {
    rootProps,
    ...rest
  } = props;
  const {
    isOpen,
    onTransitionEnd
  } = useMenuContext();
  const menulistProps = useMenuList(rest, ref);
  const positionerProps = useMenuPositioner(rootProps);
  const styles = system.useStyles();
  return /*#__PURE__*/React__namespace.createElement(system.chakra.div, _extends({}, positionerProps, {
    __css: {
      zIndex: props.zIndex ?? styles.list?.zIndex
    }
  }), /*#__PURE__*/React__namespace.createElement(MotionDiv, _extends({}, menulistProps, {
    /**
     * We could call this on either `onAnimationComplete` or `onUpdate`.
     * It seems the re-focusing works better with the `onUpdate`
     */
    onUpdate: onTransitionEnd,
    className: utils.cx("chakra-menu__menu-list", menulistProps.className),
    variants: motionVariants,
    initial: false,
    animate: isOpen ? "enter" : "exit",
    __css: {
      outline: 0,
      ...styles.list
    }
  })));
});

if (utils.__DEV__) {
  MenuList.displayName = "MenuList";
}

const StyledMenuItem = /*#__PURE__*/system.forwardRef((props, ref) => {
  const {
    type,
    ...rest
  } = props;
  const styles = system.useStyles();
  /**
   * Given another component, use its type if present
   * Else, use no type to avoid invalid html, e.g. <a type="button" />
   * Else, fall back to "button"
   */

  const btnType = rest.as ? type ?? undefined : "button";
  const buttonStyles = {
    textDecoration: "none",
    color: "inherit",
    userSelect: "none",
    display: "flex",
    width: "100%",
    alignItems: "center",
    textAlign: "start",
    flex: "0 0 auto",
    outline: 0,
    ...styles.item
  };
  return /*#__PURE__*/React__namespace.createElement(system.chakra.button, _extends({
    ref: ref,
    type: btnType
  }, rest, {
    __css: buttonStyles
  }));
});
const MenuItem = /*#__PURE__*/system.forwardRef((props, ref) => {
  const {
    icon,
    iconSpacing = "0.75rem",
    command,
    commandSpacing = "0.75rem",
    children,
    ...rest
  } = props;
  const menuitemProps = useMenuItem(rest, ref);
  const shouldWrap = icon || command;

  const _children = shouldWrap ? /*#__PURE__*/React__namespace.createElement("span", {
    style: {
      pointerEvents: "none",
      flex: 1
    }
  }, children) : children;

  return /*#__PURE__*/React__namespace.createElement(StyledMenuItem, _extends({}, menuitemProps, {
    className: utils.cx("chakra-menu__menuitem", menuitemProps.className)
  }), icon && /*#__PURE__*/React__namespace.createElement(MenuIcon, {
    fontSize: "0.8em",
    marginEnd: iconSpacing
  }, icon), _children, command && /*#__PURE__*/React__namespace.createElement(MenuCommand, {
    marginStart: commandSpacing
  }, command));
});

if (utils.__DEV__) {
  MenuItem.displayName = "MenuItem";
}

const CheckIcon = props => /*#__PURE__*/React__namespace.createElement("svg", _extends({
  viewBox: "0 0 14 14",
  width: "1em",
  height: "1em"
}, props), /*#__PURE__*/React__namespace.createElement("polygon", {
  fill: "currentColor",
  points: "5.5 11.9993304 14 3.49933039 12.5 2 5.5 8.99933039 1.5 4.9968652 0 6.49933039"
}));

const MenuItemOption = /*#__PURE__*/system.forwardRef((props, ref) => {
  const {
    icon,
    iconSpacing = "0.75rem",
    ...rest
  } = props;
  const optionProps = useMenuOption(rest, ref);
  return /*#__PURE__*/React__namespace.createElement(StyledMenuItem, _extends({}, optionProps, {
    className: utils.cx("chakra-menu__menuitem-option", rest.className)
  }), /*#__PURE__*/React__namespace.createElement(MenuIcon, {
    fontSize: "0.8em",
    marginEnd: iconSpacing,
    opacity: props.isChecked ? 1 : 0
  }, icon || /*#__PURE__*/React__namespace.createElement(CheckIcon, null)), /*#__PURE__*/React__namespace.createElement("span", {
    style: {
      flex: 1
    }
  }, optionProps.children));
});
MenuItemOption.id = "MenuItemOption";

if (utils.__DEV__) {
  MenuItemOption.displayName = "MenuItemOption";
}

const MenuOptionGroup = props => {
  const {
    className,
    title,
    ...rest
  } = props;
  const ownProps = useMenuOptionGroup(rest);
  return /*#__PURE__*/React__namespace.createElement(MenuGroup, _extends({
    title: title,
    className: utils.cx("chakra-menu__option-group", className)
  }, ownProps));
};

if (utils.__DEV__) {
  MenuOptionGroup.displayName = "MenuOptionGroup";
}

const MenuGroup = /*#__PURE__*/system.forwardRef((props, ref) => {
  const {
    title,
    children,
    className,
    ...rest
  } = props;

  const _className = utils.cx("chakra-menu__group__title", className);

  const styles = system.useStyles();
  return /*#__PURE__*/React__namespace.createElement("div", {
    ref: ref,
    className: "chakra-menu__group",
    role: "group"
  }, title && /*#__PURE__*/React__namespace.createElement(system.chakra.p, _extends({
    className: _className
  }, rest, {
    __css: styles.groupTitle
  }), title), children);
});

if (utils.__DEV__) {
  MenuGroup.displayName = "MenuGroup";
}

const MenuCommand = /*#__PURE__*/system.forwardRef((props, ref) => {
  const styles = system.useStyles();
  return /*#__PURE__*/React__namespace.createElement(system.chakra.span, _extends({
    ref: ref
  }, props, {
    __css: styles.command,
    className: "chakra-menu__command"
  }));
});

if (utils.__DEV__) {
  MenuCommand.displayName = "MenuCommand";
}

const MenuIcon = props => {
  const {
    className,
    children,
    ...rest
  } = props;
  const child = React__namespace.Children.only(children);
  const clone = /*#__PURE__*/React__namespace.isValidElement(child) ? /*#__PURE__*/React__namespace.cloneElement(child, {
    focusable: "false",
    "aria-hidden": true,
    className: utils.cx("chakra-menu__icon", child.props.className)
  }) : null;

  const _className = utils.cx("chakra-menu__icon-wrapper", className);

  return /*#__PURE__*/React__namespace.createElement(system.chakra.span, _extends({
    className: _className
  }, rest, {
    __css: {
      flexShrink: 0
    }
  }), clone);
};

if (utils.__DEV__) {
  MenuIcon.displayName = "MenuIcon";
}

const MenuDivider = props => {
  const {
    className,
    ...rest
  } = props;
  const styles = system.useStyles();
  return /*#__PURE__*/React__namespace.createElement(system.chakra.hr, _extends({
    role: "separator",
    "aria-orientation": "horizontal",
    className: utils.cx("chakra-menu__divider", className)
  }, rest, {
    __css: styles.divider
  }));
};

if (utils.__DEV__) {
  MenuDivider.displayName = "MenuDivider";
}

exports.Menu = Menu;
exports.MenuButton = MenuButton;
exports.MenuCommand = MenuCommand;
exports.MenuDescendantsProvider = MenuDescendantsProvider;
exports.MenuDivider = MenuDivider;
exports.MenuGroup = MenuGroup;
exports.MenuIcon = MenuIcon;
exports.MenuItem = MenuItem;
exports.MenuItemOption = MenuItemOption;
exports.MenuList = MenuList;
exports.MenuOptionGroup = MenuOptionGroup;
exports.MenuProvider = MenuProvider;
exports.useMenu = useMenu;
exports.useMenuButton = useMenuButton;
exports.useMenuContext = useMenuContext;
exports.useMenuDescendant = useMenuDescendant;
exports.useMenuDescendants = useMenuDescendants;
exports.useMenuDescendantsContext = useMenuDescendantsContext;
exports.useMenuItem = useMenuItem;
exports.useMenuList = useMenuList;
exports.useMenuOption = useMenuOption;
exports.useMenuOptionGroup = useMenuOptionGroup;
exports.useMenuPositioner = useMenuPositioner;
exports.useMenuState = useMenuState;

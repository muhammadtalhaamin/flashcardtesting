'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var popper = require('@chakra-ui/popper');
var portal = require('@chakra-ui/portal');
var system = require('@chakra-ui/system');
var utils = require('@chakra-ui/utils');
var visuallyHidden = require('@chakra-ui/visually-hidden');
var framerMotion = require('framer-motion');
var React = require('react');
var hooks = require('@chakra-ui/hooks');
var reactUtils = require('@chakra-ui/react-utils');

function _interopNamespace(e) {
  if (e && e.__esModule) return e;
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n["default"] = e;
  return Object.freeze(n);
}

var React__namespace = /*#__PURE__*/_interopNamespace(React);

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

const scale = {
  exit: {
    scale: 0.85,
    opacity: 0,
    transition: {
      opacity: {
        duration: 0.15,
        easings: "easeInOut"
      },
      scale: {
        duration: 0.2,
        easings: "easeInOut"
      }
    }
  },
  enter: {
    scale: 1,
    opacity: 1,
    transition: {
      opacity: {
        easings: "easeOut",
        duration: 0.2
      },
      scale: {
        duration: 0.2,
        ease: [0.175, 0.885, 0.4, 1.1]
      }
    }
  }
};

function useTooltip(props = {}) {
  const {
    openDelay = 0,
    closeDelay = 0,
    closeOnClick = true,
    closeOnMouseDown,
    onOpen: onOpenProp,
    onClose: onCloseProp,
    placement,
    id,
    isOpen: isOpenProp,
    defaultIsOpen,
    arrowSize = 10,
    arrowShadowColor,
    arrowPadding,
    modifiers,
    isDisabled,
    gutter,
    offset,
    direction,
    ...htmlProps
  } = props;
  const {
    isOpen,
    onOpen,
    onClose
  } = hooks.useDisclosure({
    isOpen: isOpenProp,
    defaultIsOpen,
    onOpen: onOpenProp,
    onClose: onCloseProp
  });
  const {
    referenceRef,
    getPopperProps,
    getArrowInnerProps,
    getArrowProps
  } = popper.usePopper({
    enabled: isOpen,
    placement,
    arrowPadding,
    modifiers,
    gutter,
    offset,
    direction
  });
  const tooltipId = hooks.useId(id, "tooltip");
  const ref = React__namespace.useRef(null);
  const enterTimeout = React__namespace.useRef();
  const exitTimeout = React__namespace.useRef();
  const openWithDelay = React__namespace.useCallback(() => {
    if (!isDisabled) {
      enterTimeout.current = window.setTimeout(onOpen, openDelay);
    }
  }, [isDisabled, onOpen, openDelay]);
  const closeWithDelay = React__namespace.useCallback(() => {
    if (enterTimeout.current) {
      clearTimeout(enterTimeout.current);
    }

    exitTimeout.current = window.setTimeout(onClose, closeDelay);
  }, [closeDelay, onClose]);
  const onClick = React__namespace.useCallback(() => {
    if (closeOnClick) {
      closeWithDelay();
    }
  }, [closeOnClick, closeWithDelay]);
  const onMouseDown = React__namespace.useCallback(() => {
    if (closeOnMouseDown) {
      closeWithDelay();
    }
  }, [closeOnMouseDown, closeWithDelay]);

  const onKeyDown = event => {
    if (isOpen && event.key === "Escape") {
      closeWithDelay();
    }
  };

  hooks.useEventListener("keydown", onKeyDown);
  React__namespace.useEffect(() => () => {
    clearTimeout(enterTimeout.current);
    clearTimeout(exitTimeout.current);
  }, []);
  /**
   * This allows for catching mouseleave events when the tooltip
   * trigger is disabled. There's currently a known issue in
   * React regarding the onMouseLeave polyfill.
   * @see https://github.com/facebook/react/issues/11972
   */

  hooks.useEventListener("mouseleave", closeWithDelay, () => ref.current);
  const getTriggerProps = React__namespace.useCallback((props = {}, _ref = null) => {
    const triggerProps = { ...props,
      ref: reactUtils.mergeRefs(ref, _ref, referenceRef),
      onMouseEnter: utils.callAllHandlers(props.onMouseEnter, openWithDelay),
      onClick: utils.callAllHandlers(props.onClick, onClick),
      onMouseDown: utils.callAllHandlers(props.onMouseDown, onMouseDown),
      onFocus: utils.callAllHandlers(props.onFocus, openWithDelay),
      onBlur: utils.callAllHandlers(props.onBlur, closeWithDelay),
      "aria-describedby": isOpen ? tooltipId : undefined
    };
    return triggerProps;
  }, [openWithDelay, closeWithDelay, onMouseDown, isOpen, tooltipId, onClick, referenceRef]);
  const getTooltipPositionerProps = React__namespace.useCallback((props = {}, forwardedRef = null) => getPopperProps({ ...props,
    style: { ...props.style,
      [popper.popperCSSVars.arrowSize.var]: arrowSize ? utils.px(arrowSize) : undefined,
      [popper.popperCSSVars.arrowShadowColor.var]: arrowShadowColor
    }
  }, forwardedRef), [getPopperProps, arrowSize, arrowShadowColor]);
  const getTooltipProps = React__namespace.useCallback((props = {}, _ref = null) => {
    const tooltipProps = {
      ref: _ref,
      ...htmlProps,
      ...props,
      id: tooltipId,
      role: "tooltip",
      style: { ...props.style,
        position: "relative",
        transformOrigin: popper.popperCSSVars.transformOrigin.varRef
      }
    };
    return tooltipProps;
  }, [htmlProps, tooltipId]);
  return {
    isOpen,
    show: openWithDelay,
    hide: closeWithDelay,
    getTriggerProps,
    getTooltipProps,
    getTooltipPositionerProps,
    getArrowProps,
    getArrowInnerProps
  };
}

const StyledTooltip = system.chakra(framerMotion.motion.div);
/**
 * Tooltips display informative text when users hover, focus on, or tap an element.
 *
 * @see Docs     https://chakra-ui.com/components/tooltip
 * @see WAI-ARIA https://www.w3.org/TR/wai-aria-practices/#tooltip
 */

const Tooltip = /*#__PURE__*/system.forwardRef((props, ref) => {
  const styles = system.useStyleConfig("Tooltip", props);
  const ownProps = system.omitThemingProps(props);
  const theme = system.useTheme();
  const {
    children,
    label,
    shouldWrapChildren,
    "aria-label": ariaLabel,
    hasArrow,
    bg,
    portalProps,
    ...rest
  } = ownProps;

  if (bg) {
    styles.bg = bg;
    styles[popper.popperCSSVars.arrowBg.var] = utils.getCSSVar(theme, "colors", bg);
  }

  const tooltip = useTooltip({ ...rest,
    direction: theme.direction
  });
  const shouldWrap = utils.isString(children) || shouldWrapChildren;
  let trigger;

  if (shouldWrap) {
    trigger = /*#__PURE__*/React__namespace.createElement(system.chakra.span, _extends({
      tabIndex: 0
    }, tooltip.getTriggerProps()), children);
  } else {
    /**
     * Ensure tooltip has only one child node
     */
    const child = React__namespace.Children.only(children);
    trigger = /*#__PURE__*/React__namespace.cloneElement(child, tooltip.getTriggerProps(child.props, child.ref));
  }

  const hasAriaLabel = !!ariaLabel;

  const _tooltipProps = tooltip.getTooltipProps({}, ref);

  const tooltipProps = hasAriaLabel ? utils.omit(_tooltipProps, ["role", "id"]) : _tooltipProps;
  const hiddenProps = utils.pick(_tooltipProps, ["role", "id"]);
  /**
   * If the `label` is empty, there's no
   * point showing the tooltip. Let's simply return back the children
   */

  if (!label) {
    return /*#__PURE__*/React__namespace.createElement(React__namespace.Fragment, null, children);
  }

  return /*#__PURE__*/React__namespace.createElement(React__namespace.Fragment, null, trigger, /*#__PURE__*/React__namespace.createElement(framerMotion.AnimatePresence, null, tooltip.isOpen && /*#__PURE__*/React__namespace.createElement(portal.Portal, portalProps, /*#__PURE__*/React__namespace.createElement(system.chakra.div, _extends({}, tooltip.getTooltipPositionerProps(), {
    __css: {
      zIndex: styles.zIndex,
      pointerEvents: "none"
    }
  }), /*#__PURE__*/React__namespace.createElement(StyledTooltip, _extends({
    variants: scale
  }, tooltipProps, {
    initial: "exit",
    animate: "enter",
    exit: "exit",
    __css: styles
  }), label, hasAriaLabel && /*#__PURE__*/React__namespace.createElement(visuallyHidden.VisuallyHidden, hiddenProps, ariaLabel), hasArrow && /*#__PURE__*/React__namespace.createElement(system.chakra.div, {
    "data-popper-arrow": true,
    className: "chakra-tooltip__arrow-wrapper"
  }, /*#__PURE__*/React__namespace.createElement(system.chakra.div, {
    "data-popper-arrow-inner": true,
    className: "chakra-tooltip__arrow",
    __css: {
      bg: styles.bg
    }
  })))))));
});

if (utils.__DEV__) {
  Tooltip.displayName = "Tooltip";
}

exports.Tooltip = Tooltip;
exports.useTooltip = useTooltip;

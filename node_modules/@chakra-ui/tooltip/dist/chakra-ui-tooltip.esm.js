import { usePopper, popperCSSVars } from '@chakra-ui/popper';
import { Portal } from '@chakra-ui/portal';
import { chakra, forwardRef, useStyleConfig, omitThemingProps, useTheme } from '@chakra-ui/system';
import { callAllHandlers, px, getCSSVar, isString, omit, pick, __DEV__ } from '@chakra-ui/utils';
import { VisuallyHidden } from '@chakra-ui/visually-hidden';
import { motion, AnimatePresence } from 'framer-motion';
import * as React from 'react';
import { useDisclosure, useId, useEventListener } from '@chakra-ui/hooks';
import { mergeRefs } from '@chakra-ui/react-utils';

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

const scale = {
  exit: {
    scale: 0.85,
    opacity: 0,
    transition: {
      opacity: {
        duration: 0.15,
        easings: "easeInOut"
      },
      scale: {
        duration: 0.2,
        easings: "easeInOut"
      }
    }
  },
  enter: {
    scale: 1,
    opacity: 1,
    transition: {
      opacity: {
        easings: "easeOut",
        duration: 0.2
      },
      scale: {
        duration: 0.2,
        ease: [0.175, 0.885, 0.4, 1.1]
      }
    }
  }
};

function useTooltip(props = {}) {
  const {
    openDelay = 0,
    closeDelay = 0,
    closeOnClick = true,
    closeOnMouseDown,
    onOpen: onOpenProp,
    onClose: onCloseProp,
    placement,
    id,
    isOpen: isOpenProp,
    defaultIsOpen,
    arrowSize = 10,
    arrowShadowColor,
    arrowPadding,
    modifiers,
    isDisabled,
    gutter,
    offset,
    direction,
    ...htmlProps
  } = props;
  const {
    isOpen,
    onOpen,
    onClose
  } = useDisclosure({
    isOpen: isOpenProp,
    defaultIsOpen,
    onOpen: onOpenProp,
    onClose: onCloseProp
  });
  const {
    referenceRef,
    getPopperProps,
    getArrowInnerProps,
    getArrowProps
  } = usePopper({
    enabled: isOpen,
    placement,
    arrowPadding,
    modifiers,
    gutter,
    offset,
    direction
  });
  const tooltipId = useId(id, "tooltip");
  const ref = React.useRef(null);
  const enterTimeout = React.useRef();
  const exitTimeout = React.useRef();
  const openWithDelay = React.useCallback(() => {
    if (!isDisabled) {
      enterTimeout.current = window.setTimeout(onOpen, openDelay);
    }
  }, [isDisabled, onOpen, openDelay]);
  const closeWithDelay = React.useCallback(() => {
    if (enterTimeout.current) {
      clearTimeout(enterTimeout.current);
    }

    exitTimeout.current = window.setTimeout(onClose, closeDelay);
  }, [closeDelay, onClose]);
  const onClick = React.useCallback(() => {
    if (closeOnClick) {
      closeWithDelay();
    }
  }, [closeOnClick, closeWithDelay]);
  const onMouseDown = React.useCallback(() => {
    if (closeOnMouseDown) {
      closeWithDelay();
    }
  }, [closeOnMouseDown, closeWithDelay]);

  const onKeyDown = event => {
    if (isOpen && event.key === "Escape") {
      closeWithDelay();
    }
  };

  useEventListener("keydown", onKeyDown);
  React.useEffect(() => () => {
    clearTimeout(enterTimeout.current);
    clearTimeout(exitTimeout.current);
  }, []);
  /**
   * This allows for catching mouseleave events when the tooltip
   * trigger is disabled. There's currently a known issue in
   * React regarding the onMouseLeave polyfill.
   * @see https://github.com/facebook/react/issues/11972
   */

  useEventListener("mouseleave", closeWithDelay, () => ref.current);
  const getTriggerProps = React.useCallback((props = {}, _ref = null) => {
    const triggerProps = { ...props,
      ref: mergeRefs(ref, _ref, referenceRef),
      onMouseEnter: callAllHandlers(props.onMouseEnter, openWithDelay),
      onClick: callAllHandlers(props.onClick, onClick),
      onMouseDown: callAllHandlers(props.onMouseDown, onMouseDown),
      onFocus: callAllHandlers(props.onFocus, openWithDelay),
      onBlur: callAllHandlers(props.onBlur, closeWithDelay),
      "aria-describedby": isOpen ? tooltipId : undefined
    };
    return triggerProps;
  }, [openWithDelay, closeWithDelay, onMouseDown, isOpen, tooltipId, onClick, referenceRef]);
  const getTooltipPositionerProps = React.useCallback((props = {}, forwardedRef = null) => getPopperProps({ ...props,
    style: { ...props.style,
      [popperCSSVars.arrowSize.var]: arrowSize ? px(arrowSize) : undefined,
      [popperCSSVars.arrowShadowColor.var]: arrowShadowColor
    }
  }, forwardedRef), [getPopperProps, arrowSize, arrowShadowColor]);
  const getTooltipProps = React.useCallback((props = {}, _ref = null) => {
    const tooltipProps = {
      ref: _ref,
      ...htmlProps,
      ...props,
      id: tooltipId,
      role: "tooltip",
      style: { ...props.style,
        position: "relative",
        transformOrigin: popperCSSVars.transformOrigin.varRef
      }
    };
    return tooltipProps;
  }, [htmlProps, tooltipId]);
  return {
    isOpen,
    show: openWithDelay,
    hide: closeWithDelay,
    getTriggerProps,
    getTooltipProps,
    getTooltipPositionerProps,
    getArrowProps,
    getArrowInnerProps
  };
}

const StyledTooltip = chakra(motion.div);
/**
 * Tooltips display informative text when users hover, focus on, or tap an element.
 *
 * @see Docs     https://chakra-ui.com/components/tooltip
 * @see WAI-ARIA https://www.w3.org/TR/wai-aria-practices/#tooltip
 */

const Tooltip = /*#__PURE__*/forwardRef((props, ref) => {
  const styles = useStyleConfig("Tooltip", props);
  const ownProps = omitThemingProps(props);
  const theme = useTheme();
  const {
    children,
    label,
    shouldWrapChildren,
    "aria-label": ariaLabel,
    hasArrow,
    bg,
    portalProps,
    ...rest
  } = ownProps;

  if (bg) {
    styles.bg = bg;
    styles[popperCSSVars.arrowBg.var] = getCSSVar(theme, "colors", bg);
  }

  const tooltip = useTooltip({ ...rest,
    direction: theme.direction
  });
  const shouldWrap = isString(children) || shouldWrapChildren;
  let trigger;

  if (shouldWrap) {
    trigger = /*#__PURE__*/React.createElement(chakra.span, _extends({
      tabIndex: 0
    }, tooltip.getTriggerProps()), children);
  } else {
    /**
     * Ensure tooltip has only one child node
     */
    const child = React.Children.only(children);
    trigger = /*#__PURE__*/React.cloneElement(child, tooltip.getTriggerProps(child.props, child.ref));
  }

  const hasAriaLabel = !!ariaLabel;

  const _tooltipProps = tooltip.getTooltipProps({}, ref);

  const tooltipProps = hasAriaLabel ? omit(_tooltipProps, ["role", "id"]) : _tooltipProps;
  const hiddenProps = pick(_tooltipProps, ["role", "id"]);
  /**
   * If the `label` is empty, there's no
   * point showing the tooltip. Let's simply return back the children
   */

  if (!label) {
    return /*#__PURE__*/React.createElement(React.Fragment, null, children);
  }

  return /*#__PURE__*/React.createElement(React.Fragment, null, trigger, /*#__PURE__*/React.createElement(AnimatePresence, null, tooltip.isOpen && /*#__PURE__*/React.createElement(Portal, portalProps, /*#__PURE__*/React.createElement(chakra.div, _extends({}, tooltip.getTooltipPositionerProps(), {
    __css: {
      zIndex: styles.zIndex,
      pointerEvents: "none"
    }
  }), /*#__PURE__*/React.createElement(StyledTooltip, _extends({
    variants: scale
  }, tooltipProps, {
    initial: "exit",
    animate: "enter",
    exit: "exit",
    __css: styles
  }), label, hasAriaLabel && /*#__PURE__*/React.createElement(VisuallyHidden, hiddenProps, ariaLabel), hasArrow && /*#__PURE__*/React.createElement(chakra.div, {
    "data-popper-arrow": true,
    className: "chakra-tooltip__arrow-wrapper"
  }, /*#__PURE__*/React.createElement(chakra.div, {
    "data-popper-arrow-inner": true,
    className: "chakra-tooltip__arrow",
    __css: {
      bg: styles.bg
    }
  })))))));
});

if (__DEV__) {
  Tooltip.displayName = "Tooltip";
}

export { Tooltip, useTooltip };

'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var alert = require('@chakra-ui/alert');
var closeButton = require('@chakra-ui/close-button');
var system = require('@chakra-ui/system');
var defaultTheme = require('@chakra-ui/theme');
var utils = require('@chakra-ui/utils');
var React = require('react');
var reactDom = require('react-dom');
var framerMotion = require('framer-motion');
var hooks = require('@chakra-ui/hooks');
var ReachAlert = require('@reach/alert');

function _interopDefault (e) { return e && e.__esModule ? e : { 'default': e }; }

function _interopNamespace(e) {
  if (e && e.__esModule) return e;
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n["default"] = e;
  return Object.freeze(n);
}

var defaultTheme__default = /*#__PURE__*/_interopDefault(defaultTheme);
var React__namespace = /*#__PURE__*/_interopNamespace(React);
var ReachAlert__default = /*#__PURE__*/_interopDefault(ReachAlert);

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

/**
 * Given an array of toasts for a specific position.
 * It returns the toast that matches the `id` passed
 */
/**
 * Given the toast manager state, finds the toast that matches
 * the id and return its position and index
 */

function findToast(toasts, id) {
  const position = getToastPosition(toasts, id);
  const index = position ? toasts[position].findIndex(toast => toast.id === id) : -1;
  return {
    position,
    index
  };
}
/**
 * Given the toast manager state, finds the position of the toast that
 * matches the `id`
 */

const getToastPosition = (toasts, id) => Object.values(toasts).flat().find(toast => toast.id === id)?.position;
/**
 * Get's the styles to be applied to a toast's container
 * based on its position in the manager
 */

function getToastStyle(position) {
  const isRighty = position.includes("right");
  const isLefty = position.includes("left");
  let alignItems = "center";
  if (isRighty) alignItems = "flex-end";
  if (isLefty) alignItems = "flex-start";
  return {
    display: "flex",
    flexDirection: "column",
    alignItems
  };
}

/**
 * @todo After Gerrit refactors this implementation,
 * allow users to change the toast transition direction from
 * a `ToastProvider` component.
 *
 * Here's an API example:
 *
 * ```jsx
 * <ToastProvider
 *   motion={customVariants}
 *   component={CustomToastComponent}
 *   autoCloseTimeout={3000}
 *   toastSpacing={32} // this will control the `margin` value applied
 * >
 * </ToastProvider>
 * ```
 */

const toastMotionVariants = {
  initial: props => {
    const {
      position
    } = props;
    const dir = ["top", "bottom"].includes(position) ? "y" : "x";
    let factor = ["top-right", "bottom-right"].includes(position) ? 1 : -1;
    if (position === "bottom") factor = 1;
    return {
      opacity: 0,
      [dir]: factor * 24
    };
  },
  animate: {
    opacity: 1,
    y: 0,
    x: 0,
    scale: 1,
    transition: {
      duration: 0.4,
      ease: [0.4, 0, 0.2, 1]
    }
  },
  exit: {
    opacity: 0,
    scale: 0.85,
    transition: {
      duration: 0.2,
      ease: [0.4, 0, 1, 1]
    }
  }
};
const Toast$1 = props => {
  const {
    id,
    message,
    onCloseComplete,
    onRequestRemove,
    requestClose = false,
    position = "bottom",
    duration = 5000
  } = props;
  const [delay, setDelay] = React__namespace.useState(duration);
  const isPresent = framerMotion.useIsPresent();
  hooks.useUpdateEffect(() => {
    if (!isPresent) {
      onCloseComplete?.();
    }
  }, [isPresent]);
  hooks.useUpdateEffect(() => {
    setDelay(duration);
  }, [duration]);

  const onMouseEnter = () => setDelay(null);

  const onMouseLeave = () => setDelay(duration);

  const close = () => {
    if (isPresent) onRequestRemove();
  };

  React__namespace.useEffect(() => {
    if (isPresent && requestClose) {
      onRequestRemove();
    }
  }, [isPresent, requestClose, onRequestRemove]);
  hooks.useTimeout(close, delay);
  const style = React__namespace.useMemo(() => getToastStyle(position), [position]);
  return /*#__PURE__*/React__namespace.createElement(framerMotion.motion.li, {
    layout: true,
    className: "chakra-toast",
    variants: toastMotionVariants,
    initial: "initial",
    animate: "animate",
    exit: "exit",
    onHoverStart: onMouseEnter,
    onHoverEnd: onMouseLeave,
    custom: {
      position
    },
    style: style
  }, /*#__PURE__*/React__namespace.createElement(ReachAlert__default["default"], {
    className: "chakra-toast__inner",
    style: {
      pointerEvents: "auto",
      maxWidth: 560,
      minWidth: 300,
      margin: "0.5rem"
    }
  }, utils.isFunction(message) ? message({
    id,
    onClose: close
  }) : message));
};

if (utils.__DEV__) {
  Toast$1.displayName = "Toast";
}

/**
 * Manages the creation, and removal of toasts
 * across all corners ("top", "bottom", etc.)
 */
class ToastManager extends React__namespace.Component {
  /**
   * Static id counter to create unique ids
   * for each toast
   */

  /**
   * State to track all the toast across all positions
   */
  constructor(props) {
    super(props);
    this.state = {
      top: [],
      "top-left": [],
      "top-right": [],
      "bottom-left": [],
      bottom: [],
      "bottom-right": []
    };

    this.notify = (message, options) => {
      const toast = this.createToast(message, options);
      const {
        position,
        id
      } = toast;
      this.setState(prevToasts => {
        const isTop = position.includes("top");
        /**
         * - If the toast is positioned at the top edges, the
         * recent toast stacks on top of the other toasts.
         *
         * - If the toast is positioned at the bottom edges, the recent
         * toast stacks below the other toasts.
         */

        const toasts = isTop ? [toast, ...prevToasts[position]] : [...prevToasts[position], toast];
        return { ...prevToasts,
          [position]: toasts
        };
      });
      return id;
    };

    this.updateToast = (id, options) => {
      this.setState(prevState => {
        const nextState = { ...prevState
        };
        const {
          position,
          index
        } = findToast(nextState, id);

        if (position && index !== -1) {
          nextState[position][index] = { ...nextState[position][index],
            ...options
          };
        }

        return nextState;
      });
    };

    this.closeAll = ({
      positions
    } = {}) => {
      // only one setState here for perf reasons
      // instead of spamming this.closeToast
      this.setState(prev => {
        const allPositions = ["bottom", "bottom-right", "bottom-left", "top", "top-left", "top-right"];
        const positionsToClose = positions ?? allPositions;
        return positionsToClose.reduce((acc, position) => {
          acc[position] = prev[position].map(toast => ({ ...toast,
            requestClose: true
          }));
          return acc;
        }, {});
      });
    };

    this.createToast = (message, options) => {
      ToastManager.counter += 1;
      const id = options.id ?? ToastManager.counter;
      const position = options.position ?? "top";
      return {
        id,
        message,
        position,
        duration: options.duration,
        onCloseComplete: options.onCloseComplete,
        onRequestRemove: () => this.removeToast(String(id), position),
        status: options.status,
        requestClose: false
      };
    };

    this.closeToast = id => {
      this.setState(prevState => {
        const position = getToastPosition(prevState, id);
        if (!position) return prevState;
        return { ...prevState,
          [position]: prevState[position].map(toast => {
            // id may be string or number
            // eslint-disable-next-line eqeqeq
            if (toast.id == id) {
              return { ...toast,
                requestClose: true
              };
            }

            return toast;
          })
        };
      });
    };

    this.removeToast = (id, position) => {
      this.setState(prevState => ({ ...prevState,
        // id may be string or number
        // eslint-disable-next-line eqeqeq
        [position]: prevState[position].filter(toast => toast.id != id)
      }));
    };

    this.isVisible = id => {
      const {
        position
      } = findToast(this.state, id);
      return Boolean(position);
    };

    this.getStyle = position => {
      const isTopOrBottom = position === "top" || position === "bottom";
      const margin = isTopOrBottom ? "0 auto" : undefined;
      const top = position.includes("top") ? "env(safe-area-inset-top, 0px)" : undefined;
      const bottom = position.includes("bottom") ? "env(safe-area-inset-bottom, 0px)" : undefined;
      const right = !position.includes("left") ? "env(safe-area-inset-right, 0px)" : undefined;
      const left = !position.includes("right") ? "env(safe-area-inset-left, 0px)" : undefined;
      return {
        position: "fixed",
        zIndex: 5500,
        pointerEvents: "none",
        display: "flex",
        flexDirection: "column",
        margin,
        top,
        bottom,
        right,
        left
      };
    };

    const methods = {
      notify: this.notify,
      closeAll: this.closeAll,
      close: this.closeToast,
      update: this.updateToast,
      isActive: this.isVisible
    };
    props.notify(methods);
  }
  /**
   * Function to actually create a toast and add it
   * to state at the specified position
   */


  render() {
    return utils.objectKeys(this.state).map(position => {
      const toasts = this.state[position];
      return /*#__PURE__*/React__namespace.createElement("ul", {
        key: position,
        id: `chakra-toast-manager-${position}`,
        style: this.getStyle(position)
      }, /*#__PURE__*/React__namespace.createElement(framerMotion.AnimatePresence, {
        initial: false
      }, toasts.map(toast => /*#__PURE__*/React__namespace.createElement(Toast$1, _extends({
        key: toast.id
      }, toast)))));
    });
  }

}
ToastManager.counter = 0;

const portalId = "chakra-toast-portal";

class Toaster {
  /**
   * Initialize the manager and mount it in the DOM
   * inside the portal node.
   *
   * @todo
   *
   * Update toast constructor to use `PortalManager`'s node or document.body.
   * Once done, we can remove the `zIndex` in `toast.manager.tsx`
   */
  constructor() {
    this.createToast = void 0;
    this.removeAll = void 0;
    this.closeToast = void 0;
    this.updateToast = void 0;
    this.isToastActive = void 0;

    this.bindFunctions = methods => {
      this.createToast = methods.notify;
      this.removeAll = methods.closeAll;
      this.closeToast = methods.close;
      this.updateToast = methods.update;
      this.isToastActive = methods.isActive;
    };

    this.notify = (message, options = {}) => this.createToast?.(message, options);

    this.close = id => {
      this.closeToast?.(id);
    };

    this.closeAll = options => {
      this.removeAll?.(options);
    };

    this.update = (id, options = {}) => {
      this.updateToast?.(id, options);
    };

    this.isActive = id => this.isToastActive?.(id);

    if (!utils.isBrowser) return;
    let portal;
    const existingPortal = document.getElementById(portalId);

    if (existingPortal) {
      portal = existingPortal;
    } else {
      const div = document.createElement("div");
      div.id = portalId;
      document.body?.appendChild(div);
      portal = div;
    }

    reactDom.render( /*#__PURE__*/React__namespace.createElement(ToastManager, {
      notify: this.bindFunctions
    }), portal);
  }

}

const toast = new Toaster();

function getToastPlacement(position, dir) {
  if (!position) return;
  const logicals = {
    "top-start": {
      ltr: "top-left",
      rtl: "top-right"
    },
    "top-end": {
      ltr: "top-right",
      rtl: "top-left"
    },
    "bottom-start": {
      ltr: "bottom-left",
      rtl: "bottom-right"
    },
    "bottom-end": {
      ltr: "bottom-right",
      rtl: "bottom-left"
    }
  };
  const logical = logicals[position];
  return logical?.[dir] ?? position;
}

const Toast = props => {
  const {
    status,
    variant,
    id,
    title,
    isClosable,
    onClose,
    description
  } = props;
  const alertTitleId = typeof id !== "undefined" ? `toast-${id}-title` : undefined;
  return /*#__PURE__*/React__namespace.createElement(alert.Alert, {
    status: status,
    variant: variant,
    id: id,
    alignItems: "start",
    borderRadius: "md",
    boxShadow: "lg",
    paddingEnd: 8,
    textAlign: "start",
    width: "auto",
    "aria-labelledby": alertTitleId
  }, /*#__PURE__*/React__namespace.createElement(alert.AlertIcon, null), /*#__PURE__*/React__namespace.createElement(system.chakra.div, {
    flex: "1",
    maxWidth: "100%"
  }, title && /*#__PURE__*/React__namespace.createElement(alert.AlertTitle, {
    id: alertTitleId
  }, title), description && /*#__PURE__*/React__namespace.createElement(alert.AlertDescription, {
    display: "block"
  }, description)), isClosable && /*#__PURE__*/React__namespace.createElement(closeButton.CloseButton, {
    size: "sm",
    onClick: onClose,
    position: "absolute",
    insetEnd: 1,
    top: 1
  }));
};

const defaults = {
  duration: 5000,
  position: "bottom",
  variant: "solid"
};
const defaultStandaloneParam = {
  theme: defaultTheme__default["default"],
  colorMode: "light",
  toggleColorMode: utils.noop,
  setColorMode: utils.noop,
  defaultOptions: defaults
};
/**
 * Create a toast from outside of React Components
 */

function createStandaloneToast({
  theme = defaultStandaloneParam.theme,
  colorMode = defaultStandaloneParam.colorMode,
  toggleColorMode = defaultStandaloneParam.toggleColorMode,
  setColorMode = defaultStandaloneParam.setColorMode,
  defaultOptions = defaultStandaloneParam.defaultOptions
} = defaultStandaloneParam) {
  const renderWithProviders = (props, options) => /*#__PURE__*/React__namespace.createElement(system.ThemeProvider, {
    theme: theme
  }, /*#__PURE__*/React__namespace.createElement(system.ColorModeContext.Provider, {
    value: {
      colorMode,
      setColorMode,
      toggleColorMode
    }
  }, utils.isFunction(options.render) ? options.render(props) : /*#__PURE__*/React__namespace.createElement(Toast, _extends({}, props, options))));

  const toastImpl = options => {
    const opts = { ...defaultOptions,
      ...options
    };
    opts.position = getToastPlacement(opts.position, theme.direction);

    const Message = props => renderWithProviders(props, opts);

    return toast.notify(Message, opts);
  };

  toastImpl.close = toast.close;
  toastImpl.closeAll = toast.closeAll; // toasts can only be updated if they have a valid id

  toastImpl.update = (id, options) => {
    if (!id) return;
    const opts = { ...defaultOptions,
      ...options
    };
    opts.position = getToastPlacement(opts.position, theme.direction);
    toast.update(id, { ...opts,
      message: props => renderWithProviders(props, opts)
    });
  };

  toastImpl.isActive = toast.isActive;
  return toastImpl;
}
/**
 * React hook used to create a function that can be used
 * to show toasts in an application.
 */

function useToast(options) {
  const {
    theme,
    setColorMode,
    toggleColorMode,
    colorMode
  } = system.useChakra();
  return React__namespace.useMemo(() => {
    return createStandaloneToast({
      theme,
      colorMode,
      setColorMode,
      toggleColorMode,
      defaultOptions: options
    });
  }, [theme, setColorMode, toggleColorMode, colorMode, options]);
}

exports.createStandaloneToast = createStandaloneToast;
exports.defaultStandaloneParam = defaultStandaloneParam;
exports.toast = toast;
exports.useToast = useToast;

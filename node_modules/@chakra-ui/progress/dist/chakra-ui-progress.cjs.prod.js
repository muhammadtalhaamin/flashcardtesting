'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var system = require('@chakra-ui/system');
var utils = require('@chakra-ui/utils');
var React = require('react');

function _interopNamespace(e) {
  if (e && e.__esModule) return e;
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n["default"] = e;
  return Object.freeze(n);
}

var React__namespace = /*#__PURE__*/_interopNamespace(React);

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

const spin = system.keyframes({
  "0%": {
    strokeDasharray: "1, 400",
    strokeDashoffset: "0"
  },
  "50%": {
    strokeDasharray: "400, 400",
    strokeDashoffset: "-100"
  },
  "100%": {
    strokeDasharray: "400, 400",
    strokeDashoffset: "-260"
  }
});
const rotate = system.keyframes({
  "0%": {
    transform: "rotate(0deg)"
  },
  "100%": {
    transform: "rotate(360deg)"
  }
});
const progress = system.keyframes({
  "0%": {
    left: "-40%"
  },
  "100%": {
    left: "100%"
  }
});
const stripe = system.keyframes({
  from: {
    backgroundPosition: "1rem 0"
  },
  to: {
    backgroundPosition: "0 0"
  }
});

/**
 * Get the common `aria-*` attributes for both the linear and circular
 * progress components.
 */
function getProgressProps(options) {
  const {
    value = 0,
    min,
    max,
    valueText,
    getValueText,
    isIndeterminate
  } = options;
  const percent = utils.valueToPercent(value, min, max);

  const getAriaValueText = () => {
    if (value == null) return undefined;
    return utils.isFunction(getValueText) ? getValueText(value, percent) : valueText;
  };

  return {
    bind: {
      "data-indeterminate": isIndeterminate ? "" : undefined,
      "aria-valuemax": max,
      "aria-valuemin": min,
      "aria-valuenow": isIndeterminate ? undefined : value,
      "aria-valuetext": getAriaValueText(),
      role: "progressbar"
    },
    percent,
    value
  };
}

const Circle = props => /*#__PURE__*/React__namespace.createElement(system.chakra.circle, _extends({
  cx: 50,
  cy: 50,
  r: 42,
  fill: "transparent"
}, props));

if (utils.__DEV__) {
  Circle.displayName = "Circle";
}

const Shape = props => {
  const {
    size,
    isIndeterminate,
    ...rest
  } = props;
  return /*#__PURE__*/React__namespace.createElement(system.chakra.svg, _extends({
    viewBox: "0 0 100 100",
    __css: {
      width: size,
      height: size,
      animation: isIndeterminate ? `${rotate} 2s linear infinite` : undefined
    }
  }, rest));
};

if (utils.__DEV__) {
  Shape.displayName = "Shape";
}

/**
 * CircularProgress is used to indicate the progress of an activity.
 * It is built using `svg` and `circle` components with support for
 * theming and `indeterminate` state
 *
 * @see Docs https://chakra-ui.com/circularprogress
 * @todo add theming support for circular progress
 */
const CircularProgress = props => {
  const {
    size = "48px",
    max = 100,
    min = 0,
    valueText,
    getValueText,
    value,
    capIsRound,
    children,
    thickness = "10px",
    color = "#0078d4",
    trackColor = "#edebe9",
    isIndeterminate,
    ...rest
  } = props;
  const progress = getProgressProps({
    min,
    max,
    value,
    valueText,
    getValueText,
    isIndeterminate
  });
  const determinant = isIndeterminate ? undefined : (progress.percent ?? 0) * 2.64;
  const strokeDasharray = utils.isUndefined(determinant) ? undefined : `${determinant} ${264 - determinant}`;
  const indicatorProps = isIndeterminate ? {
    css: {
      animation: `${spin} 1.5s linear infinite`
    }
  } : {
    strokeDashoffset: 66,
    strokeDasharray,
    transitionProperty: "stroke-dasharray, stroke",
    transitionDuration: "0.6s",
    transitionTimingFunction: "ease"
  };
  const rootStyles = {
    display: "inline-block",
    position: "relative",
    verticalAlign: "middle",
    fontSize: size
  };
  return /*#__PURE__*/React__namespace.createElement(system.chakra.div, _extends({
    className: "chakra-progress"
  }, progress.bind, rest, {
    __css: rootStyles
  }), /*#__PURE__*/React__namespace.createElement(Shape, {
    size: size,
    isIndeterminate: isIndeterminate
  }, /*#__PURE__*/React__namespace.createElement(Circle, {
    stroke: trackColor,
    strokeWidth: thickness,
    className: "chakra-progress__track"
  }), /*#__PURE__*/React__namespace.createElement(Circle, _extends({
    stroke: color,
    strokeWidth: thickness,
    className: "chakra-progress__indicator",
    strokeLinecap: capIsRound ? "round" : undefined
    /**
     * fix issue in Safari where indictor still shows when value is 0
     * @see Issue https://github.com/chakra-ui/chakra-ui/issues/3754
     */
    ,
    opacity: progress.value === 0 && !isIndeterminate ? 0 : undefined
  }, indicatorProps))), children);
};

if (utils.__DEV__) {
  CircularProgress.displayName = "CircularProgress";
}
/**
 * CircularProgress component label. In most cases it is a numeric indicator
 * of the circular progress component's value
 */


const CircularProgressLabel = system.chakra("div", {
  baseStyle: {
    fontSize: "0.24em",
    top: "50%",
    left: "50%",
    width: "100%",
    textAlign: "center",
    position: "absolute",
    transform: "translate(-50%, -50%)"
  }
});

if (utils.__DEV__) {
  CircularProgressLabel.displayName = "CircularProgressLabel";
}

/**
 * ProgressLabel is used to show the numeric value of the progress.
 * @see Docs https://chakra-ui.com/progress
 */
const ProgressLabel = props => {
  const styles = system.useStyles();
  const labelStyles = {
    top: "50%",
    left: "50%",
    width: "100%",
    textAlign: "center",
    position: "absolute",
    transform: "translate(-50%, -50%)",
    ...styles.label
  };
  return /*#__PURE__*/React__namespace.createElement(system.chakra.div, _extends({}, props, {
    __css: labelStyles
  }));
};

if (utils.__DEV__) {
  ProgressLabel.displayName = "ProgressLabel";
}

/**
 * ProgressFilledTrack (Linear)
 *
 * The progress component that visually indicates the current level of the progress bar.
 * It applies `background-color` and changes its width.
 *
 * @see Docs https://chakra-ui.com/progress
 */
const ProgressFilledTrack = props => {
  const {
    min,
    max,
    value,
    isIndeterminate,
    ...rest
  } = props;
  const progress = getProgressProps({
    value,
    min,
    max,
    isIndeterminate
  });
  const styles = system.useStyles();
  const trackStyles = {
    height: "100%",
    ...styles.filledTrack
  };
  return /*#__PURE__*/React__namespace.createElement(system.chakra.div, _extends({
    style: {
      width: `${progress.percent}%`,
      ...rest.style
    }
  }, progress.bind, rest, {
    __css: trackStyles
  }));
};

/**
 * Progress (Linear)
 *
 * Progress is used to display the progress status for a task that takes a long
 * time or consists of several steps.
 *
 * It includes accessible attributes to help assistive technologies understand
 * and speak the progress values.
 *
 * @see Docs https://chakra-ui.com/progress
 */
const Progress = props => {
  const {
    value,
    min = 0,
    max = 100,
    hasStripe,
    isAnimated,
    children,
    borderRadius: propBorderRadius,
    isIndeterminate,
    "aria-label": ariaLabel,
    "aria-labelledby": ariaLabelledBy,
    ...rest
  } = system.omitThemingProps(props);
  const styles = system.useMultiStyleConfig("Progress", props);
  const borderRadius = propBorderRadius ?? styles.track?.borderRadius;
  const stripeAnimation = {
    animation: `${stripe} 1s linear infinite`
  };
  /**
   * We should not use stripe if it is `indeterminate`
   */

  const shouldAddStripe = !isIndeterminate && hasStripe;
  const shouldAnimateStripe = shouldAddStripe && isAnimated;
  /**
   * Generate styles for stripe and stripe animation
   */

  const css = { ...(shouldAnimateStripe && stripeAnimation),
    ...(isIndeterminate && {
      position: "absolute",
      willChange: "left",
      minWidth: "50%",
      animation: `${progress} 1s ease infinite normal none running`
    })
  };
  const trackStyles = {
    overflow: "hidden",
    position: "relative",
    ...styles.track
  };
  return /*#__PURE__*/React__namespace.createElement(system.chakra.div, _extends({
    borderRadius: borderRadius,
    __css: trackStyles
  }, rest), /*#__PURE__*/React__namespace.createElement(system.StylesProvider, {
    value: styles
  }, /*#__PURE__*/React__namespace.createElement(ProgressFilledTrack, {
    "aria-label": ariaLabel,
    "aria-labelledby": ariaLabelledBy,
    min: min,
    max: max,
    value: value,
    isIndeterminate: isIndeterminate,
    css: css,
    borderRadius: borderRadius
  }), children));
};

if (utils.__DEV__) {
  Progress.displayName = "Progress";
}

exports.CircularProgress = CircularProgress;
exports.CircularProgressLabel = CircularProgressLabel;
exports.Progress = Progress;
exports.ProgressLabel = ProgressLabel;

import { isRightClick, dataAttr } from '@chakra-ui/utils';
import { mergeRefs } from '@chakra-ui/react-utils';
import * as React from 'react';

function useEventListeners() {
  const listeners = React.useRef(new Map());
  const currentListeners = listeners.current;
  const add = React.useCallback((el, type, listener, options) => {
    listeners.current.set(listener, {
      type,
      el,
      options
    });
    el.addEventListener(type, listener, options);
  }, []);
  const remove = React.useCallback((el, type, listener, options) => {
    el.removeEventListener(type, listener, options);
    listeners.current.delete(listener);
  }, []);
  React.useEffect(() => () => {
    currentListeners.forEach((value, key) => {
      remove(value.el, value.type, key, value.options);
    });
  }, [remove, currentListeners]);
  return {
    add,
    remove
  };
}

function isValidElement(event) {
  const element = event.target;
  const {
    tagName,
    isContentEditable
  } = element;
  return tagName !== "INPUT" && tagName !== "TEXTAREA" && isContentEditable !== true;
}
/**
 * useClickable implements all the interactions of a native `button`
 * component with support for making it focusable even if it is disabled.
 *
 * It can be used with both native button elements or other elements (like `div`).
 */


function useClickable(props = {}) {
  const {
    ref: htmlRef,
    isDisabled,
    isFocusable,
    clickOnEnter = true,
    clickOnSpace = true,
    onMouseDown,
    onMouseUp,
    onClick,
    onKeyDown,
    onKeyUp,
    tabIndex: tabIndexProp,
    onMouseOver,
    onMouseLeave,
    ...htmlProps
  } = props;
  /**
   * We'll use this to track if the element is a button element
   */

  const [isButton, setIsButton] = React.useState(true);
  /**
   * For custom button implementation, we'll use this to track when
   * we mouse down on the button, to enable use style its ":active" style
   */

  const [isPressed, setIsPressed] = React.useState(false);
  const listeners = useEventListeners();
  /**
   * The ref callback that fires as soon as the dom node is ready
   */

  const refCallback = node => {
    if (!node) return;

    if (node.tagName !== "BUTTON") {
      setIsButton(false);
    }
  };

  const tabIndex = isButton ? tabIndexProp : tabIndexProp || 0;
  const trulyDisabled = isDisabled && !isFocusable;
  const handleClick = React.useCallback(event => {
    if (isDisabled) {
      event.stopPropagation();
      event.preventDefault();
      return;
    }

    const self = event.currentTarget;
    self.focus();
    onClick?.(event);
  }, [isDisabled, onClick]);
  const onDocumentKeyUp = React.useCallback(e => {
    if (isPressed && isValidElement(e)) {
      e.preventDefault();
      e.stopPropagation();
      setIsPressed(false); // eslint-disable-next-line @typescript-eslint/no-unused-vars

      listeners.remove(document, "keyup", onDocumentKeyUp, false);
    }
  }, [isPressed, listeners]);
  const handleKeyDown = React.useCallback(event => {
    onKeyDown?.(event);

    if (isDisabled || event.defaultPrevented || event.metaKey) {
      return;
    }

    if (!isValidElement(event.nativeEvent) || isButton) return;
    const shouldClickOnEnter = clickOnEnter && event.key === "Enter";
    const shouldClickOnSpace = clickOnSpace && event.key === " ";

    if (shouldClickOnSpace) {
      event.preventDefault();
      setIsPressed(true);
    }

    if (shouldClickOnEnter) {
      event.preventDefault();
      const self = event.currentTarget;
      self.click();
    }

    listeners.add(document, "keyup", onDocumentKeyUp, false);
  }, [isDisabled, isButton, onKeyDown, clickOnEnter, clickOnSpace, listeners, onDocumentKeyUp]);
  const handleKeyUp = React.useCallback(event => {
    onKeyUp?.(event);
    if (isDisabled || event.defaultPrevented || event.metaKey) return;
    if (!isValidElement(event.nativeEvent) || isButton) return;
    const shouldClickOnSpace = clickOnSpace && event.key === " ";

    if (shouldClickOnSpace) {
      event.preventDefault();
      setIsPressed(false);
      const self = event.currentTarget;
      self.click();
    }
  }, [clickOnSpace, isButton, isDisabled, onKeyUp]);
  const onDocumentMouseUp = React.useCallback(event => {
    if (event.button !== 0) return;
    setIsPressed(false);
    listeners.remove(document, "mouseup", onDocumentMouseUp, false);
  }, [listeners]);
  const handleMouseDown = React.useCallback(event => {
    if (isRightClick(event)) return;

    if (isDisabled) {
      event.stopPropagation();
      event.preventDefault();
      return;
    }

    if (!isButton) {
      setIsPressed(true);
    }

    const target = event.currentTarget;
    target.focus({
      preventScroll: true
    });
    listeners.add(document, "mouseup", onDocumentMouseUp, false);
    onMouseDown?.(event);
  }, [isDisabled, isButton, onMouseDown, listeners, onDocumentMouseUp]);
  const handleMouseUp = React.useCallback(event => {
    if (isRightClick(event)) return;

    if (!isButton) {
      setIsPressed(false);
    }

    onMouseUp?.(event);
  }, [onMouseUp, isButton]);
  const handleMouseOver = React.useCallback(event => {
    if (isDisabled) {
      event.preventDefault();
      return;
    }

    onMouseOver?.(event);
  }, [isDisabled, onMouseOver]);
  const handleMouseLeave = React.useCallback(event => {
    if (isPressed) {
      event.preventDefault();
      setIsPressed(false);
    }

    onMouseLeave?.(event);
  }, [isPressed, onMouseLeave]);
  const ref = mergeRefs(htmlRef, refCallback);

  if (isButton) {
    return { ...htmlProps,
      ref,
      type: "button",
      "aria-disabled": trulyDisabled ? undefined : isDisabled,
      disabled: trulyDisabled,
      onClick: handleClick,
      onMouseDown,
      onMouseUp,
      onKeyUp,
      onKeyDown,
      onMouseOver,
      onMouseLeave
    };
  }

  return { ...htmlProps,
    ref,
    role: "button",
    "data-active": dataAttr(isPressed),
    "aria-disabled": isDisabled ? "true" : undefined,
    tabIndex: trulyDisabled ? undefined : tabIndex,
    onClick: handleClick,
    onMouseDown: handleMouseDown,
    onMouseUp: handleMouseUp,
    onKeyUp: handleKeyUp,
    onKeyDown: handleKeyDown,
    onMouseOver: handleMouseOver,
    onMouseLeave: handleMouseLeave
  };
}

export { useClickable };

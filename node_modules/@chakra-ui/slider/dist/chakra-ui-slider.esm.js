import { mergeRefs, createContext } from '@chakra-ui/react-utils';
import { forwardRef, useMultiStyleConfig, omitThemingProps, useTheme, StylesProvider, chakra, useStyles } from '@chakra-ui/system';
import { clampValue, valueToPercent, percentToValue, roundValueToStep, normalizeEventKey, focus, ariaAttr, dataAttr, callAllHandlers, __DEV__, cx, getBox } from '@chakra-ui/utils';
import * as React from 'react';
import { useState, useRef, useEffect, useCallback, useMemo } from 'react';
import { useCallbackRef, useControllableState, useBoolean, useLatestRef, useId, useUpdateEffect, usePanGesture, useIds, useDimensions } from '@chakra-ui/hooks';

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

function getIds(id) {
  return {
    root: `slider-root-${id}`,
    getThumb: i => `slider-thumb-${id}-${i}`,
    getInput: i => `slider-input-${id}-${i}`,
    track: `slider-track-${id}`,
    innerTrack: `slider-filled-track-${id}`,
    getMarker: i => `slider-marker-${id}-${i}`,
    output: `slider-output-${id}`
  };
}
function orient$1(options) {
  const {
    orientation,
    vertical,
    horizontal
  } = options;
  return orientation === "vertical" ? vertical : horizontal;
}
const zeroRect = {
  width: 0,
  height: 0
};
function getStyles(options) {
  const {
    orientation,
    thumbPercents,
    thumbRects,
    isReversed
  } = options;

  const getThumbStyle = i => ({
    position: "absolute",
    userSelect: "none",
    WebkitUserSelect: "none",
    MozUserSelect: "none",
    msUserSelect: "none",
    touchAction: "none",
    ...orient$1({
      orientation,
      vertical: {
        bottom: `calc(${thumbPercents[i]}% - ${thumbRects[i].height / 2}px)`
      },
      horizontal: {
        left: `calc(${thumbPercents[i]}% - ${thumbRects[i].width / 2}px)`
      }
    })
  });

  const size = orientation === "vertical" ? thumbRects.reduce((a, b) => a.height > b.height ? a : b, zeroRect) : thumbRects.reduce((a, b) => a.width > b.width ? a : b, zeroRect);
  const rootStyle = {
    position: "relative",
    touchAction: "none",
    WebkitTapHighlightColor: "rgba(0,0,0,0)",
    userSelect: "none",
    outline: 0,
    ...orient$1({
      orientation,
      vertical: {
        paddingLeft: size.width / 2,
        paddingRight: size.width / 2
      },
      horizontal: {
        paddingTop: size.height / 2,
        paddingBottom: size.height / 2
      }
    })
  };
  const trackStyle = {
    position: "absolute",
    ...orient$1({
      orientation,
      vertical: {
        left: "50%",
        transform: "translateX(-50%)",
        height: "100%"
      },
      horizontal: {
        top: "50%",
        transform: "translateY(-50%)",
        width: "100%"
      }
    })
  };
  const isSingleThumb = thumbPercents.length === 1;
  const fallback = [0, isReversed ? 100 - thumbPercents[0] : thumbPercents[0]];
  const range = isSingleThumb ? fallback : thumbPercents;
  let start = range[0];

  if (!isSingleThumb && isReversed) {
    start = 100 - start;
  }

  const percent = Math.abs(range[range.length - 1] - range[0]);
  const innerTrackStyle = { ...trackStyle,
    ...orient$1({
      orientation,
      vertical: isReversed ? {
        height: `${percent}%`,
        top: `${start}%`
      } : {
        height: `${percent}%`,
        bottom: `${start}%`
      },
      horizontal: isReversed ? {
        width: `${percent}%`,
        right: `${start}%`
      } : {
        width: `${percent}%`,
        left: `${start}%`
      }
    })
  };
  return {
    trackStyle,
    innerTrackStyle,
    rootStyle,
    getThumbStyle
  };
}
function getIsReversed(options) {
  const {
    isReversed,
    direction,
    orientation
  } = options;

  if (direction === "ltr" || orientation === "vertical") {
    return isReversed;
  } // only flip for horizontal RTL
  // if isReserved ðŸ”œ  otherwise  ðŸ”š


  return !isReversed;
}

/**
 * React hook that implements an accessible range slider.
 *
 * It is an alternative to `<input type="range" />`, and returns
 * prop getters for the component parts
 *
 * @see Docs     https://chakra-ui.com/docs/form/slider
 * @see WAI-ARIA https://www.w3.org/TR/wai-aria-practices-1.1/#slider
 */
function useRangeSlider(props) {
  const {
    min = 0,
    max = 100,
    onChange,
    value: valueProp,
    defaultValue,
    isReversed: isReversedProp,
    direction = "ltr",
    orientation = "horizontal",
    id: idProp,
    isDisabled,
    isReadOnly,
    onChangeStart: onChangeStartProp,
    onChangeEnd: onChangeEndProp,
    step = 1,
    getAriaValueText: getAriaValueTextProp,
    "aria-valuetext": ariaValueText,
    "aria-label": ariaLabel,
    "aria-labelledby": ariaLabelledBy,
    name,
    focusThumbOnChange = true,
    minStepsBetweenThumbs = 0,
    ...htmlProps
  } = props;
  const onChangeStart = useCallbackRef(onChangeStartProp);
  const onChangeEnd = useCallbackRef(onChangeEndProp);
  const getAriaValueText = useCallbackRef(getAriaValueTextProp);
  const isReversed = getIsReversed({
    isReversed: isReversedProp,
    direction,
    orientation
  });
  const [valueState, setValue] = useControllableState({
    value: valueProp,
    defaultValue: defaultValue ?? [25, 75],
    onChange
  });

  if (!Array.isArray(valueState)) {
    throw new TypeError(`[range-slider] You passed an invalid value for \`value\` or \`defaultValue\`, expected \`Array\` but got \`${typeof valueState}\``);
  }

  const [isDragging, setDragging] = useBoolean();
  const [isFocused, setFocused] = useBoolean();
  const [activeIndex, setActiveIndex] = useState(-1);
  const eventSourceRef = useRef(null);
  const isInteractive = !(isDisabled || isReadOnly);
  const initialValue = useRef(valueState);
  const value = valueState.map(val => clampValue(val, min, max));
  const valueRef = useLatestRef(value);
  const spacing = minStepsBetweenThumbs * step;
  const valueBounds = getValueBounds(value, min, max, spacing);
  const reversedValue = value.map(val => max - val + min);
  const thumbValues = isReversed ? reversedValue : value;
  const thumbPercents = thumbValues.map(val => valueToPercent(val, min, max));
  const isVertical = orientation === "vertical";
  const [thumbRects, setThumbRects] = useState(Array.from({
    length: value.length
  }).map(() => ({
    width: 0,
    height: 0
  })));
  useEffect(() => {
    if (!rootRef.current) return;
    const thumbs = Array.from(rootRef.current?.querySelectorAll("[role=slider]"));
    const rects = thumbs.map(el => ({
      width: el.offsetWidth,
      height: el.offsetHeight
    }));
    if (rects.length) setThumbRects(rects);
  }, []);
  /**
   * Let's keep a reference to the slider track and thumb
   */

  const trackRef = useRef(null);
  const rootRef = useRef(null);
  const uuid = useId(idProp);
  const ids = getIds(uuid);
  const getValueFromPointer = useCallback(event => {
    if (!trackRef.current) return;
    eventSourceRef.current = "pointer";
    const rect = trackRef.current.getBoundingClientRect();
    const {
      clientX,
      clientY
    } = event.touches?.[0] ?? event;
    const diff = isVertical ? rect.bottom - clientY : clientX - rect.left;
    const length = isVertical ? rect.height : rect.width;
    let percent = diff / length;
    if (isReversed) percent = 1 - percent;
    return percentToValue(percent, min, max);
  }, [isVertical, isReversed, max, min]);
  const tenSteps = (max - min) / 10;
  const oneStep = step || (max - min) / 100;
  const actions = useMemo(() => ({
    setValueAtIndex: (index, val) => {
      if (!isInteractive) return;
      const bounds = valueBounds[index];
      val = parseFloat(roundValueToStep(val, bounds.min, oneStep));
      val = clampValue(val, bounds.min, bounds.max);
      const next = [...value];
      next[index] = val;
      setValue(next);
    },
    setActiveIndex,
    stepUp: (index, step = oneStep) => {
      const valueAtIndex = value[index];
      const next = isReversed ? valueAtIndex - step : valueAtIndex + step;
      actions.setValueAtIndex(index, next);
    },
    stepDown: (index, step = oneStep) => {
      const valueAtIndex = value[index];
      const next = isReversed ? valueAtIndex + step : valueAtIndex - step;
      actions.setValueAtIndex(index, next);
    },
    reset: () => setValue(initialValue.current)
  }), [oneStep, value, isReversed, setValue, isInteractive, valueBounds]);
  /**
   * Keyboard interaction to ensure users can operate
   * the slider using only their keyboard.
   */

  const onKeyDown = useCallback(event => {
    const eventKey = normalizeEventKey(event);
    const keyMap = {
      ArrowRight: () => actions.stepUp(activeIndex),
      ArrowUp: () => actions.stepUp(activeIndex),
      ArrowLeft: () => actions.stepDown(activeIndex),
      ArrowDown: () => actions.stepDown(activeIndex),
      PageUp: () => actions.stepUp(activeIndex, tenSteps),
      PageDown: () => actions.stepDown(activeIndex, tenSteps),
      Home: () => {
        const {
          min: value
        } = valueBounds[activeIndex];
        actions.setValueAtIndex(activeIndex, value);
      },
      End: () => {
        const {
          max: value
        } = valueBounds[activeIndex];
        actions.setValueAtIndex(activeIndex, value);
      }
    };
    const action = keyMap[eventKey];

    if (action) {
      event.preventDefault();
      event.stopPropagation();
      action(event);
      eventSourceRef.current = "keyboard";
    }
  }, [actions, activeIndex, tenSteps, valueBounds]);
  /**
   * Compute styles for all component parts.
   */

  const {
    getThumbStyle,
    rootStyle,
    trackStyle,
    innerTrackStyle
  } = useMemo(() => getStyles({
    isReversed,
    orientation,
    thumbRects,
    thumbPercents
  }), [isReversed, orientation, thumbPercents, thumbRects]);
  const focusThumb = useCallback(index => {
    const idx = index ?? activeIndex;

    if (idx !== -1 && focusThumbOnChange) {
      const id = ids.getThumb(idx);
      const thumb = rootRef.current?.ownerDocument.getElementById(id);

      if (thumb) {
        setTimeout(() => focus(thumb));
      }
    }
  }, [focusThumbOnChange, activeIndex, ids]);
  useUpdateEffect(() => {
    if (eventSourceRef.current === "keyboard") {
      onChangeEnd?.(valueRef.current);
    }
  }, [value, onChangeEnd]);

  const onPanSessionStart = event => {
    const pointValue = getValueFromPointer(event) || 0;
    const distances = value.map(val => Math.abs(val - pointValue));
    const closest = Math.min(...distances);
    let index = distances.indexOf(closest); // check if the clicked thumb is stacked by checking if there are multiple
    // thumbs at the same distance

    const isThumbStacked = distances.filter(distance => distance === closest).length > 1; // when two thumbs are stacked and the user clicks at a point larger than
    // their values, pick the next closest thumb

    if (isThumbStacked && pointValue > value[index]) {
      index++;
    }

    setActiveIndex(index);
    actions.setValueAtIndex(index, pointValue);
    focusThumb(index);
  };

  const onPan = event => {
    if (activeIndex == -1) return;
    const pointValue = getValueFromPointer(event) || 0;
    setActiveIndex(activeIndex);
    actions.setValueAtIndex(activeIndex, pointValue);
    focusThumb(activeIndex);
  };

  usePanGesture(rootRef, {
    onPanSessionStart(event) {
      if (!isInteractive) return;
      setDragging.on();
      onPanSessionStart(event);
      onChangeStart?.(valueRef.current);
    },

    onPanSessionEnd() {
      if (!isInteractive) return;
      setDragging.off();
      onChangeEnd?.(valueRef.current);
    },

    onPan(event) {
      if (!isInteractive) return;
      onPan(event);
    }

  });
  const getRootProps = useCallback((props = {}, ref = null) => ({ ...props,
    ...htmlProps,
    id: ids.root,
    ref: mergeRefs(ref, rootRef),
    tabIndex: -1,
    "aria-disabled": ariaAttr(isDisabled),
    "data-focused": dataAttr(isFocused),
    style: { ...props.style,
      ...rootStyle
    }
  }), [htmlProps, isDisabled, isFocused, rootStyle, ids]);
  const getTrackProps = useCallback((props = {}, ref = null) => ({ ...props,
    ref: mergeRefs(ref, trackRef),
    id: ids.track,
    "data-disabled": dataAttr(isDisabled),
    style: { ...props.style,
      ...trackStyle
    }
  }), [isDisabled, trackStyle, ids]);
  const getInnerTrackProps = useCallback((props = {}, ref = null) => ({ ...props,
    ref,
    id: ids.innerTrack,
    style: { ...props.style,
      ...innerTrackStyle
    }
  }), [innerTrackStyle, ids]);
  const getThumbProps = useCallback((props, ref = null) => {
    const {
      index,
      ...rest
    } = props;
    const _value = value[index];

    if (_value == null) {
      throw new TypeError(`[range-slider > thumb] Cannot find value at index \`${index}\`. The \`value\` or \`defaultValue\` length is : ${value.length}`);
    }

    const bounds = valueBounds[index];
    return { ...rest,
      ref,
      role: "slider",
      tabIndex: isInteractive ? 0 : undefined,
      id: ids.getThumb(index),
      "data-active": dataAttr(isDragging && activeIndex === index),
      "aria-valuetext": getAriaValueText?.(_value) ?? ariaValueText?.[index],
      "aria-valuemin": bounds.min,
      "aria-valuemax": bounds.max,
      "aria-valuenow": _value,
      "aria-orientation": orientation,
      "aria-disabled": ariaAttr(isDisabled),
      "aria-readonly": ariaAttr(isReadOnly),
      "aria-label": ariaLabel?.[index],
      "aria-labelledby": ariaLabel?.[index] ? undefined : ariaLabelledBy?.[index],
      style: { ...props.style,
        ...getThumbStyle(index)
      },
      onKeyDown: callAllHandlers(props.onKeyDown, onKeyDown),
      onFocus: callAllHandlers(props.onFocus, () => {
        setFocused.on();
        setActiveIndex(index);
      }),
      onBlur: callAllHandlers(props.onBlur, () => {
        setFocused.off();
        setActiveIndex(-1);
      })
    };
  }, [ids, value, valueBounds, isInteractive, isDragging, activeIndex, getAriaValueText, ariaValueText, orientation, isDisabled, isReadOnly, ariaLabel, ariaLabelledBy, getThumbStyle, onKeyDown, setFocused]);
  const getOutputProps = useCallback((props = {}, ref = null) => ({ ...props,
    ref,
    id: ids.output,
    htmlFor: value.map((v, i) => ids.getThumb(i)).join(" "),
    "aria-live": "off"
  }), [ids, value]);
  const getMarkerProps = useCallback((props = {}, ref = null) => {
    const {
      value: v,
      ...rest
    } = props;
    const isInRange = !(v < min || v > max);
    const isHighlighted = v >= value[0] && v <= value[value.length - 1];
    let percent = valueToPercent(v, min, max);
    percent = isReversed ? 100 - percent : percent;
    const markerStyle = {
      position: "absolute",
      pointerEvents: "none",
      ...orient$1({
        orientation,
        vertical: {
          bottom: `${percent}%`
        },
        horizontal: {
          left: `${percent}%`
        }
      })
    };
    return { ...rest,
      ref,
      id: ids.getMarker(props.value),
      role: "presentation",
      "aria-hidden": true,
      "data-disabled": dataAttr(isDisabled),
      "data-invalid": dataAttr(!isInRange),
      "data-highlighted": dataAttr(isHighlighted),
      style: { ...props.style,
        ...markerStyle
      }
    };
  }, [isDisabled, isReversed, max, min, orientation, value, ids]);
  const getInputProps = useCallback((props, ref = null) => {
    const {
      index,
      ...rest
    } = props;
    return { ...rest,
      ref,
      id: ids.getInput(index),
      type: "hidden",
      value: value[index],
      name: Array.isArray(name) ? name[index] : `${name}-${index}`
    };
  }, [name, value, ids]);
  return {
    state: {
      value,
      isFocused,
      isDragging,
      getThumbPercent: i => thumbPercents[i],
      getThumbMinValue: i => valueBounds[i].min,
      getThumbMaxValue: i => valueBounds[i].max
    },
    actions,
    getRootProps,
    getTrackProps,
    getInnerTrackProps,
    getThumbProps,
    getMarkerProps,
    getInputProps,
    getOutputProps
  };
}

const getValueBounds = (arr, min, max, spacing) => arr.map((v, i) => {
  const _min = i === 0 ? min : arr[i - 1] + spacing;

  const _max = i === arr.length - 1 ? max : arr[i + 1] - spacing;

  return {
    min: _min,
    max: _max
  };
});

const [RangeSliderProvider, useRangeSliderContext] = createContext({
  name: "SliderContext",
  errorMessage: "useSliderContext: `context` is undefined. Seems you forgot to wrap all slider components within <RangeSlider />"
});

/**
 * The Slider is used to allow users to make selections from a range of values.
 * It provides context and functionality for all slider components
 *
 * @see Docs     https://chakra-ui.com/docs/form/slider
 * @see WAI-ARIA https://www.w3.org/TR/wai-aria-practices/#slider
 */
const RangeSlider = /*#__PURE__*/forwardRef((props, ref) => {
  const styles = useMultiStyleConfig("Slider", props);
  const ownProps = omitThemingProps(props);
  const {
    direction
  } = useTheme();
  ownProps.direction = direction;
  const {
    getRootProps,
    ...context
  } = useRangeSlider(ownProps);
  const ctx = React.useMemo(() => ({ ...context,
    name: props.name
  }), [context, props.name]);
  return /*#__PURE__*/React.createElement(RangeSliderProvider, {
    value: ctx
  }, /*#__PURE__*/React.createElement(StylesProvider, {
    value: styles
  }, /*#__PURE__*/React.createElement(chakra.div, _extends({}, getRootProps({}, ref), {
    className: "chakra-slider",
    __css: styles.container
  }), props.children)));
});
RangeSlider.defaultProps = {
  orientation: "horizontal"
};

if (__DEV__) {
  RangeSlider.displayName = "RangeSlider";
}

/**
 * Slider component that acts as the handle used to select predefined
 * values by dragging its handle along the track
 */
const RangeSliderThumb = /*#__PURE__*/forwardRef((props, ref) => {
  const {
    getThumbProps,
    getInputProps,
    name
  } = useRangeSliderContext();
  const styles = useStyles();
  const thumbProps = getThumbProps(props, ref);
  return /*#__PURE__*/React.createElement(chakra.div, _extends({}, thumbProps, {
    className: cx("chakra-slider__thumb", props.className),
    __css: styles.thumb
  }), thumbProps.children, name && /*#__PURE__*/React.createElement("input", getInputProps({
    index: props.index
  })));
});

if (__DEV__) {
  RangeSliderThumb.displayName = "RangeSliderThumb";
}

const RangeSliderTrack = /*#__PURE__*/forwardRef((props, ref) => {
  const {
    getTrackProps
  } = useRangeSliderContext();
  const styles = useStyles();
  const trackProps = getTrackProps(props, ref);
  return /*#__PURE__*/React.createElement(chakra.div, _extends({}, trackProps, {
    className: cx("chakra-slider__track", props.className),
    __css: styles.track
  }));
});

if (__DEV__) {
  RangeSliderTrack.displayName = "RangeSliderTrack";
}

const RangeSliderFilledTrack = /*#__PURE__*/forwardRef((props, ref) => {
  const {
    getInnerTrackProps
  } = useRangeSliderContext();
  const styles = useStyles();
  const trackProps = getInnerTrackProps(props, ref);
  return /*#__PURE__*/React.createElement(chakra.div, _extends({}, trackProps, {
    className: "chakra-slider__filled-track",
    __css: styles.filledTrack
  }));
});

if (__DEV__) {
  RangeSliderFilledTrack.displayName = "RangeSliderFilledTrack";
}

/**
 * SliderMark is used to provide names for specific Slider
 * values by defining labels or markers along the track.
 *
 * @see Docs https://chakra-ui.com/slider
 */
const RangeSliderMark = /*#__PURE__*/forwardRef((props, ref) => {
  const {
    getMarkerProps
  } = useRangeSliderContext();
  const markProps = getMarkerProps(props, ref);
  return /*#__PURE__*/React.createElement(chakra.div, _extends({}, markProps, {
    className: cx("chakra-slider__marker", props.className)
  }));
});

if (__DEV__) {
  RangeSliderMark.displayName = "RangeSliderMark";
}

/**
 * React hook that implements an accessible range slider.
 *
 * It is an alternative to `<input type="range" />`, and returns
 * prop getters for the component parts
 *
 * @see Docs     https://chakra-ui.com/docs/form/slider
 * @see WAI-ARIA https://www.w3.org/TR/wai-aria-practices-1.1/#slider
 */
function useSlider(props) {
  const {
    min = 0,
    max = 100,
    onChange,
    value: valueProp,
    defaultValue,
    isReversed: isReversedProp,
    direction = "ltr",
    orientation = "horizontal",
    id: idProp,
    isDisabled,
    isReadOnly,
    onChangeStart: onChangeStartProp,
    onChangeEnd: onChangeEndProp,
    step = 1,
    getAriaValueText: getAriaValueTextProp,
    "aria-valuetext": ariaValueText,
    "aria-label": ariaLabel,
    "aria-labelledby": ariaLabelledBy,
    name,
    focusThumbOnChange = true,
    ...htmlProps
  } = props;
  const onChangeStart = useCallbackRef(onChangeStartProp);
  const onChangeEnd = useCallbackRef(onChangeEndProp);
  const getAriaValueText = useCallbackRef(getAriaValueTextProp);
  const isReversed = getIsReversed({
    isReversed: isReversedProp,
    direction,
    orientation
  });
  /**
   * Enable the slider handle controlled and uncontrolled scenarios
   */

  const [computedValue, setValue] = useControllableState({
    value: valueProp,
    defaultValue: defaultValue ?? getDefaultValue(min, max),
    onChange
  });
  const [isDragging, setDragging] = useBoolean();
  const [isFocused, setFocused] = useBoolean();
  const eventSourceRef = useRef(null);
  const isInteractive = !(isDisabled || isReadOnly);
  /**
   * Constrain the value because it can't be less than min
   * or greater than max
   */

  const value = clampValue(computedValue, min, max);
  const valueRef = useLatestRef(value);
  const prevRef = useRef(valueRef.current);
  const reversedValue = max - value + min;
  const trackValue = isReversed ? reversedValue : value;
  const thumbPercent = valueToPercent(trackValue, min, max);
  const isVertical = orientation === "vertical";
  /**
   * Let's keep a reference to the slider track and thumb
   */

  const trackRef = useRef(null);
  const thumbRef = useRef(null);
  const rootRef = useRef(null);
  /**
   * Generate unique ids for component parts
   */

  const [thumbId, trackId] = useIds(idProp, `slider-thumb`, `slider-track`);
  /**
   * Get relative value of slider from the event by tracking
   * how far you clicked within the track to determine the value
   *
   * @todo - Refactor this later on to use info from pan session
   */

  const getValueFromPointer = useCallback(event => {
    if (!trackRef.current) return;
    eventSourceRef.current = "pointer";
    const trackRect = getBox(trackRef.current).borderBox;
    const {
      clientX,
      clientY
    } = event.touches?.[0] ?? event;
    const diff = isVertical ? trackRect.bottom - clientY : clientX - trackRect.left;
    const length = isVertical ? trackRect.height : trackRect.width;
    let percent = diff / length;

    if (isReversed) {
      percent = 1 - percent;
    }

    let nextValue = percentToValue(percent, min, max);

    if (step) {
      nextValue = parseFloat(roundValueToStep(nextValue, min, step));
    }

    nextValue = clampValue(nextValue, min, max);
    return nextValue;
  }, [isVertical, isReversed, max, min, step]);
  const tenSteps = (max - min) / 10;
  const oneStep = step || (max - min) / 100;
  const constrain = useCallback(value => {
    if (!isInteractive) return;
    value = parseFloat(roundValueToStep(value, min, oneStep));
    value = clampValue(value, min, max);
    setValue(value);
  }, [oneStep, max, min, setValue, isInteractive]);
  const actions = useMemo(() => ({
    stepUp: (step = oneStep) => {
      const next = isReversed ? value - step : value + step;
      constrain(next);
    },
    stepDown: (step = oneStep) => {
      const next = isReversed ? value + step : value - step;
      constrain(next);
    },
    reset: () => constrain(defaultValue || 0),
    stepTo: value => constrain(value)
  }), [constrain, isReversed, value, oneStep, defaultValue]);
  /**
   * Keyboard interaction to ensure users can operate
   * the slider using only their keyboard.
   */

  const onKeyDown = useCallback(event => {
    const eventKey = normalizeEventKey(event);
    const keyMap = {
      ArrowRight: () => actions.stepUp(),
      ArrowUp: () => actions.stepUp(),
      ArrowLeft: () => actions.stepDown(),
      ArrowDown: () => actions.stepDown(),
      PageUp: () => actions.stepUp(tenSteps),
      PageDown: () => actions.stepDown(tenSteps),
      Home: () => constrain(min),
      End: () => constrain(max)
    };
    const action = keyMap[eventKey];

    if (action) {
      event.preventDefault();
      event.stopPropagation();
      action(event);
      eventSourceRef.current = "keyboard";
    }
  }, [actions, constrain, max, min, tenSteps]);
  /**
   * ARIA (Optional): To define a human readable representation of the value,
   * we allow users pass aria-valuetext.
   */

  const valueText = getAriaValueText?.(value) ?? ariaValueText;
  /**
   * Measure the dimensions of the thumb so
   * we can center it within the track properly
   */

  const thumbBoxModel = useDimensions(thumbRef);
  /**
   * Compute styles for all component parts.
   */

  const {
    getThumbStyle,
    rootStyle,
    trackStyle,
    innerTrackStyle
  } = useMemo(() => {
    const thumbRect = thumbBoxModel?.borderBox ?? {
      width: 0,
      height: 0
    };
    return getStyles({
      isReversed,
      orientation,
      thumbRects: [thumbRect],
      thumbPercents: [thumbPercent]
    });
  }, [isReversed, orientation, thumbBoxModel?.borderBox, thumbPercent]);
  const focusThumb = useCallback(() => {
    if (thumbRef.current && focusThumbOnChange) {
      setTimeout(() => focus(thumbRef.current));
    }
  }, [focusThumbOnChange]);
  useUpdateEffect(() => {
    focusThumb();

    if (eventSourceRef.current === "keyboard") {
      onChangeEnd?.(valueRef.current);
    }
  }, [value, onChangeEnd]);

  const setValueFromPointer = event => {
    const nextValue = getValueFromPointer(event);

    if (nextValue != null && nextValue !== valueRef.current) {
      setValue(nextValue);
    }
  };

  usePanGesture(rootRef, {
    onPanSessionStart(event) {
      if (!isInteractive) return;
      setDragging.on();
      focusThumb();
      setValueFromPointer(event);
      onChangeStart?.(valueRef.current);
    },

    onPanSessionEnd() {
      if (!isInteractive) return;
      setDragging.off();
      onChangeEnd?.(valueRef.current);
      prevRef.current = valueRef.current;
    },

    onPan(event) {
      if (!isInteractive) return;
      setValueFromPointer(event);
    }

  });
  const getRootProps = useCallback((props = {}, ref = null) => ({ ...props,
    ...htmlProps,
    ref: mergeRefs(ref, rootRef),
    tabIndex: -1,
    "aria-disabled": ariaAttr(isDisabled),
    "data-focused": dataAttr(isFocused),
    style: { ...props.style,
      ...rootStyle
    }
  }), [htmlProps, isDisabled, isFocused, rootStyle]);
  const getTrackProps = useCallback((props = {}, ref = null) => ({ ...props,
    ref: mergeRefs(ref, trackRef),
    id: trackId,
    "data-disabled": dataAttr(isDisabled),
    style: { ...props.style,
      ...trackStyle
    }
  }), [isDisabled, trackId, trackStyle]);
  const getInnerTrackProps = useCallback((props = {}, ref = null) => ({ ...props,
    ref,
    style: { ...props.style,
      ...innerTrackStyle
    }
  }), [innerTrackStyle]);
  const getThumbProps = useCallback((props = {}, ref = null) => ({ ...props,
    ref: mergeRefs(ref, thumbRef),
    role: "slider",
    tabIndex: isInteractive ? 0 : undefined,
    id: thumbId,
    "data-active": dataAttr(isDragging),
    "aria-valuetext": valueText,
    "aria-valuemin": min,
    "aria-valuemax": max,
    "aria-valuenow": value,
    "aria-orientation": orientation,
    "aria-disabled": ariaAttr(isDisabled),
    "aria-readonly": ariaAttr(isReadOnly),
    "aria-label": ariaLabel,
    "aria-labelledby": ariaLabel ? undefined : ariaLabelledBy,
    style: { ...props.style,
      ...getThumbStyle(0)
    },
    onKeyDown: callAllHandlers(props.onKeyDown, onKeyDown),
    onFocus: callAllHandlers(props.onFocus, setFocused.on),
    onBlur: callAllHandlers(props.onBlur, setFocused.off)
  }), [isInteractive, thumbId, isDragging, valueText, min, max, value, orientation, isDisabled, isReadOnly, ariaLabel, ariaLabelledBy, getThumbStyle, onKeyDown, setFocused.on, setFocused.off]);
  const getMarkerProps = useCallback((props = {}, ref = null) => {
    const isInRange = !(props.value < min || props.value > max);
    const isHighlighted = value >= props.value;
    const markerPercent = valueToPercent(props.value, min, max);
    const markerStyle = {
      position: "absolute",
      pointerEvents: "none",
      ...orient({
        orientation,
        vertical: {
          bottom: isReversed ? `${100 - markerPercent}%` : `${markerPercent}%`
        },
        horizontal: {
          left: isReversed ? `${100 - markerPercent}%` : `${markerPercent}%`
        }
      })
    };
    return { ...props,
      ref,
      role: "presentation",
      "aria-hidden": true,
      "data-disabled": dataAttr(isDisabled),
      "data-invalid": dataAttr(!isInRange),
      "data-highlighted": dataAttr(isHighlighted),
      style: { ...props.style,
        ...markerStyle
      }
    };
  }, [isDisabled, isReversed, max, min, orientation, value]);
  const getInputProps = useCallback((props = {}, ref = null) => ({ ...props,
    ref,
    type: "hidden",
    value,
    name
  }), [name, value]);
  return {
    state: {
      value,
      isFocused,
      isDragging
    },
    actions,
    getRootProps,
    getTrackProps,
    getInnerTrackProps,
    getThumbProps,
    getMarkerProps,
    getInputProps
  };
}

function orient(options) {
  const {
    orientation,
    vertical,
    horizontal
  } = options;
  return orientation === "vertical" ? vertical : horizontal;
}
/**
 * The browser <input type="range" /> calculates
 * the default value of a slider by using mid-point
 * between the min and the max.
 *
 * @see https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/range
 */


function getDefaultValue(min, max) {
  return max < min ? min : min + (max - min) / 2;
}

const [SliderProvider, useSliderContext] = createContext({
  name: "SliderContext",
  errorMessage: "useSliderContext: `context` is undefined. Seems you forgot to wrap all slider components within <Slider />"
});

/**
 * The Slider is used to allow users to make selections from a range of values.
 * It provides context and functionality for all slider components
 *
 * @see Docs     https://chakra-ui.com/docs/form/slider
 * @see WAI-ARIA https://www.w3.org/TR/wai-aria-practices/#slider
 */
const Slider = /*#__PURE__*/forwardRef((props, ref) => {
  const styles = useMultiStyleConfig("Slider", props);
  const ownProps = omitThemingProps(props);
  const {
    direction
  } = useTheme();
  ownProps.direction = direction;
  const {
    getInputProps,
    getRootProps,
    ...context
  } = useSlider(ownProps);
  const rootProps = getRootProps();
  const inputProps = getInputProps({}, ref);
  return /*#__PURE__*/React.createElement(SliderProvider, {
    value: context
  }, /*#__PURE__*/React.createElement(StylesProvider, {
    value: styles
  }, /*#__PURE__*/React.createElement(chakra.div, _extends({}, rootProps, {
    className: "chakra-slider",
    __css: styles.container
  }), props.children, /*#__PURE__*/React.createElement("input", inputProps))));
});
Slider.defaultProps = {
  orientation: "horizontal"
};

if (__DEV__) {
  Slider.displayName = "Slider";
}

/**
 * Slider component that acts as the handle used to select predefined
 * values by dragging its handle along the track
 */
const SliderThumb = /*#__PURE__*/forwardRef((props, ref) => {
  const {
    getThumbProps
  } = useSliderContext();
  const styles = useStyles();
  const thumbProps = getThumbProps(props, ref);
  return /*#__PURE__*/React.createElement(chakra.div, _extends({}, thumbProps, {
    className: cx("chakra-slider__thumb", props.className),
    __css: styles.thumb
  }));
});

if (__DEV__) {
  SliderThumb.displayName = "SliderThumb";
}

const SliderTrack = /*#__PURE__*/forwardRef((props, ref) => {
  const {
    getTrackProps
  } = useSliderContext();
  const styles = useStyles();
  const trackProps = getTrackProps(props, ref);
  return /*#__PURE__*/React.createElement(chakra.div, _extends({}, trackProps, {
    className: cx("chakra-slider__track", props.className),
    __css: styles.track
  }));
});

if (__DEV__) {
  SliderTrack.displayName = "SliderTrack";
}

const SliderFilledTrack = /*#__PURE__*/forwardRef((props, ref) => {
  const {
    getInnerTrackProps
  } = useSliderContext();
  const styles = useStyles();
  const trackProps = getInnerTrackProps(props, ref);
  return /*#__PURE__*/React.createElement(chakra.div, _extends({}, trackProps, {
    className: "chakra-slider__filled-track",
    __css: styles.filledTrack
  }));
});

if (__DEV__) {
  SliderFilledTrack.displayName = "SliderFilledTrack";
}

/**
 * SliderMark is used to provide names for specific Slider
 * values by defining labels or markers along the track.
 *
 * @see Docs https://chakra-ui.com/slider
 */
const SliderMark = /*#__PURE__*/forwardRef((props, ref) => {
  const {
    getMarkerProps
  } = useSliderContext();
  const markProps = getMarkerProps(props, ref);
  return /*#__PURE__*/React.createElement(chakra.div, _extends({}, markProps, {
    className: cx("chakra-slider__marker", props.className)
  }));
});

if (__DEV__) {
  SliderMark.displayName = "SliderMark";
}

export { RangeSlider, RangeSliderFilledTrack, RangeSliderMark, RangeSliderProvider, RangeSliderThumb, RangeSliderTrack, Slider, SliderFilledTrack, SliderMark, SliderProvider, SliderThumb, SliderTrack, useRangeSlider, useRangeSliderContext, useSlider, useSliderContext };

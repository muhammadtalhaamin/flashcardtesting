'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var closeButton = require('@chakra-ui/close-button');
var focusLock = require('@chakra-ui/focus-lock');
var portal = require('@chakra-ui/portal');
var system = require('@chakra-ui/system');
var transition = require('@chakra-ui/transition');
var utils = require('@chakra-ui/utils');
var reactUtils = require('@chakra-ui/react-utils');
var framerMotion = require('framer-motion');
var React = require('react');
var reactRemoveScroll = require('react-remove-scroll');
var hooks = require('@chakra-ui/hooks');
var ariaHidden = require('aria-hidden');

function _interopNamespace(e) {
  if (e && e.__esModule) return e;
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n["default"] = e;
  return Object.freeze(n);
}

var React__namespace = /*#__PURE__*/_interopNamespace(React);

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

const transitions = {
  slideInBottom: { ...transition.slideFadeConfig,
    custom: {
      offsetY: 16,
      reverse: true
    }
  },
  slideInRight: { ...transition.slideFadeConfig,
    custom: {
      offsetX: 16,
      reverse: true
    }
  },
  scale: { ...transition.scaleFadeConfig,
    custom: {
      initialScale: 0.95,
      reverse: true
    }
  },
  none: {}
};
const Motion = system.chakra(framerMotion.motion.section);
const ModalTransition = /*#__PURE__*/React__namespace.forwardRef((props, ref) => {
  const {
    preset,
    ...rest
  } = props;
  const motionProps = transitions[preset];
  return /*#__PURE__*/React__namespace.createElement(Motion, _extends({
    ref: ref
  }, motionProps, rest));
});

/**
 * Proper state management for nested modals.
 * Simplified, but inspired by material-ui's ModalManager class.
 */

class ModalManager {
  constructor() {
    this.modals = void 0;
    this.modals = [];
  }

  add(modal) {
    this.modals.push(modal);
  }

  remove(modal) {
    this.modals = this.modals.filter(_modal => _modal !== modal);
  }

  isTopModal(modal) {
    const topmostModal = this.modals[this.modals.length - 1];
    return topmostModal === modal;
  }

}

const manager = new ModalManager();
function useModalManager(ref, isOpen) {
  React.useEffect(() => {
    if (isOpen) {
      manager.add(ref);
    }

    return () => {
      manager.remove(ref);
    };
  }, [isOpen, ref]);
}

/**
 * Modal hook that manages all the logic for the modal dialog widget
 * and returns prop getters, state and actions.
 *
 * @param props
 */
function useModal(props) {
  const {
    isOpen,
    onClose,
    id,
    closeOnOverlayClick = true,
    closeOnEsc = true,
    useInert = true,
    onOverlayClick: onOverlayClickProp,
    onEsc
  } = props;
  const dialogRef = React.useRef(null);
  const overlayRef = React.useRef(null);
  const [dialogId, headerId, bodyId] = hooks.useIds(id, `chakra-modal`, `chakra-modal--header`, `chakra-modal--body`);
  /**
   * Hook used to polyfill `aria-modal` for older browsers.
   * It uses `aria-hidden` to all other nodes.
   *
   * @see https://developer.paciellogroup.com/blog/2018/06/the-current-state-of-modal-dialog-accessibility/
   */

  useAriaHidden(dialogRef, isOpen && useInert);
  /**
   * Hook use to manage multiple or nested modals
   */

  useModalManager(dialogRef, isOpen);
  const mouseDownTarget = React.useRef(null);
  const onMouseDown = React.useCallback(event => {
    mouseDownTarget.current = event.target;
  }, []);
  const onKeyDown = React.useCallback(event => {
    if (event.key === "Escape") {
      event.stopPropagation();

      if (closeOnEsc) {
        onClose?.();
      }

      onEsc?.();
    }
  }, [closeOnEsc, onClose, onEsc]);
  const [headerMounted, setHeaderMounted] = React.useState(false);
  const [bodyMounted, setBodyMounted] = React.useState(false);
  const getDialogProps = React.useCallback((props = {}, ref = null) => ({
    role: "dialog",
    ...props,
    ref: reactUtils.mergeRefs(ref, dialogRef),
    id: dialogId,
    tabIndex: -1,
    "aria-modal": true,
    "aria-labelledby": headerMounted ? headerId : undefined,
    "aria-describedby": bodyMounted ? bodyId : undefined,
    onClick: utils.callAllHandlers(props.onClick, event => event.stopPropagation())
  }), [bodyId, bodyMounted, dialogId, headerId, headerMounted]);
  const onOverlayClick = React.useCallback(event => {
    event.stopPropagation();
    /**
     * Make sure the event starts and ends on the same DOM element.
     *
     * This is used to prevent the modal from closing when you
     * start dragging from the content, and release drag outside the content.
     *
     * We prevent this because it is technically not a considered "click outside"
     */

    if (mouseDownTarget.current !== event.target) return;
    /**
     * When you click on the overlay, we want to remove only the topmost modal
     */

    if (!manager.isTopModal(dialogRef)) return;

    if (closeOnOverlayClick) {
      onClose?.();
    }

    onOverlayClickProp?.();
  }, [onClose, closeOnOverlayClick, onOverlayClickProp]);
  const getDialogContainerProps = React.useCallback((props = {}, ref = null) => ({ ...props,
    ref: reactUtils.mergeRefs(ref, overlayRef),
    onClick: utils.callAllHandlers(props.onClick, onOverlayClick),
    onKeyDown: utils.callAllHandlers(props.onKeyDown, onKeyDown),
    onMouseDown: utils.callAllHandlers(props.onMouseDown, onMouseDown)
  }), [onKeyDown, onMouseDown, onOverlayClick]);
  return {
    isOpen,
    onClose,
    headerId,
    bodyId,
    setBodyMounted,
    setHeaderMounted,
    dialogRef,
    overlayRef,
    getDialogProps,
    getDialogContainerProps
  };
}

/**
 * Modal hook to polyfill `aria-modal`.
 *
 * It applies `aria-hidden` to elements behind the modal
 * to indicate that they're `inert`.
 *
 * @param ref React ref of the node
 * @param shouldHide whether `aria-hidden` should be applied
 */
function useAriaHidden(ref, shouldHide) {
  React.useEffect(() => {
    if (!ref.current) return undefined;
    let undo = null;

    if (shouldHide && ref.current) {
      undo = ariaHidden.hideOthers(ref.current);
    }

    return () => {
      if (shouldHide) {
        undo?.();
      }
    };
  }, [shouldHide, ref]);
}

const [ModalContextProvider, useModalContext] = reactUtils.createContext({
  strict: true,
  name: "ModalContext",
  errorMessage: "useModalContext: `context` is undefined. Seems you forgot to wrap modal components in `<Modal />`"
});
/**
 * Modal provides context, theming, and accessibility properties
 * to all other modal components.
 *
 * It doesn't render any DOM node.
 */

const Modal = props => {
  const {
    portalProps,
    children,
    autoFocus,
    trapFocus,
    initialFocusRef,
    finalFocusRef,
    returnFocusOnClose,
    blockScrollOnMount,
    allowPinchZoom,
    preserveScrollBarGap,
    motionPreset,
    lockFocusAcrossFrames
  } = props;
  const styles = system.useMultiStyleConfig("Modal", props);
  const modal = useModal(props);
  const context = { ...modal,
    autoFocus,
    trapFocus,
    initialFocusRef,
    finalFocusRef,
    returnFocusOnClose,
    blockScrollOnMount,
    allowPinchZoom,
    preserveScrollBarGap,
    motionPreset,
    lockFocusAcrossFrames
  };
  return /*#__PURE__*/React__namespace.createElement(ModalContextProvider, {
    value: context
  }, /*#__PURE__*/React__namespace.createElement(system.StylesProvider, {
    value: styles
  }, /*#__PURE__*/React__namespace.createElement(framerMotion.AnimatePresence, null, context.isOpen && /*#__PURE__*/React__namespace.createElement(portal.Portal, portalProps, children))));
};
Modal.defaultProps = {
  lockFocusAcrossFrames: true,
  returnFocusOnClose: true,
  scrollBehavior: "outside",
  trapFocus: true,
  autoFocus: true,
  blockScrollOnMount: true,
  allowPinchZoom: false,
  motionPreset: "scale"
};

if (utils.__DEV__) {
  Modal.displayName = "Modal";
}

const MotionDiv = system.chakra(framerMotion.motion.div);
/**
 * ModalContent is used to group modal's content. It has all the
 * necessary `aria-*` properties to indicate that it is a modal
 */

const ModalContent = /*#__PURE__*/system.forwardRef((props, ref) => {
  const {
    className,
    children,
    containerProps: rootProps,
    ...rest
  } = props;
  const {
    getDialogProps,
    getDialogContainerProps
  } = useModalContext();
  const dialogProps = getDialogProps(rest, ref);
  const containerProps = getDialogContainerProps(rootProps);

  const _className = utils.cx("chakra-modal__content", className);

  const styles = system.useStyles();
  const dialogStyles = {
    display: "flex",
    flexDirection: "column",
    position: "relative",
    width: "100%",
    outline: 0,
    ...styles.dialog
  };
  const dialogContainerStyles = {
    display: "flex",
    width: "100vw",
    height: "100vh",
    "@supports(height: -webkit-fill-available)": {
      height: "-webkit-fill-available"
    },
    position: "fixed",
    left: 0,
    top: 0,
    ...styles.dialogContainer
  };
  const {
    motionPreset
  } = useModalContext();
  return /*#__PURE__*/React__namespace.createElement(ModalFocusScope, null, /*#__PURE__*/React__namespace.createElement(system.chakra.div, _extends({}, containerProps, {
    className: "chakra-modal__content-container" // tabindex="-1" means that the element is not reachable via sequential keyboard navigation, @see #4686
    ,
    tabIndex: -1,
    __css: dialogContainerStyles
  }), /*#__PURE__*/React__namespace.createElement(ModalTransition, _extends({
    preset: motionPreset,
    className: _className
  }, dialogProps, {
    __css: dialogStyles
  }), children)));
});

if (utils.__DEV__) {
  ModalContent.displayName = "ModalContent";
}

function ModalFocusScope(props) {
  const {
    autoFocus,
    trapFocus,
    dialogRef,
    initialFocusRef,
    blockScrollOnMount,
    allowPinchZoom,
    finalFocusRef,
    returnFocusOnClose,
    preserveScrollBarGap,
    lockFocusAcrossFrames
  } = useModalContext();
  const [isPresent, safeToRemove] = framerMotion.usePresence();
  React__namespace.useEffect(() => {
    if (!isPresent && safeToRemove) {
      setTimeout(safeToRemove);
    }
  }, [isPresent, safeToRemove]);
  return /*#__PURE__*/React__namespace.createElement(focusLock.FocusLock, {
    autoFocus: autoFocus,
    isDisabled: !trapFocus,
    initialFocusRef: initialFocusRef,
    finalFocusRef: finalFocusRef,
    restoreFocus: returnFocusOnClose,
    contentRef: dialogRef,
    lockFocusAcrossFrames: lockFocusAcrossFrames
  }, /*#__PURE__*/React__namespace.createElement(reactRemoveScroll.RemoveScroll, {
    removeScrollBar: !preserveScrollBarGap,
    allowPinchZoom: allowPinchZoom,
    enabled: blockScrollOnMount,
    forwardProps: true
  }, props.children));
}

/**
 * ModalOverlay renders a backdrop behind the modal. It is
 * also used as a wrapper for the modal content for better positioning.
 *
 * @see Docs https://chakra-ui.com/modal
 */
const ModalOverlay = /*#__PURE__*/system.forwardRef((props, ref) => {
  const {
    className,
    transition: transition$1,
    ...rest
  } = props;

  const _className = utils.cx("chakra-modal__overlay", className);

  const styles = system.useStyles();
  const overlayStyle = {
    pos: "fixed",
    left: "0",
    top: "0",
    w: "100vw",
    h: "100vh",
    ...styles.overlay
  };
  const {
    motionPreset
  } = useModalContext();
  const motionProps = motionPreset === "none" ? {} : transition.fadeConfig;
  return /*#__PURE__*/React__namespace.createElement(MotionDiv, _extends({}, motionProps, {
    __css: overlayStyle,
    ref: ref,
    className: _className
  }, rest));
});

if (utils.__DEV__) {
  ModalOverlay.displayName = "ModalOverlay";
}

/**
 * ModalHeader
 *
 * React component that houses the title of the modal.
 *
 * @see Docs https://chakra-ui.com/modal
 */
const ModalHeader = /*#__PURE__*/system.forwardRef((props, ref) => {
  const {
    className,
    ...rest
  } = props;
  const {
    headerId,
    setHeaderMounted
  } = useModalContext();
  /**
   * Notify us if this component was rendered or used
   * so we can append `aria-labelledby` automatically
   */

  React__namespace.useEffect(() => {
    setHeaderMounted(true);
    return () => setHeaderMounted(false);
  }, [setHeaderMounted]);

  const _className = utils.cx("chakra-modal__header", className);

  const styles = system.useStyles();
  const headerStyles = {
    flex: 0,
    ...styles.header
  };
  return /*#__PURE__*/React__namespace.createElement(system.chakra.header, _extends({
    ref: ref,
    className: _className,
    id: headerId
  }, rest, {
    __css: headerStyles
  }));
});

if (utils.__DEV__) {
  ModalHeader.displayName = "ModalHeader";
}

/**
 * ModalBody
 *
 * React component that houses the main content of the modal.
 *
 * @see Docs https://chakra-ui.com/modal
 */
const ModalBody = /*#__PURE__*/system.forwardRef((props, ref) => {
  const {
    className,
    ...rest
  } = props;
  const {
    bodyId,
    setBodyMounted
  } = useModalContext();
  /**
   * Notify us if this component was rendered or used
   * so we can append `aria-describedby` automatically
   */

  React__namespace.useEffect(() => {
    setBodyMounted(true);
    return () => setBodyMounted(false);
  }, [setBodyMounted]);

  const _className = utils.cx("chakra-modal__body", className);

  const styles = system.useStyles();
  return /*#__PURE__*/React__namespace.createElement(system.chakra.div, _extends({
    ref: ref,
    className: _className,
    id: bodyId
  }, rest, {
    __css: styles.body
  }));
});

if (utils.__DEV__) {
  ModalBody.displayName = "ModalBody";
}

/**
 * ModalFooter houses the action buttons of the modal.
 * @see Docs https://chakra-ui.com/modal
 */
const ModalFooter = /*#__PURE__*/system.forwardRef((props, ref) => {
  const {
    className,
    ...rest
  } = props;

  const _className = utils.cx("chakra-modal__footer", className);

  const styles = system.useStyles();
  const footerStyles = {
    display: "flex",
    alignItems: "center",
    justifyContent: "flex-end",
    ...styles.footer
  };
  return /*#__PURE__*/React__namespace.createElement(system.chakra.footer, _extends({
    ref: ref
  }, rest, {
    __css: footerStyles,
    className: _className
  }));
});

if (utils.__DEV__) {
  ModalFooter.displayName = "ModalFooter";
}
/**
 * ModalCloseButton is used closes the modal.
 *
 * You don't need to pass the `onClick` to it, it reads the
 * `onClose` action from the modal context.
 */


const ModalCloseButton = /*#__PURE__*/system.forwardRef((props, ref) => {
  const {
    onClick,
    className,
    ...rest
  } = props;
  const {
    onClose
  } = useModalContext();

  const _className = utils.cx("chakra-modal__close-btn", className);

  const styles = system.useStyles();
  return /*#__PURE__*/React__namespace.createElement(closeButton.CloseButton, _extends({
    ref: ref,
    __css: styles.closeButton,
    className: _className,
    onClick: utils.callAllHandlers(onClick, event => {
      event.stopPropagation();
      onClose();
    })
  }, rest));
});

if (utils.__DEV__) {
  ModalCloseButton.displayName = "ModalCloseButton";
}

function AlertDialog(props) {
  const {
    leastDestructiveRef,
    ...rest
  } = props;
  return /*#__PURE__*/React__namespace.createElement(Modal, _extends({}, rest, {
    initialFocusRef: leastDestructiveRef
  }));
}
const AlertDialogContent = /*#__PURE__*/system.forwardRef((props, ref) => /*#__PURE__*/React__namespace.createElement(ModalContent, _extends({
  ref: ref,
  role: "alertdialog"
}, props)));

const [DrawerContextProvider, useDrawerContext] = reactUtils.createContext();
const placementMap = {
  start: {
    ltr: "left",
    rtl: "right"
  },
  end: {
    ltr: "right",
    rtl: "left"
  }
};

function getDrawerPlacement(placement, dir) {
  if (!placement) return;
  return placementMap[placement]?.[dir] ?? placement;
}

function Drawer(props) {
  const {
    isOpen,
    onClose,
    placement: placementProp = "right",
    children,
    ...rest
  } = props;
  const theme = system.useTheme();
  const drawerStyleConfig = theme.components?.Drawer;
  const placement = getDrawerPlacement(placementProp, theme.direction);
  return /*#__PURE__*/React__namespace.createElement(DrawerContextProvider, {
    value: {
      placement
    }
  }, /*#__PURE__*/React__namespace.createElement(Modal, _extends({
    isOpen: isOpen,
    onClose: onClose,
    styleConfig: drawerStyleConfig
  }, rest), children));
}
const StyledSlide = system.chakra(transition.Slide);

/**
 * ModalContent is used to group modal's content. It has all the
 * necessary `aria-*` properties to indicate that it is a modal
 */
const DrawerContent = /*#__PURE__*/system.forwardRef((props, ref) => {
  const {
    className,
    children,
    ...rest
  } = props;
  const {
    getDialogProps,
    getDialogContainerProps,
    isOpen
  } = useModalContext();
  const dialogProps = getDialogProps(rest, ref);
  const containerProps = getDialogContainerProps();

  const _className = utils.cx("chakra-modal__content", className);

  const styles = system.useStyles();
  const dialogStyles = {
    display: "flex",
    flexDirection: "column",
    position: "relative",
    width: "100%",
    outline: 0,
    ...styles.dialog
  };
  const dialogContainerStyles = {
    display: "flex",
    width: "100vw",
    height: "100vh",
    position: "fixed",
    left: 0,
    top: 0,
    ...styles.dialogContainer
  };
  const {
    placement
  } = useDrawerContext();
  return /*#__PURE__*/React__namespace.createElement(system.chakra.div, _extends({}, containerProps, {
    className: "chakra-modal__content-container",
    __css: dialogContainerStyles
  }), /*#__PURE__*/React__namespace.createElement(ModalFocusScope, null, /*#__PURE__*/React__namespace.createElement(StyledSlide, _extends({
    direction: placement,
    in: isOpen,
    className: _className
  }, dialogProps, {
    __css: dialogStyles
  }), children)));
});

if (utils.__DEV__) {
  DrawerContent.displayName = "DrawerContent";
}

exports.AlertDialog = AlertDialog;
exports.AlertDialogBody = ModalBody;
exports.AlertDialogCloseButton = ModalCloseButton;
exports.AlertDialogContent = AlertDialogContent;
exports.AlertDialogFooter = ModalFooter;
exports.AlertDialogHeader = ModalHeader;
exports.AlertDialogOverlay = ModalOverlay;
exports.Drawer = Drawer;
exports.DrawerBody = ModalBody;
exports.DrawerCloseButton = ModalCloseButton;
exports.DrawerContent = DrawerContent;
exports.DrawerFooter = ModalFooter;
exports.DrawerHeader = ModalHeader;
exports.DrawerOverlay = ModalOverlay;
exports.Modal = Modal;
exports.ModalBody = ModalBody;
exports.ModalCloseButton = ModalCloseButton;
exports.ModalContent = ModalContent;
exports.ModalContextProvider = ModalContextProvider;
exports.ModalFocusScope = ModalFocusScope;
exports.ModalFooter = ModalFooter;
exports.ModalHeader = ModalHeader;
exports.ModalOverlay = ModalOverlay;
exports.useAriaHidden = useAriaHidden;
exports.useModal = useModal;
exports.useModalContext = useModalContext;

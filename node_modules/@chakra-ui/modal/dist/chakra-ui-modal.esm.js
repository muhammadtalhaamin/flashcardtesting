import { CloseButton } from '@chakra-ui/close-button';
import { FocusLock } from '@chakra-ui/focus-lock';
import { Portal } from '@chakra-ui/portal';
import { chakra, useMultiStyleConfig, StylesProvider, forwardRef, useStyles, useTheme } from '@chakra-ui/system';
import { slideFadeConfig, scaleFadeConfig, fadeConfig, Slide } from '@chakra-ui/transition';
import { callAllHandlers, __DEV__, cx } from '@chakra-ui/utils';
import { mergeRefs, createContext } from '@chakra-ui/react-utils';
import { motion, AnimatePresence, usePresence } from 'framer-motion';
import * as React from 'react';
import { useEffect, useRef, useCallback, useState } from 'react';
import { RemoveScroll } from 'react-remove-scroll';
import { useIds } from '@chakra-ui/hooks';
import { hideOthers } from 'aria-hidden';

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

const transitions = {
  slideInBottom: { ...slideFadeConfig,
    custom: {
      offsetY: 16,
      reverse: true
    }
  },
  slideInRight: { ...slideFadeConfig,
    custom: {
      offsetX: 16,
      reverse: true
    }
  },
  scale: { ...scaleFadeConfig,
    custom: {
      initialScale: 0.95,
      reverse: true
    }
  },
  none: {}
};
const Motion = chakra(motion.section);
const ModalTransition = /*#__PURE__*/React.forwardRef((props, ref) => {
  const {
    preset,
    ...rest
  } = props;
  const motionProps = transitions[preset];
  return /*#__PURE__*/React.createElement(Motion, _extends({
    ref: ref
  }, motionProps, rest));
});

/**
 * Proper state management for nested modals.
 * Simplified, but inspired by material-ui's ModalManager class.
 */

class ModalManager {
  constructor() {
    this.modals = void 0;
    this.modals = [];
  }

  add(modal) {
    this.modals.push(modal);
  }

  remove(modal) {
    this.modals = this.modals.filter(_modal => _modal !== modal);
  }

  isTopModal(modal) {
    const topmostModal = this.modals[this.modals.length - 1];
    return topmostModal === modal;
  }

}

const manager = new ModalManager();
function useModalManager(ref, isOpen) {
  useEffect(() => {
    if (isOpen) {
      manager.add(ref);
    }

    return () => {
      manager.remove(ref);
    };
  }, [isOpen, ref]);
}

/**
 * Modal hook that manages all the logic for the modal dialog widget
 * and returns prop getters, state and actions.
 *
 * @param props
 */
function useModal(props) {
  const {
    isOpen,
    onClose,
    id,
    closeOnOverlayClick = true,
    closeOnEsc = true,
    useInert = true,
    onOverlayClick: onOverlayClickProp,
    onEsc
  } = props;
  const dialogRef = useRef(null);
  const overlayRef = useRef(null);
  const [dialogId, headerId, bodyId] = useIds(id, `chakra-modal`, `chakra-modal--header`, `chakra-modal--body`);
  /**
   * Hook used to polyfill `aria-modal` for older browsers.
   * It uses `aria-hidden` to all other nodes.
   *
   * @see https://developer.paciellogroup.com/blog/2018/06/the-current-state-of-modal-dialog-accessibility/
   */

  useAriaHidden(dialogRef, isOpen && useInert);
  /**
   * Hook use to manage multiple or nested modals
   */

  useModalManager(dialogRef, isOpen);
  const mouseDownTarget = useRef(null);
  const onMouseDown = useCallback(event => {
    mouseDownTarget.current = event.target;
  }, []);
  const onKeyDown = useCallback(event => {
    if (event.key === "Escape") {
      event.stopPropagation();

      if (closeOnEsc) {
        onClose?.();
      }

      onEsc?.();
    }
  }, [closeOnEsc, onClose, onEsc]);
  const [headerMounted, setHeaderMounted] = useState(false);
  const [bodyMounted, setBodyMounted] = useState(false);
  const getDialogProps = useCallback((props = {}, ref = null) => ({
    role: "dialog",
    ...props,
    ref: mergeRefs(ref, dialogRef),
    id: dialogId,
    tabIndex: -1,
    "aria-modal": true,
    "aria-labelledby": headerMounted ? headerId : undefined,
    "aria-describedby": bodyMounted ? bodyId : undefined,
    onClick: callAllHandlers(props.onClick, event => event.stopPropagation())
  }), [bodyId, bodyMounted, dialogId, headerId, headerMounted]);
  const onOverlayClick = useCallback(event => {
    event.stopPropagation();
    /**
     * Make sure the event starts and ends on the same DOM element.
     *
     * This is used to prevent the modal from closing when you
     * start dragging from the content, and release drag outside the content.
     *
     * We prevent this because it is technically not a considered "click outside"
     */

    if (mouseDownTarget.current !== event.target) return;
    /**
     * When you click on the overlay, we want to remove only the topmost modal
     */

    if (!manager.isTopModal(dialogRef)) return;

    if (closeOnOverlayClick) {
      onClose?.();
    }

    onOverlayClickProp?.();
  }, [onClose, closeOnOverlayClick, onOverlayClickProp]);
  const getDialogContainerProps = useCallback((props = {}, ref = null) => ({ ...props,
    ref: mergeRefs(ref, overlayRef),
    onClick: callAllHandlers(props.onClick, onOverlayClick),
    onKeyDown: callAllHandlers(props.onKeyDown, onKeyDown),
    onMouseDown: callAllHandlers(props.onMouseDown, onMouseDown)
  }), [onKeyDown, onMouseDown, onOverlayClick]);
  return {
    isOpen,
    onClose,
    headerId,
    bodyId,
    setBodyMounted,
    setHeaderMounted,
    dialogRef,
    overlayRef,
    getDialogProps,
    getDialogContainerProps
  };
}

/**
 * Modal hook to polyfill `aria-modal`.
 *
 * It applies `aria-hidden` to elements behind the modal
 * to indicate that they're `inert`.
 *
 * @param ref React ref of the node
 * @param shouldHide whether `aria-hidden` should be applied
 */
function useAriaHidden(ref, shouldHide) {
  useEffect(() => {
    if (!ref.current) return undefined;
    let undo = null;

    if (shouldHide && ref.current) {
      undo = hideOthers(ref.current);
    }

    return () => {
      if (shouldHide) {
        undo?.();
      }
    };
  }, [shouldHide, ref]);
}

const [ModalContextProvider, useModalContext] = createContext({
  strict: true,
  name: "ModalContext",
  errorMessage: "useModalContext: `context` is undefined. Seems you forgot to wrap modal components in `<Modal />`"
});
/**
 * Modal provides context, theming, and accessibility properties
 * to all other modal components.
 *
 * It doesn't render any DOM node.
 */

const Modal = props => {
  const {
    portalProps,
    children,
    autoFocus,
    trapFocus,
    initialFocusRef,
    finalFocusRef,
    returnFocusOnClose,
    blockScrollOnMount,
    allowPinchZoom,
    preserveScrollBarGap,
    motionPreset,
    lockFocusAcrossFrames
  } = props;
  const styles = useMultiStyleConfig("Modal", props);
  const modal = useModal(props);
  const context = { ...modal,
    autoFocus,
    trapFocus,
    initialFocusRef,
    finalFocusRef,
    returnFocusOnClose,
    blockScrollOnMount,
    allowPinchZoom,
    preserveScrollBarGap,
    motionPreset,
    lockFocusAcrossFrames
  };
  return /*#__PURE__*/React.createElement(ModalContextProvider, {
    value: context
  }, /*#__PURE__*/React.createElement(StylesProvider, {
    value: styles
  }, /*#__PURE__*/React.createElement(AnimatePresence, null, context.isOpen && /*#__PURE__*/React.createElement(Portal, portalProps, children))));
};
Modal.defaultProps = {
  lockFocusAcrossFrames: true,
  returnFocusOnClose: true,
  scrollBehavior: "outside",
  trapFocus: true,
  autoFocus: true,
  blockScrollOnMount: true,
  allowPinchZoom: false,
  motionPreset: "scale"
};

if (__DEV__) {
  Modal.displayName = "Modal";
}

const MotionDiv = chakra(motion.div);
/**
 * ModalContent is used to group modal's content. It has all the
 * necessary `aria-*` properties to indicate that it is a modal
 */

const ModalContent = /*#__PURE__*/forwardRef((props, ref) => {
  const {
    className,
    children,
    containerProps: rootProps,
    ...rest
  } = props;
  const {
    getDialogProps,
    getDialogContainerProps
  } = useModalContext();
  const dialogProps = getDialogProps(rest, ref);
  const containerProps = getDialogContainerProps(rootProps);

  const _className = cx("chakra-modal__content", className);

  const styles = useStyles();
  const dialogStyles = {
    display: "flex",
    flexDirection: "column",
    position: "relative",
    width: "100%",
    outline: 0,
    ...styles.dialog
  };
  const dialogContainerStyles = {
    display: "flex",
    width: "100vw",
    height: "100vh",
    "@supports(height: -webkit-fill-available)": {
      height: "-webkit-fill-available"
    },
    position: "fixed",
    left: 0,
    top: 0,
    ...styles.dialogContainer
  };
  const {
    motionPreset
  } = useModalContext();
  return /*#__PURE__*/React.createElement(ModalFocusScope, null, /*#__PURE__*/React.createElement(chakra.div, _extends({}, containerProps, {
    className: "chakra-modal__content-container" // tabindex="-1" means that the element is not reachable via sequential keyboard navigation, @see #4686
    ,
    tabIndex: -1,
    __css: dialogContainerStyles
  }), /*#__PURE__*/React.createElement(ModalTransition, _extends({
    preset: motionPreset,
    className: _className
  }, dialogProps, {
    __css: dialogStyles
  }), children)));
});

if (__DEV__) {
  ModalContent.displayName = "ModalContent";
}

function ModalFocusScope(props) {
  const {
    autoFocus,
    trapFocus,
    dialogRef,
    initialFocusRef,
    blockScrollOnMount,
    allowPinchZoom,
    finalFocusRef,
    returnFocusOnClose,
    preserveScrollBarGap,
    lockFocusAcrossFrames
  } = useModalContext();
  const [isPresent, safeToRemove] = usePresence();
  React.useEffect(() => {
    if (!isPresent && safeToRemove) {
      setTimeout(safeToRemove);
    }
  }, [isPresent, safeToRemove]);
  return /*#__PURE__*/React.createElement(FocusLock, {
    autoFocus: autoFocus,
    isDisabled: !trapFocus,
    initialFocusRef: initialFocusRef,
    finalFocusRef: finalFocusRef,
    restoreFocus: returnFocusOnClose,
    contentRef: dialogRef,
    lockFocusAcrossFrames: lockFocusAcrossFrames
  }, /*#__PURE__*/React.createElement(RemoveScroll, {
    removeScrollBar: !preserveScrollBarGap,
    allowPinchZoom: allowPinchZoom,
    enabled: blockScrollOnMount,
    forwardProps: true
  }, props.children));
}

/**
 * ModalOverlay renders a backdrop behind the modal. It is
 * also used as a wrapper for the modal content for better positioning.
 *
 * @see Docs https://chakra-ui.com/modal
 */
const ModalOverlay = /*#__PURE__*/forwardRef((props, ref) => {
  const {
    className,
    transition,
    ...rest
  } = props;

  const _className = cx("chakra-modal__overlay", className);

  const styles = useStyles();
  const overlayStyle = {
    pos: "fixed",
    left: "0",
    top: "0",
    w: "100vw",
    h: "100vh",
    ...styles.overlay
  };
  const {
    motionPreset
  } = useModalContext();
  const motionProps = motionPreset === "none" ? {} : fadeConfig;
  return /*#__PURE__*/React.createElement(MotionDiv, _extends({}, motionProps, {
    __css: overlayStyle,
    ref: ref,
    className: _className
  }, rest));
});

if (__DEV__) {
  ModalOverlay.displayName = "ModalOverlay";
}

/**
 * ModalHeader
 *
 * React component that houses the title of the modal.
 *
 * @see Docs https://chakra-ui.com/modal
 */
const ModalHeader = /*#__PURE__*/forwardRef((props, ref) => {
  const {
    className,
    ...rest
  } = props;
  const {
    headerId,
    setHeaderMounted
  } = useModalContext();
  /**
   * Notify us if this component was rendered or used
   * so we can append `aria-labelledby` automatically
   */

  React.useEffect(() => {
    setHeaderMounted(true);
    return () => setHeaderMounted(false);
  }, [setHeaderMounted]);

  const _className = cx("chakra-modal__header", className);

  const styles = useStyles();
  const headerStyles = {
    flex: 0,
    ...styles.header
  };
  return /*#__PURE__*/React.createElement(chakra.header, _extends({
    ref: ref,
    className: _className,
    id: headerId
  }, rest, {
    __css: headerStyles
  }));
});

if (__DEV__) {
  ModalHeader.displayName = "ModalHeader";
}

/**
 * ModalBody
 *
 * React component that houses the main content of the modal.
 *
 * @see Docs https://chakra-ui.com/modal
 */
const ModalBody = /*#__PURE__*/forwardRef((props, ref) => {
  const {
    className,
    ...rest
  } = props;
  const {
    bodyId,
    setBodyMounted
  } = useModalContext();
  /**
   * Notify us if this component was rendered or used
   * so we can append `aria-describedby` automatically
   */

  React.useEffect(() => {
    setBodyMounted(true);
    return () => setBodyMounted(false);
  }, [setBodyMounted]);

  const _className = cx("chakra-modal__body", className);

  const styles = useStyles();
  return /*#__PURE__*/React.createElement(chakra.div, _extends({
    ref: ref,
    className: _className,
    id: bodyId
  }, rest, {
    __css: styles.body
  }));
});

if (__DEV__) {
  ModalBody.displayName = "ModalBody";
}

/**
 * ModalFooter houses the action buttons of the modal.
 * @see Docs https://chakra-ui.com/modal
 */
const ModalFooter = /*#__PURE__*/forwardRef((props, ref) => {
  const {
    className,
    ...rest
  } = props;

  const _className = cx("chakra-modal__footer", className);

  const styles = useStyles();
  const footerStyles = {
    display: "flex",
    alignItems: "center",
    justifyContent: "flex-end",
    ...styles.footer
  };
  return /*#__PURE__*/React.createElement(chakra.footer, _extends({
    ref: ref
  }, rest, {
    __css: footerStyles,
    className: _className
  }));
});

if (__DEV__) {
  ModalFooter.displayName = "ModalFooter";
}
/**
 * ModalCloseButton is used closes the modal.
 *
 * You don't need to pass the `onClick` to it, it reads the
 * `onClose` action from the modal context.
 */


const ModalCloseButton = /*#__PURE__*/forwardRef((props, ref) => {
  const {
    onClick,
    className,
    ...rest
  } = props;
  const {
    onClose
  } = useModalContext();

  const _className = cx("chakra-modal__close-btn", className);

  const styles = useStyles();
  return /*#__PURE__*/React.createElement(CloseButton, _extends({
    ref: ref,
    __css: styles.closeButton,
    className: _className,
    onClick: callAllHandlers(onClick, event => {
      event.stopPropagation();
      onClose();
    })
  }, rest));
});

if (__DEV__) {
  ModalCloseButton.displayName = "ModalCloseButton";
}

function AlertDialog(props) {
  const {
    leastDestructiveRef,
    ...rest
  } = props;
  return /*#__PURE__*/React.createElement(Modal, _extends({}, rest, {
    initialFocusRef: leastDestructiveRef
  }));
}
const AlertDialogContent = /*#__PURE__*/forwardRef((props, ref) => /*#__PURE__*/React.createElement(ModalContent, _extends({
  ref: ref,
  role: "alertdialog"
}, props)));

const [DrawerContextProvider, useDrawerContext] = createContext();
const placementMap = {
  start: {
    ltr: "left",
    rtl: "right"
  },
  end: {
    ltr: "right",
    rtl: "left"
  }
};

function getDrawerPlacement(placement, dir) {
  if (!placement) return;
  return placementMap[placement]?.[dir] ?? placement;
}

function Drawer(props) {
  const {
    isOpen,
    onClose,
    placement: placementProp = "right",
    children,
    ...rest
  } = props;
  const theme = useTheme();
  const drawerStyleConfig = theme.components?.Drawer;
  const placement = getDrawerPlacement(placementProp, theme.direction);
  return /*#__PURE__*/React.createElement(DrawerContextProvider, {
    value: {
      placement
    }
  }, /*#__PURE__*/React.createElement(Modal, _extends({
    isOpen: isOpen,
    onClose: onClose,
    styleConfig: drawerStyleConfig
  }, rest), children));
}
const StyledSlide = chakra(Slide);

/**
 * ModalContent is used to group modal's content. It has all the
 * necessary `aria-*` properties to indicate that it is a modal
 */
const DrawerContent = /*#__PURE__*/forwardRef((props, ref) => {
  const {
    className,
    children,
    ...rest
  } = props;
  const {
    getDialogProps,
    getDialogContainerProps,
    isOpen
  } = useModalContext();
  const dialogProps = getDialogProps(rest, ref);
  const containerProps = getDialogContainerProps();

  const _className = cx("chakra-modal__content", className);

  const styles = useStyles();
  const dialogStyles = {
    display: "flex",
    flexDirection: "column",
    position: "relative",
    width: "100%",
    outline: 0,
    ...styles.dialog
  };
  const dialogContainerStyles = {
    display: "flex",
    width: "100vw",
    height: "100vh",
    position: "fixed",
    left: 0,
    top: 0,
    ...styles.dialogContainer
  };
  const {
    placement
  } = useDrawerContext();
  return /*#__PURE__*/React.createElement(chakra.div, _extends({}, containerProps, {
    className: "chakra-modal__content-container",
    __css: dialogContainerStyles
  }), /*#__PURE__*/React.createElement(ModalFocusScope, null, /*#__PURE__*/React.createElement(StyledSlide, _extends({
    direction: placement,
    in: isOpen,
    className: _className
  }, dialogProps, {
    __css: dialogStyles
  }), children)));
});

if (__DEV__) {
  DrawerContent.displayName = "DrawerContent";
}

export { AlertDialog, ModalBody as AlertDialogBody, ModalCloseButton as AlertDialogCloseButton, AlertDialogContent, ModalFooter as AlertDialogFooter, ModalHeader as AlertDialogHeader, ModalOverlay as AlertDialogOverlay, Drawer, ModalBody as DrawerBody, ModalCloseButton as DrawerCloseButton, DrawerContent, ModalFooter as DrawerFooter, ModalHeader as DrawerHeader, ModalOverlay as DrawerOverlay, Modal, ModalBody, ModalCloseButton, ModalContent, ModalContextProvider, ModalFocusScope, ModalFooter, ModalHeader, ModalOverlay, useAriaHidden, useModal, useModalContext };

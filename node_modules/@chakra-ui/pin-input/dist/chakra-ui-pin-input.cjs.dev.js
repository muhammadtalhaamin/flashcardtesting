'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var system = require('@chakra-ui/system');
var utils = require('@chakra-ui/utils');
var reactUtils = require('@chakra-ui/react-utils');
var React = require('react');
var descendant = require('@chakra-ui/descendant');
var hooks = require('@chakra-ui/hooks');

function _interopNamespace(e) {
  if (e && e.__esModule) return e;
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n["default"] = e;
  return Object.freeze(n);
}

var React__namespace = /*#__PURE__*/_interopNamespace(React);

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

/* -------------------------------------------------------------------------------------------------
 * Create context to track descendants and their indices
 * -----------------------------------------------------------------------------------------------*/

const [PinInputDescendantsProvider, usePinInputDescendantsContext, usePinInputDescendants, usePinInputDescendant] = descendant.createDescendantContext();
/* -------------------------------------------------------------------------------------------------
 * Create context that stores pin-input logic
 * -----------------------------------------------------------------------------------------------*/

const [PinInputProvider, usePinInputContext] = reactUtils.createContext({
  name: "PinInputContext",
  errorMessage: "usePinInputContext: `context` is undefined. Seems you forgot to all pin input fields within `<PinInput />`"
});
/* -------------------------------------------------------------------------------------------------
 * usePinInput hook
 * -----------------------------------------------------------------------------------------------*/

const toArray = value => value?.split("");

function validate(value, type) {
  const NUMERIC_REGEX = /^[0-9]+$/;
  const ALPHA_NUMERIC_REGEX = /^[a-zA-Z0-9]+$/i;
  const regex = type === "alphanumeric" ? ALPHA_NUMERIC_REGEX : NUMERIC_REGEX;
  return regex.test(value);
}
/* -------------------------------------------------------------------------------------------------
 * usePinInput - handles the general pin input logic
 * -----------------------------------------------------------------------------------------------*/

/**
 * @internal
 */


function usePinInput(props = {}) {
  const {
    autoFocus,
    value,
    defaultValue,
    onChange,
    onComplete,
    placeholder = "â—‹",
    manageFocus = true,
    otp = false,
    id: idProp,
    isDisabled,
    isInvalid,
    type = "number",
    mask
  } = props;
  const uuid = hooks.useId();
  const id = idProp ?? `pin-input-${uuid}`;
  const descendants = usePinInputDescendants();
  const [moveFocus, setMoveFocus] = React__namespace.useState(true);
  const [focusedIndex, setFocusedIndex] = React__namespace.useState(-1);
  const [values, setValues] = hooks.useControllableState({
    defaultValue: toArray(defaultValue) || [],
    value: toArray(value),
    onChange: values => onChange?.(values.join(""))
  });
  React__namespace.useEffect(() => {
    if (autoFocus) {
      const first = descendants.first();
      if (first) utils.focus(first.node, {
        nextTick: true
      });
    } // We don't want to listen for updates to `autoFocus` since it only runs initially
    // eslint-disable-next-line

  }, [descendants]);
  const focusNext = React__namespace.useCallback(index => {
    if (!moveFocus || !manageFocus) return;
    const next = descendants.next(index, false);
    if (next) utils.focus(next.node, {
      nextTick: true
    });
  }, [descendants, moveFocus, manageFocus]);
  const setValue = React__namespace.useCallback((value, index) => {
    const nextValues = [...values];
    nextValues[index] = value;
    setValues(nextValues);
    const isComplete = value !== "" && nextValues.length === descendants.count() && nextValues.every(inputValue => inputValue != null && inputValue !== "");

    if (isComplete) {
      onComplete?.(nextValues.join(""));
    } else {
      focusNext(index);
    }
  }, [values, setValues, focusNext, onComplete, descendants]);
  const clear = React__namespace.useCallback(() => {
    const values = Array(descendants.count()).fill("");
    setValues(values);
    const first = descendants.first();
    if (first) utils.focus(first.node);
  }, [descendants, setValues]);
  const getNextValue = React__namespace.useCallback((value, eventValue) => {
    let nextValue = eventValue;

    if (value?.length > 0) {
      if (value[0] === eventValue.charAt(0)) {
        nextValue = eventValue.charAt(1);
      } else if (value[0] === eventValue.charAt(1)) {
        nextValue = eventValue.charAt(0);
      }
    }

    return nextValue;
  }, []);
  const getInputProps = React__namespace.useCallback(props => {
    const {
      index,
      ...rest
    } = props;
    /**
     * Improved from: https://github.com/uber/baseweb/blob/master/src/pin-code/pin-code.js
     */

    const onChange = event => {
      const eventValue = event.target.value;
      const currentValue = values[index];
      const nextValue = getNextValue(currentValue, eventValue); // if the value was removed using backspace

      if (nextValue === "") {
        setValue("", index);
        return;
      } // in the case of an autocomplete or copy and paste


      if (eventValue.length > 2) {
        // see if we can use the string to fill out our values
        if (validate(eventValue, type)) {
          // Ensure the value matches the number of inputs
          const nextValue = eventValue.split("").filter((_, index) => index < descendants.count());
          setValues(nextValue); // if pasting fills the entire input fields, trigger `onComplete`

          if (nextValue.length === descendants.count()) {
            onComplete?.(nextValue.join(""));
          }
        }
      } else {
        // only set if the new value is a number
        if (validate(nextValue, type)) {
          setValue(nextValue, index);
        }

        setMoveFocus(true);
      }
    };

    const onKeyDown = event => {
      if (event.key === "Backspace" && manageFocus) {
        if (event.target.value === "") {
          const prevInput = descendants.prev(index, false);

          if (prevInput) {
            setValue("", index - 1);
            utils.focus(prevInput.node);
            setMoveFocus(true);
          }
        } else {
          setMoveFocus(false);
        }
      }
    };

    const onFocus = () => {
      setFocusedIndex(index);
    };

    const onBlur = () => {
      setFocusedIndex(-1);
    };

    const hasFocus = focusedIndex === index;
    const inputType = type === "number" ? "tel" : "text";
    return {
      "aria-label": "Please enter your pin code",
      inputMode: type === "number" ? "numeric" : "text",
      type: mask ? "password" : inputType,
      ...rest,
      id: `${id}-${index}`,
      disabled: isDisabled,
      "aria-invalid": utils.ariaAttr(isInvalid),
      onChange: utils.callAllHandlers(rest.onChange, onChange),
      onKeyDown: utils.callAllHandlers(rest.onKeyDown, onKeyDown),
      onFocus: utils.callAllHandlers(rest.onFocus, onFocus),
      onBlur: utils.callAllHandlers(rest.onBlur, onBlur),
      value: values[index] || "",
      autoComplete: otp ? "one-time-code" : "off",
      placeholder: hasFocus ? "" : placeholder
    };
  }, [descendants, focusedIndex, getNextValue, id, isDisabled, mask, isInvalid, manageFocus, onComplete, otp, placeholder, setValue, setValues, type, values]);
  return {
    // prop getter
    getInputProps,
    // state
    id,
    descendants,
    values,
    // actions
    setValue,
    setValues,
    clear
  };
}

/**
 * @internal
 */
function usePinInputField(props = {}, ref = null) {
  const {
    getInputProps
  } = usePinInputContext();
  const {
    index,
    register
  } = usePinInputDescendant();
  return getInputProps({ ...props,
    ref: reactUtils.mergeRefs(register, ref),
    index
  });
}

const PinInput = props => {
  const styles = system.useStyleConfig("PinInput", props);
  const {
    children,
    ...rest
  } = system.omitThemingProps(props);
  const {
    descendants,
    ...context
  } = usePinInput(rest);
  const clones = reactUtils.getValidChildren(children).map(child => /*#__PURE__*/React__namespace.cloneElement(child, {
    __css: styles
  }));
  return /*#__PURE__*/React__namespace.createElement(PinInputDescendantsProvider, {
    value: descendants
  }, /*#__PURE__*/React__namespace.createElement(PinInputProvider, {
    value: context
  }, clones));
};

if (utils.__DEV__) {
  PinInput.displayName = "PinInput";
}

const PinInputField = /*#__PURE__*/system.forwardRef((props, ref) => {
  const inputProps = usePinInputField(props, ref);
  return /*#__PURE__*/React__namespace.createElement(system.chakra.input, _extends({}, inputProps, {
    className: utils.cx("chakra-pin-input", props.className)
  }));
});

if (utils.__DEV__) {
  PinInputField.displayName = "PinInputField";
}

exports.PinInput = PinInput;
exports.PinInputDescendantsProvider = PinInputDescendantsProvider;
exports.PinInputField = PinInputField;
exports.PinInputProvider = PinInputProvider;
exports.usePinInput = usePinInput;
exports.usePinInputContext = usePinInputContext;
exports.usePinInputDescendant = usePinInputDescendant;
exports.usePinInputDescendants = usePinInputDescendants;
exports.usePinInputDescendantsContext = usePinInputDescendantsContext;
exports.usePinInputField = usePinInputField;

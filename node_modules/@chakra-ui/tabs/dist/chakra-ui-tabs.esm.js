import { forwardRef, useMultiStyleConfig, omitThemingProps, StylesProvider, chakra, useStyles } from '@chakra-ui/system';
import { normalizeEventKey, callAllHandlers, determineLazyBehavior, isUndefined, focus, omit, cx, __DEV__ } from '@chakra-ui/utils';
import * as React from 'react';
import { useClickable } from '@chakra-ui/clickable';
import { createDescendantContext } from '@chakra-ui/descendant';
import { useControllableState, useId, useSafeLayoutEffect } from '@chakra-ui/hooks';
import { createContext, mergeRefs, getValidChildren } from '@chakra-ui/react-utils';

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

/* -------------------------------------------------------------------------------------------------
 * Create context to track descendants and their indices
 * -----------------------------------------------------------------------------------------------*/

const [TabsDescendantsProvider, useTabsDescendantsContext, useTabsDescendants, useTabsDescendant] = createDescendantContext();
/* -------------------------------------------------------------------------------------------------
 * useTabs - The root react hook that manages all tab items
 * -----------------------------------------------------------------------------------------------*/

/**
 * Tabs hooks that provides all the states, and accessibility
 * helpers to keep all things working properly.
 *
 * Its returned object will be passed unto a Context Provider
 * so all child components can read from it.
 * There is no document link yet
 * @see Docs https://chakra-ui.com/docs/components/useTabs
 */
function useTabs(props) {
  const {
    defaultIndex,
    onChange,
    index,
    isManual,
    isLazy,
    lazyBehavior = "unmount",
    orientation = "horizontal",
    direction = "ltr",
    ...htmlProps
  } = props;
  /**
   * We use this to keep track of the index of the focused tab.
   *
   * Tabs can be automatically activated, this means selection follows focus.
   * When we navigate with the arrow keys, we move focus and selection to next/prev tab
   *
   * Tabs can also be manually activated, this means selection does not follow focus.
   * When we navigate with the arrow keys, we only move focus NOT selection. The user
   * will need not manually activate the tab using `Enter` or `Space`.
   *
   * This is why we need to keep track of the `focusedIndex` and `selectedIndex`
   */

  const [focusedIndex, setFocusedIndex] = React.useState(defaultIndex ?? 0);
  const [selectedIndex, setSelectedIndex] = useControllableState({
    defaultValue: defaultIndex ?? 0,
    value: index,
    onChange
  });
  /**
   * Sync focused `index` with controlled `selectedIndex` (which is the `props.index`)
   */

  React.useEffect(() => {
    if (index != null) {
      setFocusedIndex(index);
    }
  }, [index]);
  /**
   * Think of `useDescendants` as a register for the tab nodes.
   */

  const descendants = useTabsDescendants();
  /**
   * Generate a unique id or use user-provided id for the tabs widget
   */

  const id = useId(props.id, `tabs`);
  return {
    id,
    selectedIndex,
    focusedIndex,
    setSelectedIndex,
    setFocusedIndex,
    isManual,
    isLazy,
    lazyBehavior,
    orientation,
    descendants,
    direction,
    htmlProps
  };
}
const [TabsProvider, useTabsContext] = createContext({
  name: "TabsContext",
  errorMessage: "useTabsContext: `context` is undefined. Seems you forgot to wrap all tabs components within <Tabs />"
});

/**
 * Tabs hook to manage multiple tab buttons,
 * and ensures only one tab is selected per time.
 *
 * @param props props object for the tablist
 */
function useTabList(props) {
  const {
    focusedIndex,
    orientation,
    direction
  } = useTabsContext();
  const descendants = useTabsDescendantsContext();
  const onKeyDown = React.useCallback(event => {
    const nextTab = () => {
      const next = descendants.nextEnabled(focusedIndex);
      if (next) focus(next.node);
    };

    const prevTab = () => {
      const prev = descendants.prevEnabled(focusedIndex);
      if (prev) focus(prev.node);
    };

    const firstTab = () => {
      const first = descendants.firstEnabled();
      if (first) focus(first.node);
    };

    const lastTab = () => {
      const last = descendants.lastEnabled();
      if (last) focus(last.node);
    };

    const isHorizontal = orientation === "horizontal";
    const isVertical = orientation === "vertical";
    const eventKey = normalizeEventKey(event);
    const ArrowStart = direction === "ltr" ? "ArrowLeft" : "ArrowRight";
    const ArrowEnd = direction === "ltr" ? "ArrowRight" : "ArrowLeft";
    const keyMap = {
      [ArrowStart]: () => isHorizontal && prevTab(),
      [ArrowEnd]: () => isHorizontal && nextTab(),
      ArrowDown: () => isVertical && nextTab(),
      ArrowUp: () => isVertical && prevTab(),
      Home: firstTab,
      End: lastTab
    };
    const action = keyMap[eventKey];

    if (action) {
      event.preventDefault();
      action(event);
    }
  }, [descendants, focusedIndex, orientation, direction]);
  return { ...props,
    role: "tablist",
    "aria-orientation": orientation,
    onKeyDown: callAllHandlers(props.onKeyDown, onKeyDown)
  };
}

/**
 * Tabs hook to manage each tab button.
 *
 * A tab can be disabled and focusable, or both,
 * hence the use of `useClickable` to handle this scenario
 */
function useTab(props) {
  const {
    isDisabled,
    isFocusable,
    ...htmlProps
  } = props;
  const {
    setSelectedIndex,
    isManual,
    id,
    setFocusedIndex,
    selectedIndex
  } = useTabsContext();
  const {
    index,
    register
  } = useTabsDescendant({
    disabled: isDisabled && !isFocusable
  });
  const isSelected = index === selectedIndex;

  const onClick = () => {
    setSelectedIndex(index);
  };

  const onFocus = () => {
    setFocusedIndex(index);
    const isDisabledButFocusable = isDisabled && isFocusable;
    const shouldSelect = !isManual && !isDisabledButFocusable;

    if (shouldSelect) {
      setSelectedIndex(index);
    }
  };

  const clickableProps = useClickable({ ...htmlProps,
    ref: mergeRefs(register, props.ref),
    isDisabled,
    isFocusable,
    onClick: callAllHandlers(props.onClick, onClick)
  });
  const type = "button";
  return { ...clickableProps,
    id: makeTabId(id, index),
    role: "tab",
    tabIndex: isSelected ? 0 : -1,
    type,
    "aria-selected": isSelected,
    "aria-controls": makeTabPanelId(id, index),
    onFocus: isDisabled ? undefined : callAllHandlers(props.onFocus, onFocus)
  };
}

/**
 * Tabs hook for managing the visibility of multiple tab panels.
 *
 * Since only one panel can be show at a time, we use `cloneElement`
 * to inject `selected` panel to each TabPanel.
 *
 * It returns a cloned version of its children with
 * all functionality included.
 */
function useTabPanels(props) {
  const context = useTabsContext();
  const {
    id,
    selectedIndex
  } = context;
  const validChildren = getValidChildren(props.children);
  const children = validChildren.map((child, index) => /*#__PURE__*/React.cloneElement(child, {
    isSelected: index === selectedIndex,
    id: makeTabPanelId(id, index),
    // Refers to the associated tab element, and also provides an accessible name to the tab panel.
    "aria-labelledby": makeTabId(id, index)
  }));
  return { ...props,
    children
  };
}
/**
 * Tabs hook for managing the visible/hidden states
 * of the tab panel.
 *
 * @param props props object for the tab panel
 */

function useTabPanel(props) {
  const {
    isSelected,
    id,
    children,
    ...htmlProps
  } = props;
  const {
    isLazy,
    lazyBehavior
  } = useTabsContext();
  const hasBeenSelected = React.useRef(false);

  if (isSelected) {
    hasBeenSelected.current = true;
  }

  const shouldRenderChildren = determineLazyBehavior({
    hasBeenSelected: hasBeenSelected.current,
    isSelected,
    isLazy,
    lazyBehavior
  });
  return {
    // Puts the tabpanel in the page `Tab` sequence.
    tabIndex: 0,
    ...htmlProps,
    children: shouldRenderChildren ? children : null,
    role: "tabpanel",
    hidden: !isSelected,
    id
  };
}
/**
 * Tabs hook to show an animated indicators that
 * follows the active tab.
 *
 * The way we do it is by measuring the DOM Rect (or dimensions)
 * of the active tab, and return that as CSS style for
 * the indicator.
 */

function useTabIndicator() {
  const context = useTabsContext();
  const descendants = useTabsDescendantsContext();
  const {
    selectedIndex,
    orientation
  } = context;
  const isHorizontal = orientation === "horizontal";
  const isVertical = orientation === "vertical"; // Get the clientRect of the selected tab

  const [rect, setRect] = React.useState(() => {
    if (isHorizontal) return {
      left: 0,
      width: 0
    };
    if (isVertical) return {
      top: 0,
      height: 0
    };
    return undefined;
  });
  const [hasMeasured, setHasMeasured] = React.useState(false); // Update the selected tab rect when the selectedIndex changes

  useSafeLayoutEffect(() => {
    if (isUndefined(selectedIndex)) return undefined;
    const tab = descendants.item(selectedIndex);
    if (isUndefined(tab)) return undefined; // Horizontal Tab: Calculate width and left distance

    if (isHorizontal) {
      setRect({
        left: tab.node.offsetLeft,
        width: tab.node.offsetWidth
      });
    } // Vertical Tab: Calculate height and top distance


    if (isVertical) {
      setRect({
        top: tab.node.offsetTop,
        height: tab.node.offsetHeight
      });
    } // Prevent unwanted transition from 0 to measured rect
    // by setting the measured state in the next tick


    const id = requestAnimationFrame(() => {
      setHasMeasured(true);
    });
    return () => {
      if (id) {
        cancelAnimationFrame(id);
      }
    };
  }, [selectedIndex, isHorizontal, isVertical, descendants]);
  return {
    position: "absolute",
    transitionProperty: "left, right, top, bottom",
    transitionDuration: hasMeasured ? "200ms" : "0ms",
    transitionTimingFunction: "cubic-bezier(0, 0, 0.2, 1)",
    ...rect
  };
}

function makeTabId(id, index) {
  return `${id}--tab-${index}`;
}

function makeTabPanelId(id, index) {
  return `${id}--tabpanel-${index}`;
}

/**
 * Tabs
 *
 * Provides context and logic for all tabs components.
 */
const Tabs = /*#__PURE__*/forwardRef((props, ref) => {
  const styles = useMultiStyleConfig("Tabs", props);
  const {
    children,
    className,
    ...rest
  } = omitThemingProps(props);
  const {
    htmlProps,
    descendants,
    ...ctx
  } = useTabs(rest);
  const context = React.useMemo(() => ctx, [ctx]);
  const rootProps = omit(htmlProps, ["isFitted"]);
  return /*#__PURE__*/React.createElement(TabsDescendantsProvider, {
    value: descendants
  }, /*#__PURE__*/React.createElement(TabsProvider, {
    value: context
  }, /*#__PURE__*/React.createElement(StylesProvider, {
    value: styles
  }, /*#__PURE__*/React.createElement(chakra.div, _extends({
    className: cx("chakra-tabs", className),
    ref: ref
  }, rootProps, {
    __css: styles.root
  }), children))));
});

if (__DEV__) {
  Tabs.displayName = "Tabs";
}

/**
 * Tab button used to activate a specific tab panel. It renders a `button`,
 * and is responsible for automatic and manual selection modes.
 */
const Tab = /*#__PURE__*/forwardRef((props, ref) => {
  const styles = useStyles();
  const tabProps = useTab({ ...props,
    ref
  });
  const tabStyles = {
    outline: "0",
    display: "flex",
    alignItems: "center",
    justifyContent: "center",
    ...styles.tab
  };
  return /*#__PURE__*/React.createElement(chakra.button, _extends({}, tabProps, {
    className: cx("chakra-tabs__tab", props.className),
    __css: tabStyles
  }));
});

if (__DEV__) {
  Tab.displayName = "Tab";
}

/**
 * TabList is used to manage a list of tab buttons. It renders a `div` by default,
 * and is responsible the keyboard interaction between tabs.
 */
const TabList = /*#__PURE__*/forwardRef((props, ref) => {
  const tablistProps = useTabList({ ...props,
    ref
  });
  const styles = useStyles();
  const tablistStyles = {
    display: "flex",
    ...styles.tablist
  };
  return /*#__PURE__*/React.createElement(chakra.div, _extends({}, tablistProps, {
    className: cx("chakra-tabs__tablist", props.className),
    __css: tablistStyles
  }));
});

if (__DEV__) {
  TabList.displayName = "TabList";
}

/**
 * TabPanel
 * Used to render the content for a specific tab.
 */
const TabPanel = /*#__PURE__*/forwardRef((props, ref) => {
  const panelProps = useTabPanel({ ...props,
    ref
  });
  const styles = useStyles();
  return /*#__PURE__*/React.createElement(chakra.div, _extends({
    outline: "0"
  }, panelProps, {
    className: cx("chakra-tabs__tab-panel", props.className),
    __css: styles.tabpanel
  }));
});

if (__DEV__) {
  TabPanel.displayName = "TabPanel";
}

/**
 * TabPanel
 *
 * Used to manage the rendering of multiple tab panels. It uses
 * `cloneElement` to hide/show tab panels.
 *
 * It renders a `div` by default.
 */
const TabPanels = /*#__PURE__*/forwardRef((props, ref) => {
  const panelsProps = useTabPanels(props);
  const styles = useStyles();
  return /*#__PURE__*/React.createElement(chakra.div, _extends({}, panelsProps, {
    width: "100%",
    ref: ref,
    className: cx("chakra-tabs__tab-panels", props.className),
    __css: styles.tabpanels
  }));
});

if (__DEV__) {
  TabPanels.displayName = "TabPanels";
}

/**
 * TabIndicator
 *
 * Used to render an active tab indicator that animates between
 * selected tabs.
 */
const TabIndicator = /*#__PURE__*/forwardRef((props, ref) => {
  const indicatorStyle = useTabIndicator();
  const style = { ...props.style,
    ...indicatorStyle
  };
  const styles = useStyles();
  return /*#__PURE__*/React.createElement(chakra.div, _extends({
    ref: ref
  }, props, {
    className: cx("chakra-tabs__tab-indicator", props.className),
    style: style,
    __css: styles.indicator
  }));
});

if (__DEV__) {
  TabIndicator.displayName = "TabIndicator";
}

export { Tab, TabIndicator, TabList, TabPanel, TabPanels, Tabs, TabsDescendantsProvider, TabsProvider, useTab, useTabIndicator, useTabList, useTabPanel, useTabPanels, useTabs, useTabsContext, useTabsDescendant, useTabsDescendants, useTabsDescendantsContext };

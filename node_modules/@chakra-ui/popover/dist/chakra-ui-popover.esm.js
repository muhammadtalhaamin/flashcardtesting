import { CloseButton } from '@chakra-ui/close-button';
import { chakra, useMultiStyleConfig, omitThemingProps, useTheme, StylesProvider, forwardRef, useStyles } from '@chakra-ui/system';
import { mergeWith, determineLazyBehavior, px, callAllHandlers, getRelatedTarget, contains, runIfFn, __DEV__, cx } from '@chakra-ui/utils';
import * as React from 'react';
import React__default, { useRef, useState, useCallback, useEffect } from 'react';
import { createContext, mergeRefs } from '@chakra-ui/react-utils';
import { motion } from 'framer-motion';
import { useDisclosure, useIds, useFocusOnPointerDown, useFocusOnHide, useFocusOnShow } from '@chakra-ui/hooks';
import { usePopper, popperCSSVars } from '@chakra-ui/popper';

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

const [PopoverProvider, usePopoverContext] = createContext({
  name: "PopoverContext",
  errorMessage: "usePopoverContext: `context` is undefined. Seems you forgot to wrap all popover components within `<Popover />`"
});

const mergeVariants = variants => {
  if (!variants) return;
  return mergeWith(variants, {
    enter: {
      visibility: "visible"
    },
    exit: {
      transitionEnd: {
        visibility: "hidden"
      }
    }
  });
};

const scaleFade = {
  exit: {
    opacity: 0,
    scale: 0.95,
    transition: {
      duration: 0.1,
      ease: [0.4, 0, 1, 1]
    }
  },
  enter: {
    scale: 1,
    opacity: 1,
    transition: {
      duration: 0.15,
      ease: [0, 0, 0.2, 1]
    }
  }
};
const Section = motion(chakra.section);
const PopoverTransition = /*#__PURE__*/React__default.forwardRef((props, ref) => {
  const {
    isOpen
  } = usePopoverContext();
  return /*#__PURE__*/React__default.createElement(Section, _extends({
    ref: ref,
    variants: mergeVariants(props.variants)
  }, props, {
    initial: false,
    animate: isOpen ? "enter" : "exit"
  }));
});
PopoverTransition.defaultProps = {
  variants: scaleFade
};

const TRIGGER = {
  click: "click",
  hover: "hover"
};

/**
 * @internal
 */
function usePopover(props = {}) {
  const {
    closeOnBlur = true,
    closeOnEsc = true,
    initialFocusRef,
    id,
    returnFocusOnClose = true,
    autoFocus = true,
    arrowSize,
    arrowShadowColor,
    trigger = TRIGGER.click,
    openDelay = 200,
    closeDelay = 200,
    isLazy,
    lazyBehavior = "unmount",
    computePositionOnMount,
    ...popperProps
  } = props;
  const {
    isOpen,
    onClose,
    onOpen,
    onToggle
  } = useDisclosure(props);
  const triggerRef = useRef(null);
  const popoverRef = useRef(null);
  const isHoveringRef = useRef(false);
  const hasBeenOpened = useRef(false);

  if (isOpen) {
    hasBeenOpened.current = true;
  }

  const [hasHeader, setHasHeader] = useState(false);
  const [hasBody, setHasBody] = useState(false);
  const [triggerId, popoverId, headerId, bodyId] = useIds(id, "popover-trigger", "popover-content", "popover-header", "popover-body");
  const {
    referenceRef,
    getArrowProps,
    getPopperProps,
    getArrowInnerProps,
    forceUpdate
  } = usePopper({ ...popperProps,
    enabled: isOpen || !!computePositionOnMount
  });
  useFocusOnPointerDown({
    enabled: isOpen,
    ref: triggerRef
  });
  useFocusOnHide(popoverRef, {
    focusRef: triggerRef,
    visible: isOpen,
    shouldFocus: returnFocusOnClose && trigger === TRIGGER.click
  });
  useFocusOnShow(popoverRef, {
    focusRef: initialFocusRef,
    visible: isOpen,
    shouldFocus: autoFocus && trigger === TRIGGER.click
  });
  const shouldRenderChildren = determineLazyBehavior({
    hasBeenSelected: hasBeenOpened.current,
    isLazy,
    lazyBehavior,
    isSelected: isOpen
  });
  const getPopoverProps = useCallback((props = {}, _ref = null) => {
    const popoverProps = { ...props,
      style: { ...props.style,
        transformOrigin: popperCSSVars.transformOrigin.varRef,
        [popperCSSVars.arrowSize.var]: arrowSize ? px(arrowSize) : undefined,
        [popperCSSVars.arrowShadowColor.var]: arrowShadowColor
      },
      ref: mergeRefs(popoverRef, _ref),
      children: shouldRenderChildren ? props.children : null,
      id: popoverId,
      tabIndex: -1,
      role: "dialog",
      onKeyDown: callAllHandlers(props.onKeyDown, event => {
        if (closeOnEsc && event.key === "Escape") {
          onClose();
        }
      }),
      onBlur: callAllHandlers(props.onBlur, event => {
        const relatedTarget = getRelatedTarget(event);
        const targetIsPopover = contains(popoverRef.current, relatedTarget);
        const targetIsTrigger = contains(triggerRef.current, relatedTarget);
        const isValidBlur = !targetIsPopover && !targetIsTrigger;

        if (isOpen && closeOnBlur && isValidBlur) {
          onClose();
        }
      }),
      "aria-labelledby": hasHeader ? headerId : undefined,
      "aria-describedby": hasBody ? bodyId : undefined
    };

    if (trigger === TRIGGER.hover) {
      popoverProps.role = "tooltip";
      popoverProps.onMouseEnter = callAllHandlers(props.onMouseEnter, () => {
        isHoveringRef.current = true;
      });
      popoverProps.onMouseLeave = callAllHandlers(props.onMouseLeave, () => {
        isHoveringRef.current = false;
        setTimeout(onClose, closeDelay);
      });
    }

    return popoverProps;
  }, [shouldRenderChildren, popoverId, hasHeader, headerId, hasBody, bodyId, trigger, closeOnEsc, onClose, isOpen, closeOnBlur, closeDelay, arrowShadowColor, arrowSize]);
  const getPopoverPositionerProps = useCallback((props = {}, forwardedRef = null) => getPopperProps({ ...props,
    style: {
      visibility: isOpen ? "visible" : "hidden",
      ...props.style
    }
  }, forwardedRef), [isOpen, getPopperProps]);
  const openTimeout = useRef();
  const closeTimeout = useRef();
  const getTriggerProps = useCallback((props = {}, _ref = null) => {
    const triggerProps = { ...props,
      ref: mergeRefs(triggerRef, _ref, referenceRef),
      id: triggerId,
      "aria-haspopup": "dialog",
      "aria-expanded": isOpen,
      "aria-controls": popoverId
    };

    if (trigger === TRIGGER.click) {
      triggerProps.onClick = callAllHandlers(props.onClick, onToggle);
    }

    if (trigger === TRIGGER.hover) {
      /**
       * Any content that shows on pointer hover should also show on keyboard focus.
       * Consider focus and blur to be the `hover` for keyboard users.
       *
       * @see https://www.w3.org/WAI/WCAG21/Understanding/content-on-hover-or-focus.html
       */
      triggerProps.onFocus = callAllHandlers(props.onFocus, onOpen);
      triggerProps.onBlur = callAllHandlers(props.onBlur, onClose);
      /**
       * Any content that shows on hover or focus must be dismissible.
       * This case pressing `Escape` will dismiss the popover
       */

      triggerProps.onKeyDown = callAllHandlers(props.onKeyDown, event => {
        if (event.key === "Escape") {
          onClose();
        }
      });
      triggerProps.onMouseEnter = callAllHandlers(props.onMouseEnter, () => {
        isHoveringRef.current = true;
        openTimeout.current = window.setTimeout(onOpen, openDelay);
      });
      triggerProps.onMouseLeave = callAllHandlers(props.onMouseLeave, () => {
        isHoveringRef.current = false;

        if (openTimeout.current) {
          clearTimeout(openTimeout.current);
          openTimeout.current = undefined;
        }

        closeTimeout.current = window.setTimeout(() => {
          if (isHoveringRef.current === false) {
            onClose();
          }
        }, closeDelay);
      });
    }

    return triggerProps;
  }, [triggerId, isOpen, popoverId, trigger, referenceRef, onToggle, onOpen, onClose, openDelay, closeDelay]);
  useEffect(() => {
    return () => {
      if (openTimeout.current) {
        clearTimeout(openTimeout.current);
      }

      if (closeTimeout.current) {
        clearTimeout(closeTimeout.current);
      }
    };
  }, []);
  const getHeaderProps = useCallback((props = {}, ref = null) => ({ ...props,
    id: headerId,
    ref: mergeRefs(ref, node => {
      setHasHeader(!!node);
    })
  }), [headerId]);
  const getBodyProps = useCallback((props = {}, ref = null) => ({ ...props,
    id: bodyId,
    ref: mergeRefs(ref, node => {
      setHasBody(!!node);
    })
  }), [bodyId]);
  return {
    forceUpdate,
    isOpen,
    onClose,
    getArrowProps,
    getArrowInnerProps,
    getPopoverPositionerProps,
    getPopoverProps,
    getTriggerProps,
    getHeaderProps,
    getBodyProps
  };
}

/**
 * Popover is used to bring attention to specific user interface elements,
 * typically to suggest an action or to guide users through a new experience.
 */
const Popover = props => {
  const styles = useMultiStyleConfig("Popover", props);
  const {
    children,
    ...rest
  } = omitThemingProps(props);
  const theme = useTheme();
  const context = usePopover({ ...rest,
    direction: theme.direction
  });
  return /*#__PURE__*/React.createElement(PopoverProvider, {
    value: context
  }, /*#__PURE__*/React.createElement(StylesProvider, {
    value: styles
  }, runIfFn(children, {
    isOpen: context.isOpen,
    onClose: context.onClose,
    forceUpdate: context.forceUpdate
  })));
};

if (__DEV__) {
  Popover.displayName = "Popover";
}
/**
 * PopoverTrigger opens the popover's content. It must be an interactive element
 * such as `button` or `a`.
 */


const PopoverTrigger = props => {
  // enforce a single child
  const child = React.Children.only(props.children);
  const {
    getTriggerProps
  } = usePopoverContext();
  return /*#__PURE__*/React.cloneElement(child, getTriggerProps(child.props, child.ref));
};

if (__DEV__) {
  PopoverTrigger.displayName = "PopoverTrigger";
}

const PopoverContent = /*#__PURE__*/forwardRef((props, ref) => {
  const {
    rootProps,
    ...contentProps
  } = props;
  const {
    getPopoverProps,
    getPopoverPositionerProps
  } = usePopoverContext();
  const styles = useStyles();
  const contentStyles = {
    position: "relative",
    display: "flex",
    flexDirection: "column",
    ...styles.content
  };
  return /*#__PURE__*/React.createElement(chakra.div, _extends({}, getPopoverPositionerProps(rootProps), {
    __css: styles.popper,
    className: "chakra-popover__popper"
  }), /*#__PURE__*/React.createElement(PopoverTransition, _extends({}, getPopoverProps(contentProps, ref), {
    className: cx("chakra-popover__content", props.className),
    __css: contentStyles
  })));
});

if (__DEV__) {
  PopoverContent.displayName = "PopoverContent";
}

/**
 * PopoverHeader is the accessible header or label
 * for the popover's content and it is first announced by screenreaders.
 */
const PopoverHeader = /*#__PURE__*/forwardRef((props, ref) => {
  const {
    getHeaderProps
  } = usePopoverContext();
  const styles = useStyles();
  return /*#__PURE__*/React.createElement(chakra.header, _extends({}, getHeaderProps(props, ref), {
    className: cx("chakra-popover__header", props.className),
    __css: styles.header
  }));
});

if (__DEV__) {
  PopoverHeader.displayName = "PopoverHeader";
}

/**
 * PopoverBody is the main content area for the popover. Should contain
 * at least one interactive element.
 */
const PopoverBody = /*#__PURE__*/forwardRef((props, ref) => {
  const {
    getBodyProps
  } = usePopoverContext();
  const styles = useStyles();
  return /*#__PURE__*/React.createElement(chakra.div, _extends({}, getBodyProps(props, ref), {
    className: cx("chakra-popover__body", props.className),
    __css: styles.body
  }));
});

if (__DEV__) {
  PopoverBody.displayName = "PopoverBody";
}

const PopoverFooter = props => {
  const styles = useStyles();
  return /*#__PURE__*/React.createElement(chakra.footer, _extends({}, props, {
    className: cx("chakra-popover__footer", props.className),
    __css: styles.footer
  }));
};

if (__DEV__) {
  PopoverFooter.displayName = "PopoverFooter";
}

const PopoverCloseButton = props => {
  const {
    onClose
  } = usePopoverContext();
  const styles = useStyles();
  return /*#__PURE__*/React.createElement(CloseButton, _extends({
    size: "sm",
    onClick: onClose,
    className: cx("chakra-popover__close-btn", props.className),
    __css: styles.closeButton
  }, props));
};

if (__DEV__) {
  PopoverCloseButton.displayName = "PopoverCloseButton";
}

const PopoverArrow = props => {
  const {
    bg,
    bgColor,
    backgroundColor
  } = props;
  const {
    getArrowProps,
    getArrowInnerProps
  } = usePopoverContext();
  const styles = useStyles();
  const arrowBg = bg ?? bgColor ?? backgroundColor;
  return /*#__PURE__*/React.createElement(chakra.div, _extends({}, getArrowProps(), {
    className: "chakra-popover__arrow-positioner"
  }), /*#__PURE__*/React.createElement(chakra.div, _extends({
    className: cx("chakra-popover__arrow", props.className)
  }, getArrowInnerProps(props), {
    __css: { ...styles.arrow,
      "--popper-arrow-bg": arrowBg ? `colors.${arrowBg}, ${arrowBg}` : undefined
    }
  })));
};

if (__DEV__) {
  PopoverArrow.displayName = "PopoverArrow";
}

export { Popover, PopoverArrow, PopoverBody, PopoverCloseButton, PopoverContent, PopoverFooter, PopoverHeader, PopoverTrigger, usePopover, usePopoverContext };

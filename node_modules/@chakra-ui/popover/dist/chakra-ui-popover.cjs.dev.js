'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var closeButton = require('@chakra-ui/close-button');
var system = require('@chakra-ui/system');
var utils = require('@chakra-ui/utils');
var React = require('react');
var reactUtils = require('@chakra-ui/react-utils');
var framerMotion = require('framer-motion');
var hooks = require('@chakra-ui/hooks');
var popper = require('@chakra-ui/popper');

function _interopNamespace(e) {
  if (e && e.__esModule) return e;
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n["default"] = e;
  return Object.freeze(n);
}

var React__namespace = /*#__PURE__*/_interopNamespace(React);

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

const [PopoverProvider, usePopoverContext] = reactUtils.createContext({
  name: "PopoverContext",
  errorMessage: "usePopoverContext: `context` is undefined. Seems you forgot to wrap all popover components within `<Popover />`"
});

const mergeVariants = variants => {
  if (!variants) return;
  return utils.mergeWith(variants, {
    enter: {
      visibility: "visible"
    },
    exit: {
      transitionEnd: {
        visibility: "hidden"
      }
    }
  });
};

const scaleFade = {
  exit: {
    opacity: 0,
    scale: 0.95,
    transition: {
      duration: 0.1,
      ease: [0.4, 0, 1, 1]
    }
  },
  enter: {
    scale: 1,
    opacity: 1,
    transition: {
      duration: 0.15,
      ease: [0, 0, 0.2, 1]
    }
  }
};
const Section = framerMotion.motion(system.chakra.section);
const PopoverTransition = /*#__PURE__*/React__namespace["default"].forwardRef((props, ref) => {
  const {
    isOpen
  } = usePopoverContext();
  return /*#__PURE__*/React__namespace["default"].createElement(Section, _extends({
    ref: ref,
    variants: mergeVariants(props.variants)
  }, props, {
    initial: false,
    animate: isOpen ? "enter" : "exit"
  }));
});
PopoverTransition.defaultProps = {
  variants: scaleFade
};

const TRIGGER = {
  click: "click",
  hover: "hover"
};

/**
 * @internal
 */
function usePopover(props = {}) {
  const {
    closeOnBlur = true,
    closeOnEsc = true,
    initialFocusRef,
    id,
    returnFocusOnClose = true,
    autoFocus = true,
    arrowSize,
    arrowShadowColor,
    trigger = TRIGGER.click,
    openDelay = 200,
    closeDelay = 200,
    isLazy,
    lazyBehavior = "unmount",
    computePositionOnMount,
    ...popperProps
  } = props;
  const {
    isOpen,
    onClose,
    onOpen,
    onToggle
  } = hooks.useDisclosure(props);
  const triggerRef = React.useRef(null);
  const popoverRef = React.useRef(null);
  const isHoveringRef = React.useRef(false);
  const hasBeenOpened = React.useRef(false);

  if (isOpen) {
    hasBeenOpened.current = true;
  }

  const [hasHeader, setHasHeader] = React.useState(false);
  const [hasBody, setHasBody] = React.useState(false);
  const [triggerId, popoverId, headerId, bodyId] = hooks.useIds(id, "popover-trigger", "popover-content", "popover-header", "popover-body");
  const {
    referenceRef,
    getArrowProps,
    getPopperProps,
    getArrowInnerProps,
    forceUpdate
  } = popper.usePopper({ ...popperProps,
    enabled: isOpen || !!computePositionOnMount
  });
  hooks.useFocusOnPointerDown({
    enabled: isOpen,
    ref: triggerRef
  });
  hooks.useFocusOnHide(popoverRef, {
    focusRef: triggerRef,
    visible: isOpen,
    shouldFocus: returnFocusOnClose && trigger === TRIGGER.click
  });
  hooks.useFocusOnShow(popoverRef, {
    focusRef: initialFocusRef,
    visible: isOpen,
    shouldFocus: autoFocus && trigger === TRIGGER.click
  });
  const shouldRenderChildren = utils.determineLazyBehavior({
    hasBeenSelected: hasBeenOpened.current,
    isLazy,
    lazyBehavior,
    isSelected: isOpen
  });
  const getPopoverProps = React.useCallback((props = {}, _ref = null) => {
    const popoverProps = { ...props,
      style: { ...props.style,
        transformOrigin: popper.popperCSSVars.transformOrigin.varRef,
        [popper.popperCSSVars.arrowSize.var]: arrowSize ? utils.px(arrowSize) : undefined,
        [popper.popperCSSVars.arrowShadowColor.var]: arrowShadowColor
      },
      ref: reactUtils.mergeRefs(popoverRef, _ref),
      children: shouldRenderChildren ? props.children : null,
      id: popoverId,
      tabIndex: -1,
      role: "dialog",
      onKeyDown: utils.callAllHandlers(props.onKeyDown, event => {
        if (closeOnEsc && event.key === "Escape") {
          onClose();
        }
      }),
      onBlur: utils.callAllHandlers(props.onBlur, event => {
        const relatedTarget = utils.getRelatedTarget(event);
        const targetIsPopover = utils.contains(popoverRef.current, relatedTarget);
        const targetIsTrigger = utils.contains(triggerRef.current, relatedTarget);
        const isValidBlur = !targetIsPopover && !targetIsTrigger;

        if (isOpen && closeOnBlur && isValidBlur) {
          onClose();
        }
      }),
      "aria-labelledby": hasHeader ? headerId : undefined,
      "aria-describedby": hasBody ? bodyId : undefined
    };

    if (trigger === TRIGGER.hover) {
      popoverProps.role = "tooltip";
      popoverProps.onMouseEnter = utils.callAllHandlers(props.onMouseEnter, () => {
        isHoveringRef.current = true;
      });
      popoverProps.onMouseLeave = utils.callAllHandlers(props.onMouseLeave, () => {
        isHoveringRef.current = false;
        setTimeout(onClose, closeDelay);
      });
    }

    return popoverProps;
  }, [shouldRenderChildren, popoverId, hasHeader, headerId, hasBody, bodyId, trigger, closeOnEsc, onClose, isOpen, closeOnBlur, closeDelay, arrowShadowColor, arrowSize]);
  const getPopoverPositionerProps = React.useCallback((props = {}, forwardedRef = null) => getPopperProps({ ...props,
    style: {
      visibility: isOpen ? "visible" : "hidden",
      ...props.style
    }
  }, forwardedRef), [isOpen, getPopperProps]);
  const openTimeout = React.useRef();
  const closeTimeout = React.useRef();
  const getTriggerProps = React.useCallback((props = {}, _ref = null) => {
    const triggerProps = { ...props,
      ref: reactUtils.mergeRefs(triggerRef, _ref, referenceRef),
      id: triggerId,
      "aria-haspopup": "dialog",
      "aria-expanded": isOpen,
      "aria-controls": popoverId
    };

    if (trigger === TRIGGER.click) {
      triggerProps.onClick = utils.callAllHandlers(props.onClick, onToggle);
    }

    if (trigger === TRIGGER.hover) {
      /**
       * Any content that shows on pointer hover should also show on keyboard focus.
       * Consider focus and blur to be the `hover` for keyboard users.
       *
       * @see https://www.w3.org/WAI/WCAG21/Understanding/content-on-hover-or-focus.html
       */
      triggerProps.onFocus = utils.callAllHandlers(props.onFocus, onOpen);
      triggerProps.onBlur = utils.callAllHandlers(props.onBlur, onClose);
      /**
       * Any content that shows on hover or focus must be dismissible.
       * This case pressing `Escape` will dismiss the popover
       */

      triggerProps.onKeyDown = utils.callAllHandlers(props.onKeyDown, event => {
        if (event.key === "Escape") {
          onClose();
        }
      });
      triggerProps.onMouseEnter = utils.callAllHandlers(props.onMouseEnter, () => {
        isHoveringRef.current = true;
        openTimeout.current = window.setTimeout(onOpen, openDelay);
      });
      triggerProps.onMouseLeave = utils.callAllHandlers(props.onMouseLeave, () => {
        isHoveringRef.current = false;

        if (openTimeout.current) {
          clearTimeout(openTimeout.current);
          openTimeout.current = undefined;
        }

        closeTimeout.current = window.setTimeout(() => {
          if (isHoveringRef.current === false) {
            onClose();
          }
        }, closeDelay);
      });
    }

    return triggerProps;
  }, [triggerId, isOpen, popoverId, trigger, referenceRef, onToggle, onOpen, onClose, openDelay, closeDelay]);
  React.useEffect(() => {
    return () => {
      if (openTimeout.current) {
        clearTimeout(openTimeout.current);
      }

      if (closeTimeout.current) {
        clearTimeout(closeTimeout.current);
      }
    };
  }, []);
  const getHeaderProps = React.useCallback((props = {}, ref = null) => ({ ...props,
    id: headerId,
    ref: reactUtils.mergeRefs(ref, node => {
      setHasHeader(!!node);
    })
  }), [headerId]);
  const getBodyProps = React.useCallback((props = {}, ref = null) => ({ ...props,
    id: bodyId,
    ref: reactUtils.mergeRefs(ref, node => {
      setHasBody(!!node);
    })
  }), [bodyId]);
  return {
    forceUpdate,
    isOpen,
    onClose,
    getArrowProps,
    getArrowInnerProps,
    getPopoverPositionerProps,
    getPopoverProps,
    getTriggerProps,
    getHeaderProps,
    getBodyProps
  };
}

/**
 * Popover is used to bring attention to specific user interface elements,
 * typically to suggest an action or to guide users through a new experience.
 */
const Popover = props => {
  const styles = system.useMultiStyleConfig("Popover", props);
  const {
    children,
    ...rest
  } = system.omitThemingProps(props);
  const theme = system.useTheme();
  const context = usePopover({ ...rest,
    direction: theme.direction
  });
  return /*#__PURE__*/React__namespace.createElement(PopoverProvider, {
    value: context
  }, /*#__PURE__*/React__namespace.createElement(system.StylesProvider, {
    value: styles
  }, utils.runIfFn(children, {
    isOpen: context.isOpen,
    onClose: context.onClose,
    forceUpdate: context.forceUpdate
  })));
};

if (utils.__DEV__) {
  Popover.displayName = "Popover";
}
/**
 * PopoverTrigger opens the popover's content. It must be an interactive element
 * such as `button` or `a`.
 */


const PopoverTrigger = props => {
  // enforce a single child
  const child = React__namespace.Children.only(props.children);
  const {
    getTriggerProps
  } = usePopoverContext();
  return /*#__PURE__*/React__namespace.cloneElement(child, getTriggerProps(child.props, child.ref));
};

if (utils.__DEV__) {
  PopoverTrigger.displayName = "PopoverTrigger";
}

const PopoverContent = /*#__PURE__*/system.forwardRef((props, ref) => {
  const {
    rootProps,
    ...contentProps
  } = props;
  const {
    getPopoverProps,
    getPopoverPositionerProps
  } = usePopoverContext();
  const styles = system.useStyles();
  const contentStyles = {
    position: "relative",
    display: "flex",
    flexDirection: "column",
    ...styles.content
  };
  return /*#__PURE__*/React__namespace.createElement(system.chakra.div, _extends({}, getPopoverPositionerProps(rootProps), {
    __css: styles.popper,
    className: "chakra-popover__popper"
  }), /*#__PURE__*/React__namespace.createElement(PopoverTransition, _extends({}, getPopoverProps(contentProps, ref), {
    className: utils.cx("chakra-popover__content", props.className),
    __css: contentStyles
  })));
});

if (utils.__DEV__) {
  PopoverContent.displayName = "PopoverContent";
}

/**
 * PopoverHeader is the accessible header or label
 * for the popover's content and it is first announced by screenreaders.
 */
const PopoverHeader = /*#__PURE__*/system.forwardRef((props, ref) => {
  const {
    getHeaderProps
  } = usePopoverContext();
  const styles = system.useStyles();
  return /*#__PURE__*/React__namespace.createElement(system.chakra.header, _extends({}, getHeaderProps(props, ref), {
    className: utils.cx("chakra-popover__header", props.className),
    __css: styles.header
  }));
});

if (utils.__DEV__) {
  PopoverHeader.displayName = "PopoverHeader";
}

/**
 * PopoverBody is the main content area for the popover. Should contain
 * at least one interactive element.
 */
const PopoverBody = /*#__PURE__*/system.forwardRef((props, ref) => {
  const {
    getBodyProps
  } = usePopoverContext();
  const styles = system.useStyles();
  return /*#__PURE__*/React__namespace.createElement(system.chakra.div, _extends({}, getBodyProps(props, ref), {
    className: utils.cx("chakra-popover__body", props.className),
    __css: styles.body
  }));
});

if (utils.__DEV__) {
  PopoverBody.displayName = "PopoverBody";
}

const PopoverFooter = props => {
  const styles = system.useStyles();
  return /*#__PURE__*/React__namespace.createElement(system.chakra.footer, _extends({}, props, {
    className: utils.cx("chakra-popover__footer", props.className),
    __css: styles.footer
  }));
};

if (utils.__DEV__) {
  PopoverFooter.displayName = "PopoverFooter";
}

const PopoverCloseButton = props => {
  const {
    onClose
  } = usePopoverContext();
  const styles = system.useStyles();
  return /*#__PURE__*/React__namespace.createElement(closeButton.CloseButton, _extends({
    size: "sm",
    onClick: onClose,
    className: utils.cx("chakra-popover__close-btn", props.className),
    __css: styles.closeButton
  }, props));
};

if (utils.__DEV__) {
  PopoverCloseButton.displayName = "PopoverCloseButton";
}

const PopoverArrow = props => {
  const {
    bg,
    bgColor,
    backgroundColor
  } = props;
  const {
    getArrowProps,
    getArrowInnerProps
  } = usePopoverContext();
  const styles = system.useStyles();
  const arrowBg = bg ?? bgColor ?? backgroundColor;
  return /*#__PURE__*/React__namespace.createElement(system.chakra.div, _extends({}, getArrowProps(), {
    className: "chakra-popover__arrow-positioner"
  }), /*#__PURE__*/React__namespace.createElement(system.chakra.div, _extends({
    className: utils.cx("chakra-popover__arrow", props.className)
  }, getArrowInnerProps(props), {
    __css: { ...styles.arrow,
      "--popper-arrow-bg": arrowBg ? `colors.${arrowBg}, ${arrowBg}` : undefined
    }
  })));
};

if (utils.__DEV__) {
  PopoverArrow.displayName = "PopoverArrow";
}

exports.Popover = Popover;
exports.PopoverArrow = PopoverArrow;
exports.PopoverBody = PopoverBody;
exports.PopoverCloseButton = PopoverCloseButton;
exports.PopoverContent = PopoverContent;
exports.PopoverFooter = PopoverFooter;
exports.PopoverHeader = PopoverHeader;
exports.PopoverTrigger = PopoverTrigger;
exports.usePopover = usePopover;
exports.usePopoverContext = usePopoverContext;

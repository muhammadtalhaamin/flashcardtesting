import { createContext, mergeRefs } from '@chakra-ui/react-utils';
import { useLayoutEffect, useEffect, useRef, useState } from 'react';

/**
 * Sort an array of DOM nodes according to the HTML tree order
 * @see http://www.w3.org/TR/html5/infrastructure.html#tree-order
 */

function sortNodes(nodes) {
  return nodes.sort((a, b) => {
    const compare = a.compareDocumentPosition(b);

    if (compare & Node.DOCUMENT_POSITION_FOLLOWING || compare & Node.DOCUMENT_POSITION_CONTAINED_BY) {
      // a < b
      return -1;
    }

    if (compare & Node.DOCUMENT_POSITION_PRECEDING || compare & Node.DOCUMENT_POSITION_CONTAINS) {
      // a > b
      return 1;
    }

    if (compare & Node.DOCUMENT_POSITION_DISCONNECTED || compare & Node.DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC) {
      throw Error("Cannot sort the given nodes.");
    } else {
      return 0;
    }
  });
}
const isElement = el => typeof el == "object" && "nodeType" in el && el.nodeType === Node.ELEMENT_NODE;
function getNextIndex(current, max, loop) {
  let next = current + 1;
  if (loop && next >= max) next = 0;
  return next;
}
function getPrevIndex(current, max, loop) {
  let next = current - 1;
  if (loop && next < 0) next = max;
  return next;
}
const useSafeLayoutEffect = typeof window !== "undefined" ? useLayoutEffect : useEffect;
const cast = value => value;

/**
 * @internal
 *
 * Class to manage descendants and their relative indices in the DOM.
 * It uses `node.compareDocumentPosition(...)` under the hood
 */
class DescendantsManager {
  constructor() {
    this.descendants = new Map();

    this.register = nodeOrOptions => {
      if (nodeOrOptions == null) return;

      if (isElement(nodeOrOptions)) {
        return this.registerNode(nodeOrOptions);
      }

      return node => {
        this.registerNode(node, nodeOrOptions);
      };
    };

    this.unregister = node => {
      this.descendants.delete(node);
      const sorted = sortNodes(Array.from(this.descendants.keys()));
      this.assignIndex(sorted);
    };

    this.destroy = () => {
      this.descendants.clear();
    };

    this.assignIndex = descendants => {
      this.descendants.forEach(descendant => {
        const index = descendants.indexOf(descendant.node);
        descendant.index = index;
        descendant.node.dataset.index = descendant.index.toString();
      });
    };

    this.count = () => this.descendants.size;

    this.enabledCount = () => this.enabledValues().length;

    this.values = () => {
      const values = Array.from(this.descendants.values());
      return values.sort((a, b) => a.index - b.index);
    };

    this.enabledValues = () => {
      return this.values().filter(descendant => !descendant.disabled);
    };

    this.item = index => {
      if (this.count() === 0) return undefined;
      return this.values()[index];
    };

    this.enabledItem = index => {
      if (this.enabledCount() === 0) return undefined;
      return this.enabledValues()[index];
    };

    this.first = () => this.item(0);

    this.firstEnabled = () => this.enabledItem(0);

    this.last = () => this.item(this.descendants.size - 1);

    this.lastEnabled = () => {
      const lastIndex = this.enabledValues().length - 1;
      return this.enabledItem(lastIndex);
    };

    this.indexOf = node => {
      if (!node) return -1;
      return this.descendants.get(node)?.index ?? -1;
    };

    this.enabledIndexOf = node => {
      if (node == null) return -1;
      return this.enabledValues().findIndex(i => i.node.isSameNode(node));
    };

    this.next = (index, loop = true) => {
      const next = getNextIndex(index, this.count(), loop);
      return this.item(next);
    };

    this.nextEnabled = (index, loop = true) => {
      const item = this.item(index);
      if (!item) return;
      const enabledIndex = this.enabledIndexOf(item.node);
      const nextEnabledIndex = getNextIndex(enabledIndex, this.enabledCount(), loop);
      return this.enabledItem(nextEnabledIndex);
    };

    this.prev = (index, loop = true) => {
      const prev = getPrevIndex(index, this.count() - 1, loop);
      return this.item(prev);
    };

    this.prevEnabled = (index, loop = true) => {
      const item = this.item(index);
      if (!item) return;
      const enabledIndex = this.enabledIndexOf(item.node);
      const prevEnabledIndex = getPrevIndex(enabledIndex, this.enabledCount() - 1, loop);
      return this.enabledItem(prevEnabledIndex);
    };

    this.registerNode = (node, options) => {
      if (!node || this.descendants.has(node)) return;
      const keys = Array.from(this.descendants.keys()).concat(node);
      const sorted = sortNodes(keys);

      if (options?.disabled) {
        options.disabled = !!options.disabled;
      }

      const descendant = {
        node,
        index: -1,
        ...options
      };
      this.descendants.set(node, descendant);
      this.assignIndex(sorted);
    };
  }

}

/**
 * @internal
 * React hook that initializes the DescendantsManager
 */

function useDescendants() {
  const descendants = useRef(new DescendantsManager());
  useSafeLayoutEffect(() => {
    return () => descendants.current.destroy();
  });
  return descendants.current;
}

/* -------------------------------------------------------------------------------------------------
 * Descendants context to be used in component-land.
  - Mount the `DescendantsContextProvider` at the root of the component
  - Call `useDescendantsContext` anywhere you need access to the descendants information

  NB:  I recommend using `createDescendantContext` below
 * -----------------------------------------------------------------------------------------------*/
const [DescendantsContextProvider, useDescendantsContext] = createContext({
  name: "DescendantsProvider",
  errorMessage: "useDescendantsContext must be used within DescendantsProvider"
});
/**
 * @internal
 * This hook provides information a descendant such as:
 * - Its index compared to other descendants
 * - ref callback to register the descendant
 * - Its enabled index compared to other enabled descendants
 */

function useDescendant(options) {
  const descendants = useDescendantsContext();
  const [index, setIndex] = useState(-1);
  const ref = useRef(null);
  useSafeLayoutEffect(() => {
    return () => {
      if (!ref.current) return;
      descendants.unregister(ref.current);
    };
  }, []);
  useSafeLayoutEffect(() => {
    if (!ref.current) return;
    const dataIndex = Number(ref.current.dataset.index);

    if (index != dataIndex && !Number.isNaN(dataIndex)) {
      setIndex(dataIndex);
    }
  });
  const refCallback = options ? cast(descendants.register(options)) : cast(descendants.register);
  return {
    descendants,
    index,
    enabledIndex: descendants.enabledIndexOf(ref.current),
    register: mergeRefs(refCallback, ref)
  };
}
/* -------------------------------------------------------------------------------------------------
 * Function that provides strongly typed versions of the context provider and hooks above.
   To be used in component-land
 * -----------------------------------------------------------------------------------------------*/


function createDescendantContext() {
  const ContextProvider = cast(DescendantsContextProvider);

  const _useDescendantsContext = () => cast(useDescendantsContext());

  const _useDescendant = options => useDescendant(options);

  const _useDescendants = () => useDescendants();

  return [// context provider
  ContextProvider, // call this when you need to read from context
  _useDescendantsContext, // descendants state information, to be called and passed to `ContextProvider`
  _useDescendants, // descendant index information
  _useDescendant];
}

export { createDescendantContext, createDescendantContext as default };

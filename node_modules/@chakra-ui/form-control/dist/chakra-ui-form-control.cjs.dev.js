'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var hooks = require('@chakra-ui/hooks');
var system = require('@chakra-ui/system');
var utils = require('@chakra-ui/utils');
var reactUtils = require('@chakra-ui/react-utils');
var React = require('react');
var Icon = require('@chakra-ui/icon');

function _interopDefault (e) { return e && e.__esModule ? e : { 'default': e }; }

function _interopNamespace(e) {
  if (e && e.__esModule) return e;
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n["default"] = e;
  return Object.freeze(n);
}

var React__namespace = /*#__PURE__*/_interopNamespace(React);
var Icon__default = /*#__PURE__*/_interopDefault(Icon);

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

const [FormControlProvider, useFormControlContext] = reactUtils.createContext({
  strict: false,
  name: "FormControlContext"
});

function useFormControlProvider(props) {
  const {
    id: idProp,
    isRequired,
    isInvalid,
    isDisabled,
    isReadOnly,
    ...htmlProps
  } = props; // Generate all the required ids

  const uuid = hooks.useId();
  const id = idProp || `field-${uuid}`;
  const labelId = `${id}-label`;
  const feedbackId = `${id}-feedback`;
  const helpTextId = `${id}-helptext`;
  /**
   * Track whether the `FormErrorMessage` has been rendered.
   * We use this to append its id the the `aria-describedby` of the `input`.
   */

  const [hasFeedbackText, setHasFeedbackText] = React__namespace.useState(false);
  /**
   * Track whether the `FormHelperText` has been rendered.
   * We use this to append its id the the `aria-describedby` of the `input`.
   */

  const [hasHelpText, setHasHelpText] = React__namespace.useState(false); // Track whether the form element (e.g, `input`) has focus.

  const [isFocused, setFocus] = hooks.useBoolean();
  const getHelpTextProps = React__namespace.useCallback((props = {}, forwardedRef = null) => ({
    id: helpTextId,
    ...props,

    /**
     * Notify the field context when the help text is rendered on screen,
     * so we can apply the correct `aria-describedby` to the field (e.g. input, textarea).
     */
    ref: reactUtils.mergeRefs(forwardedRef, node => {
      if (!node) return;
      setHasHelpText(true);
    })
  }), [helpTextId]);
  const getLabelProps = React__namespace.useCallback((props = {}, forwardedRef = null) => ({ ...props,
    ref: forwardedRef,
    "data-focus": utils.dataAttr(isFocused),
    "data-disabled": utils.dataAttr(isDisabled),
    "data-invalid": utils.dataAttr(isInvalid),
    "data-readonly": utils.dataAttr(isReadOnly),
    id: props.id ?? labelId,
    htmlFor: props.htmlFor ?? id
  }), [id, isDisabled, isFocused, isInvalid, isReadOnly, labelId]);
  const getErrorMessageProps = React__namespace.useCallback((props = {}, forwardedRef = null) => ({
    id: feedbackId,
    ...props,

    /**
     * Notify the field context when the error message is rendered on screen,
     * so we can apply the correct `aria-describedby` to the field (e.g. input, textarea).
     */
    ref: reactUtils.mergeRefs(forwardedRef, node => {
      if (!node) return;
      setHasFeedbackText(true);
    }),
    "aria-live": "polite"
  }), [feedbackId]);
  const getRootProps = React__namespace.useCallback((props = {}, forwardedRef = null) => ({ ...props,
    ...htmlProps,
    ref: forwardedRef,
    role: "group"
  }), [htmlProps]);
  const getRequiredIndicatorProps = React__namespace.useCallback((props = {}, forwardedRef = null) => ({ ...props,
    ref: forwardedRef,
    role: "presentation",
    "aria-hidden": true,
    children: props.children || "*"
  }), []);
  return {
    isRequired: !!isRequired,
    isInvalid: !!isInvalid,
    isReadOnly: !!isReadOnly,
    isDisabled: !!isDisabled,
    isFocused: !!isFocused,
    onFocus: setFocus.on,
    onBlur: setFocus.off,
    hasFeedbackText,
    setHasFeedbackText,
    hasHelpText,
    setHasHelpText,
    id,
    labelId,
    feedbackId,
    helpTextId,
    htmlProps,
    getHelpTextProps,
    getErrorMessageProps,
    getRootProps,
    getLabelProps,
    getRequiredIndicatorProps
  };
}

/**
 * FormControl provides context such as
 * `isInvalid`, `isDisabled`, and `isRequired` to form elements.
 *
 * This is commonly used in form elements such as `input`,
 * `select`, `textarea`, etc.
 */
const FormControl = /*#__PURE__*/system.forwardRef((props, ref) => {
  const styles = system.useMultiStyleConfig("Form", props);
  const ownProps = system.omitThemingProps(props);
  const {
    getRootProps,
    htmlProps: _,
    ...context
  } = useFormControlProvider(ownProps);
  const className = utils.cx("chakra-form-control", props.className);
  const contextValue = React__namespace.useMemo(() => context, [context]);
  return /*#__PURE__*/React__namespace.createElement(FormControlProvider, {
    value: contextValue
  }, /*#__PURE__*/React__namespace.createElement(system.StylesProvider, {
    value: styles
  }, /*#__PURE__*/React__namespace.createElement(system.chakra.div, _extends({}, getRootProps({}, ref), {
    className: className,
    __css: styles["container"]
  }))));
});

if (utils.__DEV__) {
  FormControl.displayName = "FormControl";
}

/**
 * FormHelperText
 *
 * Assistive component that conveys additional guidance
 * about the field, such as how it will be used and what
 * types in values should be provided.
 */
const FormHelperText = /*#__PURE__*/system.forwardRef((props, ref) => {
  const field = useFormControlContext();
  const styles = system.useStyles();
  const className = utils.cx("chakra-form__helper-text", props.className);
  return /*#__PURE__*/React__namespace.createElement(system.chakra.div, _extends({}, field?.getHelpTextProps(props, ref), {
    __css: styles.helperText,
    className: className
  }));
});

if (utils.__DEV__) {
  FormHelperText.displayName = "FormHelperText";
}

/**
 * React hook that provides the props that should be spread on to
 * input fields (`input`, `select`, `textarea`, etc.).
 *
 * It provides a convenient way to control a form fields, validation
 * and helper text.
 *
 * @internal
 */
function useFormControl(props) {
  const {
    isDisabled,
    isInvalid,
    isReadOnly,
    isRequired,
    ...rest
  } = useFormControlProps(props);
  return { ...rest,
    disabled: isDisabled,
    readOnly: isReadOnly,
    required: isRequired,
    "aria-invalid": utils.ariaAttr(isInvalid),
    "aria-required": utils.ariaAttr(isRequired),
    "aria-readonly": utils.ariaAttr(isReadOnly)
  };
}
/**
 * @internal
 */

function useFormControlProps(props) {
  const field = useFormControlContext();
  const {
    id,
    disabled,
    readOnly,
    required,
    isRequired,
    isInvalid,
    isReadOnly,
    isDisabled,
    onFocus,
    onBlur,
    ...rest
  } = props;
  const labelIds = props["aria-describedby"] ? [props["aria-describedby"]] : []; // Error message must be described first in all scenarios.

  if (field?.hasFeedbackText && field?.isInvalid) {
    labelIds.push(field.feedbackId);
  }

  if (field?.hasHelpText) {
    labelIds.push(field.helpTextId);
  }

  return { ...rest,
    "aria-describedby": labelIds.join(" ") || undefined,
    id: id ?? field?.id,
    isDisabled: disabled ?? isDisabled ?? field?.isDisabled,
    isReadOnly: readOnly ?? isReadOnly ?? field?.isReadOnly,
    isRequired: required ?? isRequired ?? field?.isRequired,
    isInvalid: isInvalid ?? field?.isInvalid,
    onFocus: utils.callAllHandlers(field?.onFocus, onFocus),
    onBlur: utils.callAllHandlers(field?.onBlur, onBlur)
  };
}

/**
 * Used to provide feedback about an invalid input,
 * and suggest clear instructions on how to fix it.
 */
const FormErrorMessage = /*#__PURE__*/system.forwardRef((props, ref) => {
  const styles = system.useMultiStyleConfig("FormError", props);
  const ownProps = system.omitThemingProps(props);
  const field = useFormControlContext();
  if (!field?.isInvalid) return null;
  return /*#__PURE__*/React__namespace.createElement(system.StylesProvider, {
    value: styles
  }, /*#__PURE__*/React__namespace.createElement(system.chakra.div, _extends({}, field?.getErrorMessageProps(ownProps, ref), {
    className: utils.cx("chakra-form__error-message", props.className),
    __css: {
      display: "flex",
      alignItems: "center",
      ...styles.text
    }
  })));
});

if (utils.__DEV__) {
  FormErrorMessage.displayName = "FormErrorMessage";
}
/**
 * Used as the visual indicator that a field is invalid or
 * a field has incorrect values.
 */


const FormErrorIcon = /*#__PURE__*/system.forwardRef((props, ref) => {
  const styles = system.useStyles();
  const field = useFormControlContext();
  if (!field?.isInvalid) return null;

  const _className = utils.cx("chakra-form__error-icon", props.className);

  return /*#__PURE__*/React__namespace.createElement(Icon__default["default"], _extends({
    ref: ref,
    "aria-hidden": true
  }, props, {
    __css: styles.icon,
    className: _className
  }), /*#__PURE__*/React__namespace.createElement("path", {
    fill: "currentColor",
    d: "M11.983,0a12.206,12.206,0,0,0-8.51,3.653A11.8,11.8,0,0,0,0,12.207,11.779,11.779,0,0,0,11.8,24h.214A12.111,12.111,0,0,0,24,11.791h0A11.766,11.766,0,0,0,11.983,0ZM10.5,16.542a1.476,1.476,0,0,1,1.449-1.53h.027a1.527,1.527,0,0,1,1.523,1.47,1.475,1.475,0,0,1-1.449,1.53h-.027A1.529,1.529,0,0,1,10.5,16.542ZM11,12.5v-6a1,1,0,0,1,2,0v6a1,1,0,1,1-2,0Z"
  }));
});

if (utils.__DEV__) {
  FormErrorIcon.displayName = "FormErrorIcon";
}

/**
 * Used to enhance the usability of form controls.
 *
 * It is used to inform users as to what information
 * is requested for a form field.
 *
 * ♿️ Accessibility: Every form field should have a form label.
 */
const FormLabel = /*#__PURE__*/system.forwardRef((passedProps, ref) => {
  const styles = system.useStyleConfig("FormLabel", passedProps);
  const props = system.omitThemingProps(passedProps);
  const {
    className,
    children,
    requiredIndicator = /*#__PURE__*/React__namespace.createElement(RequiredIndicator, null),
    ...rest
  } = props;
  const field = useFormControlContext();
  const ownProps = field?.getLabelProps(rest, ref) ?? {
    ref,
    ...rest
  };
  return /*#__PURE__*/React__namespace.createElement(system.chakra.label, _extends({}, ownProps, {
    className: utils.cx("chakra-form__label", props.className),
    __css: {
      display: "block",
      textAlign: "start",
      ...styles
    }
  }), children, field?.isRequired ? requiredIndicator : null);
});

if (utils.__DEV__) {
  FormLabel.displayName = "FormLabel";
}

/**
 * Used to show a "required" text or an asterisks (*) to indicate that
 * a field is required.
 */
const RequiredIndicator = /*#__PURE__*/system.forwardRef((props, ref) => {
  const field = useFormControlContext();
  const styles = system.useStyles();
  if (!field?.isRequired) return null;
  const className = utils.cx("chakra-form__required-indicator", props.className);
  return /*#__PURE__*/React__namespace.createElement(system.chakra.span, _extends({}, field?.getRequiredIndicatorProps(props, ref), {
    __css: styles.requiredIndicator,
    className: className
  }));
});

if (utils.__DEV__) {
  RequiredIndicator.displayName = "RequiredIndicator";
}

exports.FormControl = FormControl;
exports.FormErrorIcon = FormErrorIcon;
exports.FormErrorMessage = FormErrorMessage;
exports.FormHelperText = FormHelperText;
exports.FormLabel = FormLabel;
exports.RequiredIndicator = RequiredIndicator;
exports.useFormControl = useFormControl;
exports.useFormControlContext = useFormControlContext;
exports.useFormControlProps = useFormControlProps;

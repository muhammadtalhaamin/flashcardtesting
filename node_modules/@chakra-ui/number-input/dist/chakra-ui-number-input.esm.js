import { useFormControlProps } from '@chakra-ui/form-control';
import { forwardRef, useMultiStyleConfig, omitThemingProps, StylesProvider, chakra, useStyles } from '@chakra-ui/system';
import { normalizeEventKey, isNull, focus, isBrowser, callAllHandlers, ariaAttr, minSafeInteger, maxSafeInteger, cx, __DEV__ } from '@chakra-ui/utils';
import { mergeRefs, createContext } from '@chakra-ui/react-utils';
import * as React from 'react';
import { useState, useRef, useCallback } from 'react';
import { Icon } from '@chakra-ui/icon';
import { useCounter } from '@chakra-ui/counter';
import { useInterval, useUnmountEffect, useCallbackRef, useBoolean, useSafeLayoutEffect, useEventListener } from '@chakra-ui/hooks';

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

const TriangleDownIcon = props => /*#__PURE__*/React.createElement(Icon, _extends({
  viewBox: "0 0 24 24"
}, props), /*#__PURE__*/React.createElement("path", {
  fill: "currentColor",
  d: "M21,5H3C2.621,5,2.275,5.214,2.105,5.553C1.937,5.892,1.973,6.297,2.2,6.6l9,12 c0.188,0.252,0.485,0.4,0.8,0.4s0.611-0.148,0.8-0.4l9-12c0.228-0.303,0.264-0.708,0.095-1.047C21.725,5.214,21.379,5,21,5z"
}));
const TriangleUpIcon = props => /*#__PURE__*/React.createElement(Icon, _extends({
  viewBox: "0 0 24 24"
}, props), /*#__PURE__*/React.createElement("path", {
  fill: "currentColor",
  d: "M12.8,5.4c-0.377-0.504-1.223-0.504-1.6,0l-9,12c-0.228,0.303-0.264,0.708-0.095,1.047 C2.275,18.786,2.621,19,3,19h18c0.379,0,0.725-0.214,0.895-0.553c0.169-0.339,0.133-0.744-0.095-1.047L12.8,5.4z"
}));

/**
 * When click and hold on a button - the speed of auto changing the value.
 */

const CONTINUOUS_CHANGE_INTERVAL = 50;
/**
 * When click and hold on a button - the delay before auto changing the value.
 */

const CONTINUOUS_CHANGE_DELAY = 300;

/**
 * React hook used in the number input to spin its
 * value on long press of the spin buttons
 *
 * @param increment the function to increment
 * @param decrement the function to decrement
 */
function useSpinner(increment, decrement) {
  /**
   * To keep incrementing/decrementing on press, we call that `spinning`
   */
  const [isSpinning, setIsSpinning] = useState(false); // This state keeps track of the action ("increment" or "decrement")

  const [action, setAction] = useState(null); // To increment the value the first time you mousedown, we call that `runOnce`

  const [runOnce, setRunOnce] = useState(true); // Store the timeout instance id in a ref, so we can clear the timeout later

  const timeoutRef = useRef(null); // Clears the timeout from memory

  const removeTimeout = () => clearTimeout(timeoutRef.current);
  /**
   * useInterval hook provides a performant way to
   * update the state value at specific interval
   */


  useInterval(() => {
    if (action === "increment") {
      increment();
    }

    if (action === "decrement") {
      decrement();
    }
  }, isSpinning ? CONTINUOUS_CHANGE_INTERVAL : null); // Function to activate the spinning and increment the value

  const up = useCallback(() => {
    // increment the first fime
    if (runOnce) {
      increment();
    } // after a delay, keep incrementing at interval ("spinning up")


    timeoutRef.current = setTimeout(() => {
      setRunOnce(false);
      setIsSpinning(true);
      setAction("increment");
    }, CONTINUOUS_CHANGE_DELAY);
  }, [increment, runOnce]); // Function to activate the spinning and increment the value

  const down = useCallback(() => {
    // decrement the first fime
    if (runOnce) {
      decrement();
    } // after a delay, keep decrementing at interval ("spinning down")


    timeoutRef.current = setTimeout(() => {
      setRunOnce(false);
      setIsSpinning(true);
      setAction("decrement");
    }, CONTINUOUS_CHANGE_DELAY);
  }, [decrement, runOnce]); // Function to stop spinng (useful for mouseup, keyup handlers)

  const stop = useCallback(() => {
    setRunOnce(true);
    setIsSpinning(false);
    removeTimeout();
  }, []);
  /**
   * If the component unmounts while spinning,
   * let's clear the timeout as well
   */

  useUnmountEffect(removeTimeout);
  return {
    up,
    down,
    stop
  };
}

const FLOATING_POINT_REGEX = /^[Ee0-9+\-.]$/;
/**
 * Determine if a character is a DOM floating point character
 * @see https://www.w3.org/TR/2012/WD-html-markup-20120329/datatypes.html#common.data.float
 */

function isFloatingPointNumericCharacter(character) {
  return FLOATING_POINT_REGEX.test(character);
}
/**
 * Determine if the event is a valid numeric keyboard event.
 * We use this so we can prevent non-number characters in the input
 */

function isValidNumericKeyboardEvent(event) {
  if (event.key == null) return true;
  const isModifierKey = event.ctrlKey || event.altKey || event.metaKey;

  if (isModifierKey) {
    return true;
  }

  const isSingleCharacterKey = event.key.length === 1;

  if (!isSingleCharacterKey) {
    return true;
  }

  return isFloatingPointNumericCharacter(event.key);
}

const sanitize = value => value.split("").filter(isFloatingPointNumericCharacter).join("");
/**
 * React hook that implements the WAI-ARIA Spin Button widget
 * and used to create numeric input fields.
 *
 * It returns prop getters you can use to build your own
 * custom number inputs.
 *
 * @see WAI-ARIA https://www.w3.org/TR/wai-aria-practices-1.1/#spinbutton
 * @see Docs     https://www.chakra-ui.com/useNumberInput
 * @see WHATWG   https://html.spec.whatwg.org/multipage/input.html#number-state-(type=number)
 */


function useNumberInput(props = {}) {
  const {
    focusInputOnChange = true,
    clampValueOnBlur = true,
    keepWithinRange = true,
    min = minSafeInteger,
    max = maxSafeInteger,
    step: stepProp = 1,
    isReadOnly,
    isDisabled,
    isRequired,
    getAriaValueText,
    isInvalid,
    pattern = "[0-9]*(.[0-9]+)?",
    inputMode = "decimal",
    allowMouseWheel,
    id,
    onChange: _,
    precision,
    name,
    "aria-describedby": ariaDescBy,
    "aria-label": ariaLabel,
    "aria-labelledby": ariaLabelledBy,
    onFocus,
    onBlur,
    ...htmlProps
  } = props;
  const onFocusProp = useCallbackRef(onFocus);
  const onBlurProp = useCallbackRef(onBlur);
  const getAriaValueTextProp = useCallbackRef(getAriaValueText);
  /**
   * Leverage the `useCounter` hook since it provides
   * the functionality to `increment`, `decrement` and `update`
   * counter values
   */

  const counter = useCounter(props);
  const {
    update: updateFn,
    increment: incrementFn,
    decrement: decrementFn
  } = counter;
  /**
   * Keep track of the focused state of the input,
   * so user can this to change the styles of the
   * `spinners`, maybe :)
   */

  const [isFocused, setFocused] = useBoolean();
  const inputRef = React.useRef(null);
  /**
   * Sync state with uncontrolled form libraries like `react-hook-form`.
   */

  useSafeLayoutEffect(() => {
    if (!inputRef.current) return;
    const notInSync = inputRef.current.value != counter.value;

    if (notInSync) {
      counter.setValue(sanitize(inputRef.current.value));
    }
  }, []);
  const isInteractive = !(isReadOnly || isDisabled);
  const increment = React.useCallback((step = stepProp) => {
    if (isInteractive) {
      incrementFn(step);
    }
  }, [incrementFn, isInteractive, stepProp]);
  const decrement = React.useCallback((step = stepProp) => {
    if (isInteractive) {
      decrementFn(step);
    }
  }, [decrementFn, isInteractive, stepProp]);
  /**
   * Leverage the `useSpinner` hook to spin the input's value
   * when long press on the up and down buttons.
   *
   * This leverages `setInterval` internally
   */

  const spinner = useSpinner(increment, decrement);
  /**
   * The `onChange` handler filters out any character typed
   * that isn't floating point compatible.
   */

  const onChange = React.useCallback(event => {
    updateFn(sanitize(event.target.value));
  }, [updateFn]);
  const onKeyDown = React.useCallback(event => {
    /**
     * only allow valid numeric keys
     */
    if (!isValidNumericKeyboardEvent(event)) {
      event.preventDefault();
    }
    /**
     * Keyboard Accessibility
     *
     * We want to increase or decrease the input's value
     * based on if the user the arrow keys.
     *
     * @see https://www.w3.org/TR/wai-aria-practices-1.1/#keyboard-interaction-17
     */


    const stepFactor = getStepFactor(event) * stepProp;
    const eventKey = normalizeEventKey(event);
    const keyMap = {
      ArrowUp: () => increment(stepFactor),
      ArrowDown: () => decrement(stepFactor),
      Home: () => updateFn(min),
      End: () => updateFn(max)
    };
    const action = keyMap[eventKey];

    if (action) {
      event.preventDefault();
      action(event);
    }
  }, [updateFn, decrement, increment, max, min, stepProp]);

  const getStepFactor = event => {
    let ratio = 1;

    if (event.metaKey || event.ctrlKey) {
      ratio = 0.1;
    }

    if (event.shiftKey) {
      ratio = 10;
    }

    return ratio;
  };
  /**
   * If user would like to use a human-readable representation
   * of the value, rather than the value itself they can pass `getAriaValueText`
   *
   * @see https://www.w3.org/TR/wai-aria-practices-1.1/#wai-aria-roles-states-and-properties-18
   * @see https://www.w3.org/TR/wai-aria-1.1/#aria-valuetext
   */


  const ariaValueText = React.useMemo(() => {
    const text = getAriaValueTextProp?.(counter.value);

    if (!isNull(text)) {
      return text;
    }

    const defaultText = counter.value.toString(); // empty string is an invalid ARIA attribute value

    return !defaultText ? undefined : defaultText;
  }, [counter.value, getAriaValueTextProp]);
  /**
   * Function that clamps the input's value on blur
   */

  const validateAndClamp = React.useCallback(() => {
    let next = counter.value;
    if (next === "") return;

    if (counter.valueAsNumber < min) {
      next = min;
    }

    if (counter.valueAsNumber > max) {
      next = max;
    }
    /**
     * `counter.cast` does 2 things:
     *
     * - sanitize the value by using parseFloat and some Regex
     * - used to round value to computed precision or decimal points
     */


    counter.cast(next);
  }, [counter, max, min]);
  const onInputBlur = React.useCallback(() => {
    setFocused.off();

    if (clampValueOnBlur) {
      validateAndClamp();
    }
  }, [clampValueOnBlur, setFocused, validateAndClamp]);
  const focusInput = React.useCallback(() => {
    if (focusInputOnChange) {
      focus(inputRef.current, {
        nextTick: true
      });
    }
  }, [focusInputOnChange]);
  const spinUp = React.useCallback(event => {
    event.preventDefault();
    spinner.up();
    focusInput();
  }, [focusInput, spinner]);
  const spinDown = React.useCallback(event => {
    event.preventDefault();
    spinner.down();
    focusInput();
  }, [focusInput, spinner]);
  const pointerDown = isBrowser && !!document.documentElement.ontouchstart ? "onTouchStart" : "onMouseDown";
  useEventListener("wheel", event => {
    const isInputFocused = document.activeElement === inputRef.current;
    if (!allowMouseWheel || !isInputFocused) return;
    event.preventDefault();
    const stepFactor = getStepFactor(event) * stepProp;
    const direction = Math.sign(event.deltaY);

    if (direction === -1) {
      increment(stepFactor);
    } else if (direction === 1) {
      decrement(stepFactor);
    }
  }, inputRef.current, {
    passive: false
  });
  const getIncrementButtonProps = React.useCallback((props = {}, ref = null) => {
    const disabled = isDisabled || keepWithinRange && counter.isAtMax;
    return { ...props,
      ref,
      role: "button",
      tabIndex: -1,
      [pointerDown]: callAllHandlers(props[pointerDown], spinUp),
      onMouseUp: callAllHandlers(props.onMouseUp, spinner.stop),
      onMouseLeave: callAllHandlers(props.onMouseUp, spinner.stop),
      onTouchEnd: callAllHandlers(props.onTouchEnd, spinner.stop),
      disabled,
      "aria-disabled": ariaAttr(disabled)
    };
  }, [pointerDown, counter.isAtMax, keepWithinRange, spinUp, spinner.stop, isDisabled]);
  const getDecrementButtonProps = React.useCallback((props = {}, ref = null) => {
    const disabled = isDisabled || keepWithinRange && counter.isAtMin;
    return { ...props,
      ref,
      role: "button",
      tabIndex: -1,
      [pointerDown]: callAllHandlers(props[pointerDown], spinDown),
      onMouseLeave: callAllHandlers(props.onMouseLeave, spinner.stop),
      onMouseUp: callAllHandlers(props.onMouseUp, spinner.stop),
      onTouchEnd: callAllHandlers(props.onTouchEnd, spinner.stop),
      disabled,
      "aria-disabled": ariaAttr(disabled)
    };
  }, [pointerDown, counter.isAtMin, keepWithinRange, spinDown, spinner.stop, isDisabled]);
  const getInputProps = React.useCallback((props = {}, ref = null) => ({
    name,
    inputMode,
    type: "text",
    pattern,
    "aria-labelledby": ariaLabelledBy,
    "aria-label": ariaLabel,
    "aria-describedby": ariaDescBy,
    id,
    disabled: isDisabled,
    ...props,
    readOnly: props.readOnly ?? isReadOnly,
    "aria-readonly": props.readOnly ?? isReadOnly,
    "aria-required": props.required ?? isRequired,
    required: props.required ?? isRequired,
    ref: mergeRefs(inputRef, ref),
    value: counter.value,
    role: "spinbutton",
    "aria-valuemin": min,
    "aria-valuemax": max,
    "aria-valuenow": Number.isNaN(counter.valueAsNumber) ? undefined : counter.valueAsNumber,
    "aria-invalid": ariaAttr(isInvalid ?? counter.isOutOfRange),
    "aria-valuetext": ariaValueText,
    autoComplete: "off",
    autoCorrect: "off",
    onChange: callAllHandlers(props.onChange, onChange),
    onKeyDown: callAllHandlers(props.onKeyDown, onKeyDown),
    onFocus: callAllHandlers(props.onFocus, onFocusProp, setFocused.on),
    onBlur: callAllHandlers(props.onBlur, onBlurProp, onInputBlur)
  }), [name, inputMode, pattern, ariaLabelledBy, ariaLabel, ariaDescBy, id, isDisabled, isRequired, isReadOnly, isInvalid, counter.value, counter.valueAsNumber, counter.isOutOfRange, min, max, ariaValueText, onChange, onKeyDown, onFocusProp, setFocused.on, onBlurProp, onInputBlur]);
  return {
    value: counter.value,
    valueAsNumber: counter.valueAsNumber,
    isFocused,
    isDisabled,
    isReadOnly,
    getIncrementButtonProps,
    getDecrementButtonProps,
    getInputProps,
    htmlProps
  };
}

/**
 * React context used to communicate between components
 */
const [NumberInputProvider, useNumberInputContext] = createContext({
  name: "NumberInputContext",
  errorMessage: "useNumberInputContext: `context` is undefined. Seems you forgot to wrap number-input's components within <NumberInput />"
});

/**
 * NumberInput
 *
 * React component that provides context and logic to all
 * number input sub-components.
 *
 * It renders a `div` by default.
 *
 * @see Docs http://chakra-ui.com/numberinput
 */
const NumberInput = /*#__PURE__*/forwardRef((props, ref) => {
  const styles = useMultiStyleConfig("NumberInput", props);
  const ownProps = omitThemingProps(props);
  const controlProps = useFormControlProps(ownProps);
  const {
    htmlProps,
    ...context
  } = useNumberInput(controlProps);
  const ctx = React.useMemo(() => context, [context]);
  return /*#__PURE__*/React.createElement(NumberInputProvider, {
    value: ctx
  }, /*#__PURE__*/React.createElement(StylesProvider, {
    value: styles
  }, /*#__PURE__*/React.createElement(chakra.div, _extends({}, htmlProps, {
    ref: ref,
    className: cx("chakra-numberinput", props.className),
    __css: {
      position: "relative",
      zIndex: 0,
      ...styles.root
    }
  }))));
});

if (__DEV__) {
  NumberInput.displayName = "NumberInput";
}

/**
 * NumberInputStepper
 *
 * React component used to group the increment and decrement
 * button spinners.
 *
 * It renders a `div` by default.
 *
 * @see Docs http://chakra-ui.com/components/number-input
 */
const NumberInputStepper = /*#__PURE__*/forwardRef((props, ref) => {
  const styles = useStyles();
  return /*#__PURE__*/React.createElement(chakra.div, _extends({
    "aria-hidden": true,
    ref: ref
  }, props, {
    __css: {
      display: "flex",
      flexDirection: "column",
      position: "absolute",
      top: "0",
      insetEnd: "0px",
      margin: "1px",
      height: "calc(100% - 2px)",
      zIndex: 1,
      ...styles.stepperGroup
    }
  }));
});

if (__DEV__) {
  NumberInputStepper.displayName = "NumberInputStepper";
}

/**
 * NumberInputField
 *
 * React component that represents the actual `input` field
 * where users can type to edit numeric values.
 *
 * It renders an `input` by default and ensures only numeric
 * values can be typed.
 *
 * @see Docs http://chakra-ui.com/numberinput
 */
const NumberInputField = /*#__PURE__*/forwardRef((props, ref) => {
  const {
    getInputProps
  } = useNumberInputContext();
  const input = getInputProps(props, ref);
  const styles = useStyles();
  return /*#__PURE__*/React.createElement(chakra.input, _extends({}, input, {
    className: cx("chakra-numberinput__field", props.className),
    __css: {
      width: "100%",
      ...styles.field
    }
  }));
});

if (__DEV__) {
  NumberInputField.displayName = "NumberInputField";
}

const StyledStepper = chakra("div", {
  baseStyle: {
    display: "flex",
    justifyContent: "center",
    alignItems: "center",
    flex: 1,
    transitionProperty: "common",
    transitionDuration: "normal",
    userSelect: "none",
    cursor: "pointer",
    lineHeight: "normal"
  }
});

/**
 * NumberDecrementStepper
 *
 * React component used to decrement the number input's value
 *
 * It renders a `div` with `role=button` by default
 */
const NumberDecrementStepper = /*#__PURE__*/forwardRef((props, ref) => {
  const styles = useStyles();
  const {
    getDecrementButtonProps
  } = useNumberInputContext();
  const decrement = getDecrementButtonProps(props, ref);
  return /*#__PURE__*/React.createElement(StyledStepper, _extends({}, decrement, {
    __css: styles.stepper
  }), props.children ?? /*#__PURE__*/React.createElement(TriangleDownIcon, null));
});

if (__DEV__) {
  NumberDecrementStepper.displayName = "NumberDecrementStepper";
}

/**
 * NumberIncrementStepper
 *
 * React component used to increment the number input's value
 *
 * It renders a `div` with `role=button` by default
 */
const NumberIncrementStepper = /*#__PURE__*/forwardRef((props, ref) => {
  const {
    getIncrementButtonProps
  } = useNumberInputContext();
  const increment = getIncrementButtonProps(props, ref);
  const styles = useStyles();
  return /*#__PURE__*/React.createElement(StyledStepper, _extends({}, increment, {
    __css: styles.stepper
  }), props.children ?? /*#__PURE__*/React.createElement(TriangleUpIcon, null));
});

if (__DEV__) {
  NumberIncrementStepper.displayName = "NumberIncrementStepper";
}

export { NumberDecrementStepper, NumberIncrementStepper, NumberInput, NumberInputField, NumberInputStepper, StyledStepper, useNumberInput };

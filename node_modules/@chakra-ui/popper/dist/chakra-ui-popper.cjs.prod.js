'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var reactUtils = require('@chakra-ui/react-utils');
var core = require('@popperjs/core');
var react = require('react');

const toVar = (value, fallback) => ({
  var: value,
  varRef: fallback ? `var(${value}, ${fallback})` : `var(${value})`
});

const cssVars = {
  arrowShadowColor: toVar("--popper-arrow-shadow-color"),
  arrowSize: toVar("--popper-arrow-size", "8px"),
  arrowSizeHalf: toVar("--popper-arrow-size-half"),
  arrowBg: toVar("--popper-arrow-bg"),
  transformOrigin: toVar("--popper-transform-origin"),
  arrowOffset: toVar("--popper-arrow-offset")
};
function getBoxShadow(placement) {
  if (placement.includes("top")) return `1px 1px 1px 0 var(--popper-arrow-shadow-color)`;
  if (placement.includes("bottom")) return `-1px -1px 1px 0 var(--popper-arrow-shadow-color)`;
  if (placement.includes("right")) return `-1px 1px 1px 0 var(--popper-arrow-shadow-color)`;
  if (placement.includes("left")) return `1px -1px 1px 0 var(--popper-arrow-shadow-color)`;
}
const transforms = {
  top: "bottom center",
  "top-start": "bottom left",
  "top-end": "bottom right",
  bottom: "top center",
  "bottom-start": "top left",
  "bottom-end": "top right",
  left: "right center",
  "left-start": "right top",
  "left-end": "right bottom",
  right: "left center",
  "right-start": "left top",
  "right-end": "left bottom"
};
const toTransformOrigin = placement => transforms[placement];
const defaultEventListeners = {
  scroll: true,
  resize: true
};
function getEventListenerOptions(value) {
  let eventListeners;

  if (typeof value === "object") {
    eventListeners = {
      enabled: true,
      options: { ...defaultEventListeners,
        ...value
      }
    };
  } else {
    eventListeners = {
      enabled: value,
      options: defaultEventListeners
    };
  }

  return eventListeners;
}

/* -------------------------------------------------------------------------------------------------
 The match width modifier sets the popper width to match the reference.
 It us useful for custom selects, autocomplete, etc.
* -----------------------------------------------------------------------------------------------*/

const matchWidth = {
  name: "matchWidth",
  enabled: true,
  phase: "beforeWrite",
  requires: ["computeStyles"],
  fn: ({
    state
  }) => {
    state.styles.popper.width = `${state.rects.reference.width}px`;
  },
  effect: ({
    state
  }) => () => {
    const reference = state.elements.reference;
    state.elements.popper.style.width = `${reference.offsetWidth}px`;
  }
};
/* -------------------------------------------------------------------------------------------------
  The transform origin modifier sets the css `transformOrigin` value of the popper
  based on the dynamic placement state of the popper.
  
  Useful when we need to animate/transition the popper.
* -----------------------------------------------------------------------------------------------*/

const transformOrigin = {
  name: "transformOrigin",
  enabled: true,
  phase: "write",
  fn: ({
    state
  }) => {
    setTransformOrigin(state);
  },
  effect: ({
    state
  }) => () => {
    setTransformOrigin(state);
  }
};

const setTransformOrigin = state => {
  state.elements.popper.style.setProperty(cssVars.transformOrigin.var, toTransformOrigin(state.placement));
};
/* -------------------------------------------------------------------------------------------------
  The position arrow modifier adds width, height and overrides the `top/left/right/bottom`
  styles generated by popper.js to properly position the arrow
* -----------------------------------------------------------------------------------------------*/


const positionArrow = {
  name: "positionArrow",
  enabled: true,
  phase: "afterWrite",
  fn: ({
    state
  }) => {
    setArrowStyles(state);
  }
};

const setArrowStyles = state => {
  if (!state.placement) return;
  const overrides = getArrowStyle$1(state.placement);

  if (state.elements?.arrow && overrides) {
    Object.assign(state.elements.arrow.style, {
      [overrides.property]: overrides.value,
      width: cssVars.arrowSize.varRef,
      height: cssVars.arrowSize.varRef,
      zIndex: -1
    });
    const vars = {
      [cssVars.arrowSizeHalf.var]: `calc(${cssVars.arrowSize.varRef} / 2)`,
      [cssVars.arrowOffset.var]: `calc(${cssVars.arrowSizeHalf.varRef} * -1)`
    };

    for (const property in vars) {
      state.elements.arrow.style.setProperty(property, vars[property]);
    }
  }
};

const getArrowStyle$1 = placement => {
  if (placement.startsWith("top")) {
    return {
      property: "bottom",
      value: cssVars.arrowOffset.varRef
    };
  }

  if (placement.startsWith("bottom")) {
    return {
      property: "top",
      value: cssVars.arrowOffset.varRef
    };
  }

  if (placement.startsWith("left")) {
    return {
      property: "right",
      value: cssVars.arrowOffset.varRef
    };
  }

  if (placement.startsWith("right")) {
    return {
      property: "left",
      value: cssVars.arrowOffset.varRef
    };
  }
};
/* -------------------------------------------------------------------------------------------------
  The inner arrow modifier, sets the placement styles for the inner arrow that forms
  the popper arrow tip.
* -----------------------------------------------------------------------------------------------*/


const innerArrow = {
  name: "innerArrow",
  enabled: true,
  phase: "main",
  requires: ["arrow"],
  fn: ({
    state
  }) => {
    setInnerArrowStyles(state);
  },
  effect: ({
    state
  }) => () => {
    setInnerArrowStyles(state);
  }
};

const setInnerArrowStyles = state => {
  if (!state.elements.arrow) return;
  const inner = state.elements.arrow.querySelector("[data-popper-arrow-inner]");
  if (!inner) return;
  Object.assign(inner.style, {
    transform: "rotate(45deg)",
    background: cssVars.arrowBg.varRef,
    top: 0,
    left: 0,
    width: "100%",
    height: "100%",
    position: "absolute",
    zIndex: "inherit",
    boxShadow: getBoxShadow(state.placement)
  });
};

const logicals = {
  "start-start": {
    ltr: "left-start",
    rtl: "right-start"
  },
  "start-end": {
    ltr: "left-end",
    rtl: "right-end"
  },
  "end-start": {
    ltr: "right-start",
    rtl: "left-start"
  },
  "end-end": {
    ltr: "right-end",
    rtl: "left-end"
  },
  start: {
    ltr: "left",
    rtl: "right"
  },
  end: {
    ltr: "right",
    rtl: "left"
  }
};
const opposites = {
  "auto-start": "auto-end",
  "auto-end": "auto-start",
  "top-start": "top-end",
  "top-end": "top-start",
  "bottom-start": "bottom-end",
  "bottom-end": "bottom-start"
};
function getPopperPlacement(placement, dir = "ltr") {
  const value = logicals[placement]?.[dir] || placement;
  if (dir === "ltr") return value;
  return opposites[placement] ?? value;
}

function usePopper(props = {}) {
  const {
    enabled = true,
    modifiers,
    placement: placementProp = "bottom",
    strategy = "absolute",
    arrowPadding = 8,
    eventListeners = true,
    offset,
    gutter = 8,
    flip = true,
    boundary = "clippingParents",
    preventOverflow = true,
    matchWidth: matchWidth$1,
    direction = "ltr"
  } = props;
  const reference = react.useRef(null);
  const popper = react.useRef(null);
  const instance = react.useRef(null);
  const placement = getPopperPlacement(placementProp, direction);
  const cleanup = react.useRef(() => {});
  const setupPopper = react.useCallback(() => {
    if (!enabled || !reference.current || !popper.current) return; // If popper instance exists, destroy it so we can create a new one

    cleanup.current?.();
    instance.current = core.createPopper(reference.current, popper.current, {
      placement,
      modifiers: [innerArrow, positionArrow, transformOrigin, { ...matchWidth,
        enabled: !!matchWidth$1
      }, {
        name: "eventListeners",
        ...getEventListenerOptions(eventListeners)
      }, {
        name: "arrow",
        options: {
          padding: arrowPadding
        }
      }, {
        name: "offset",
        options: {
          offset: offset ?? [0, gutter]
        }
      }, {
        name: "flip",
        enabled: !!flip,
        options: {
          padding: 8
        }
      }, {
        name: "preventOverflow",
        enabled: !!preventOverflow,
        options: {
          boundary
        }
      }, // allow users override internal modifiers
      ...(modifiers ?? [])],
      strategy
    }); // force update one-time to fix any positioning issues

    instance.current.forceUpdate();
    cleanup.current = instance.current.destroy;
  }, [placement, enabled, modifiers, matchWidth$1, eventListeners, arrowPadding, offset, gutter, flip, preventOverflow, boundary, strategy]);
  react.useEffect(() => {
    return () => {
      /**
       * Fast refresh might call this function and tear down the popper
       * even if the reference still exists. This checks against that
       */
      if (!reference.current && !popper.current) {
        instance.current?.destroy();
        instance.current = null;
      }
    };
  }, []);
  const referenceRef = react.useCallback(node => {
    reference.current = node;
    setupPopper();
  }, [setupPopper]);
  const getReferenceProps = react.useCallback((props = {}, ref = null) => ({ ...props,
    ref: reactUtils.mergeRefs(referenceRef, ref)
  }), [referenceRef]);
  const popperRef = react.useCallback(node => {
    popper.current = node;
    setupPopper();
  }, [setupPopper]);
  const getPopperProps = react.useCallback((props = {}, ref = null) => ({ ...props,
    ref: reactUtils.mergeRefs(popperRef, ref),
    style: { ...props.style,
      position: strategy,
      minWidth: "max-content",
      inset: "0 auto auto 0"
    }
  }), [strategy, popperRef]);
  const getArrowProps = react.useCallback((props = {}, ref = null) => {
    const {
      size,
      shadowColor,
      bg,
      style,
      ...rest
    } = props;
    return { ...rest,
      ref,
      "data-popper-arrow": "",
      style: getArrowStyle(props)
    };
  }, []);
  const getArrowInnerProps = react.useCallback((props = {}, ref = null) => ({ ...props,
    ref,
    "data-popper-arrow-inner": ""
  }), []);
  return {
    update() {
      instance.current?.update();
    },

    forceUpdate() {
      instance.current?.forceUpdate();
    },

    transformOrigin: cssVars.transformOrigin.varRef,
    referenceRef,
    popperRef,
    getPopperProps,
    getArrowProps,
    getArrowInnerProps,
    getReferenceProps
  };
}

function getArrowStyle(props) {
  const {
    size,
    shadowColor,
    bg,
    style
  } = props;
  const computedStyle = { ...style,
    position: "absolute"
  };

  if (size) {
    computedStyle["--popper-arrow-size"] = size;
  }

  if (shadowColor) {
    computedStyle["--popper-arrow-shadow-color"] = shadowColor;
  }

  if (bg) {
    computedStyle["--popper-arrow-bg"] = bg;
  }

  return computedStyle;
}

exports.popperCSSVars = cssVars;
exports.usePopper = usePopper;

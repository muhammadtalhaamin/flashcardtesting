import { isInputEvent, addItem, removeItem, __DEV__, warn, dataAttr, callAllHandlers, focus, callAll, cx } from '@chakra-ui/utils';
import { createContext, mergeRefs } from '@chakra-ui/react-utils';
import * as React from 'react';
import { useCallback, useRef, useState } from 'react';
import { useCallbackRef, useControllableState, useBoolean, useControllableProp, useSafeLayoutEffect } from '@chakra-ui/hooks';
import { chakra, forwardRef, useMultiStyleConfig, omitThemingProps } from '@chakra-ui/system';
import { motion, AnimatePresence } from 'framer-motion';
import { visuallyHiddenStyle } from '@chakra-ui/visually-hidden';

/**
 * React hook that provides all the state management logic
 * for a group of checkboxes.
 *
 * It is consumed by the `CheckboxGroup` component
 */
function useCheckboxGroup(props = {}) {
  const {
    defaultValue,
    value: valueProp,
    onChange,
    isDisabled,
    isNative
  } = props;
  const onChangeProp = useCallbackRef(onChange);
  const [value, setValue] = useControllableState({
    value: valueProp,
    defaultValue: defaultValue || [],
    onChange: onChangeProp
  });
  const handleChange = useCallback(eventOrValue => {
    if (!value) return;
    const isChecked = isInputEvent(eventOrValue) ? eventOrValue.target.checked : !value.includes(eventOrValue);
    const selectedValue = isInputEvent(eventOrValue) ? eventOrValue.target.value : eventOrValue;
    const nextValue = isChecked ? addItem(value, selectedValue) : removeItem(value, selectedValue);
    setValue(nextValue);
  }, [setValue, value]);
  const getCheckboxProps = useCallback((props = {}) => {
    const checkedKey = isNative ? "checked" : "isChecked";
    return { ...props,
      [checkedKey]: value.includes(props.value),
      onChange: handleChange
    };
  }, [handleChange, isNative, value]);
  return {
    value,
    isDisabled,
    onChange: handleChange,
    setValue,
    getCheckboxProps
  };
}

const [CheckboxGroupProvider, useCheckboxGroupContext] = createContext({
  name: "CheckboxGroupContext",
  strict: false
});
/**
 * Used for multiple checkboxes which are bound in one group,
 * and it indicates whether one or more options are selected.
 *
 * @see Docs https://chakra-ui.com/checkbox
 */

const CheckboxGroup = props => {
  const {
    colorScheme,
    size,
    variant,
    children,
    isDisabled
  } = props;
  const {
    value,
    onChange
  } = useCheckboxGroup(props);
  const group = React.useMemo(() => ({
    size,
    onChange,
    colorScheme,
    value,
    variant,
    isDisabled
  }), [size, onChange, colorScheme, value, variant, isDisabled]);
  return /*#__PURE__*/React.createElement(CheckboxGroupProvider, {
    value: group
  }, children);
};

if (__DEV__) {
  CheckboxGroup.displayName = "CheckboxGroup";
}

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

const MotionSvg = "custom" in motion ? motion.custom(chakra.svg) : motion(chakra.svg);

const CheckIcon = props => /*#__PURE__*/React.createElement(MotionSvg, _extends({
  width: "1.2em",
  viewBox: "0 0 12 10",
  variants: {
    unchecked: {
      opacity: 0,
      strokeDashoffset: 16
    },
    checked: {
      opacity: 1,
      strokeDashoffset: 0,
      transition: {
        duration: 0.2
      }
    }
  },
  style: {
    fill: "none",
    strokeWidth: 2,
    stroke: "currentColor",
    strokeDasharray: 16
  }
}, props), /*#__PURE__*/React.createElement("polyline", {
  points: "1.5 6 4.5 9 10.5 1"
}));

const IndeterminateIcon = props => /*#__PURE__*/React.createElement(MotionSvg, _extends({
  width: "1.2em",
  viewBox: "0 0 24 24",
  variants: {
    unchecked: {
      scaleX: 0.65,
      opacity: 0
    },
    checked: {
      scaleX: 1,
      opacity: 1,
      transition: {
        scaleX: {
          duration: 0
        },
        opacity: {
          duration: 0.02
        }
      }
    }
  },
  style: {
    stroke: "currentColor",
    strokeWidth: 4
  }
}, props), /*#__PURE__*/React.createElement("line", {
  x1: "21",
  x2: "3",
  y1: "12",
  y2: "12"
}));

const CheckboxTransition = ({
  open,
  children
}) => /*#__PURE__*/React.createElement(AnimatePresence, {
  initial: false
}, open && /*#__PURE__*/React.createElement(motion.div, {
  variants: {
    unchecked: {
      scale: 0.5
    },
    checked: {
      scale: 1
    }
  },
  initial: "unchecked",
  animate: "checked",
  exit: "unchecked",
  style: {
    display: "flex",
    alignItems: "center",
    justifyContent: "center",
    height: "100%"
  }
}, children));

/**
 * CheckboxIcon is used to visually indicate the checked or indeterminate
 * state of a checkbox.
 *
 * @todo allow users pass their own icon svgs
 */
const CheckboxIcon = props => {
  const {
    isIndeterminate,
    isChecked,
    ...rest
  } = props;
  const IconEl = isIndeterminate ? IndeterminateIcon : CheckIcon;
  return /*#__PURE__*/React.createElement(CheckboxTransition, {
    open: isChecked || isIndeterminate
  }, /*#__PURE__*/React.createElement(IconEl, rest));
};

/**
 * useCheckbox that provides all the state and focus management logic
 * for a checkbox. It is consumed by the `Checkbox` component
 *
 * @see Docs https://chakra-ui.com/checkbox#hooks
 */
function useCheckbox(props = {}) {
  const {
    defaultIsChecked,
    defaultChecked = defaultIsChecked,
    isChecked: checkedProp,
    isFocusable,
    isDisabled,
    isReadOnly,
    isRequired,
    onChange,
    isIndeterminate,
    isInvalid,
    name,
    value,
    id,
    onBlur,
    onFocus,
    tabIndex = undefined,
    "aria-label": ariaLabel,
    "aria-labelledby": ariaLabelledBy,
    "aria-invalid": ariaInvalid,
    "aria-describedby": ariaDescribedBy,
    ...htmlProps
  } = props;
  const onChangeProp = useCallbackRef(onChange);
  const onBlurProp = useCallbackRef(onBlur);
  const onFocusProp = useCallbackRef(onFocus);
  const [isFocused, setFocused] = useBoolean();
  const [isHovered, setHovered] = useBoolean();
  const [isActive, setActive] = useBoolean();
  const inputRef = useRef(null);
  const [rootIsLabelElement, setRootIsLabelElement] = useState(true);
  const [checkedState, setCheckedState] = useState(!!defaultChecked);
  const [isControlled, isChecked] = useControllableProp(checkedProp, checkedState);
  warn({
    condition: !!defaultIsChecked,
    message: 'The "defaultIsChecked" prop has been deprecated and will be removed in a future version. ' + 'Please use the "defaultChecked" prop instead, which mirrors default React checkbox behavior.'
  });
  const handleChange = useCallback(event => {
    if (isReadOnly || isDisabled) {
      event.preventDefault();
      return;
    }

    if (!isControlled) {
      if (isChecked) {
        setCheckedState(event.target.checked);
      } else {
        setCheckedState(isIndeterminate ? true : event.target.checked);
      }
    }

    onChangeProp?.(event);
  }, [isReadOnly, isDisabled, isChecked, isControlled, isIndeterminate, onChangeProp]);
  useSafeLayoutEffect(() => {
    if (inputRef.current) {
      inputRef.current.indeterminate = Boolean(isIndeterminate);
    }
  }, [isIndeterminate]);
  const trulyDisabled = isDisabled && !isFocusable;
  const onKeyDown = useCallback(event => {
    if (event.key === " ") {
      setActive.on();
    }
  }, [setActive]);
  const onKeyUp = useCallback(event => {
    if (event.key === " ") {
      setActive.off();
    }
  }, [setActive]);
  /**
   * Sync state with uncontrolled form libraries like `react-hook-form`.
   *
   * These libraries set the checked value for input fields
   * using their refs. For the checkbox, it sets `ref.current.checked = true | false` directly.
   *
   * This means the `isChecked` state will get out of sync with `ref.current.checked`,
   * even though the input validation with work, the UI will not be up to date.
   *
   * Let's correct that by checking and syncing the state accordingly.
   */

  useSafeLayoutEffect(() => {
    if (!inputRef.current) return;
    const notInSync = inputRef.current.checked !== isChecked;

    if (notInSync) {
      setCheckedState(inputRef.current.checked);
    }
  }, [inputRef.current]);
  const getCheckboxProps = useCallback((props = {}, forwardedRef = null) => {
    const onPressDown = event => {
      // On mousedown, the input blurs and returns focus to the `body`,
      // we need to prevent this. Native checkboxes keeps focus on `input`
      event.preventDefault();
      setActive.on();
    };

    return { ...props,
      ref: forwardedRef,
      "data-active": dataAttr(isActive),
      "data-hover": dataAttr(isHovered),
      "data-checked": dataAttr(isChecked),
      "data-focus": dataAttr(isFocused),
      "data-indeterminate": dataAttr(isIndeterminate),
      "data-disabled": dataAttr(isDisabled),
      "data-invalid": dataAttr(isInvalid),
      "data-readonly": dataAttr(isReadOnly),
      "aria-hidden": true,
      onMouseDown: callAllHandlers(props.onMouseDown, onPressDown),
      onMouseUp: callAllHandlers(props.onMouseUp, setActive.off),
      onMouseEnter: callAllHandlers(props.onMouseEnter, setHovered.on),
      onMouseLeave: callAllHandlers(props.onMouseLeave, setHovered.off)
    };
  }, [isActive, isChecked, isDisabled, isFocused, isHovered, isIndeterminate, isInvalid, isReadOnly, setActive, setHovered.off, setHovered.on]);
  const getRootProps = useCallback((props = {}, forwardedRef = null) => ({ ...htmlProps,
    ...props,
    ref: mergeRefs(forwardedRef, node => {
      if (!node) return;
      setRootIsLabelElement(node.tagName === "LABEL");
    }),
    onClick: callAllHandlers(props.onClick, () => {
      /**
       * Accessibility:
       *
       * Ideally, `getRootProps` should be spread unto a `label` element.
       *
       * If the element was changed using the `as` prop or changing
       * the dom node `getRootProps` is spread unto (to a `div` or `span`), we'll trigger
       * click on the input when the element is clicked.
       * @see Issue https://github.com/chakra-ui/chakra-ui/issues/3480
       */
      if (!rootIsLabelElement) {
        inputRef.current?.click();
        focus(inputRef.current, {
          nextTick: true
        });
      }
    }),
    "data-disabled": dataAttr(isDisabled),
    "data-checked": dataAttr(isChecked),
    "data-invalid": dataAttr(isInvalid)
  }), [htmlProps, isDisabled, isChecked, isInvalid, rootIsLabelElement]);
  const getInputProps = useCallback((props = {}, forwardedRef = null) => {
    return { ...props,
      ref: mergeRefs(inputRef, forwardedRef),
      type: "checkbox",
      name,
      value,
      id,
      tabIndex,
      onChange: callAllHandlers(props.onChange, handleChange),
      onBlur: callAllHandlers(props.onBlur, onBlurProp, setFocused.off),
      onFocus: callAllHandlers(props.onFocus, onFocusProp, setFocused.on),
      onKeyDown: callAllHandlers(props.onKeyDown, onKeyDown),
      onKeyUp: callAllHandlers(props.onKeyUp, onKeyUp),
      required: isRequired,
      checked: isChecked,
      disabled: trulyDisabled,
      readOnly: isReadOnly,
      "aria-label": ariaLabel,
      "aria-labelledby": ariaLabelledBy,
      "aria-invalid": ariaInvalid ? Boolean(ariaInvalid) : isInvalid,
      "aria-describedby": ariaDescribedBy,
      "aria-disabled": isDisabled,
      style: visuallyHiddenStyle
    };
  }, [name, value, id, handleChange, setFocused.off, setFocused.on, onBlurProp, onFocusProp, onKeyDown, onKeyUp, isRequired, isChecked, trulyDisabled, isReadOnly, ariaLabel, ariaLabelledBy, ariaInvalid, isInvalid, ariaDescribedBy, isDisabled, tabIndex]);
  const getLabelProps = useCallback((props = {}, forwardedRef = null) => ({ ...props,
    ref: forwardedRef,
    onMouseDown: callAllHandlers(props.onMouseDown, stopEvent),
    onTouchStart: callAllHandlers(props.onTouchStart, stopEvent),
    "data-disabled": dataAttr(isDisabled),
    "data-checked": dataAttr(isChecked),
    "data-invalid": dataAttr(isInvalid)
  }), [isChecked, isDisabled, isInvalid]);
  return {
    state: {
      isInvalid,
      isFocused,
      isChecked,
      isActive,
      isHovered,
      isIndeterminate,
      isDisabled,
      isReadOnly,
      isRequired
    },
    getRootProps,
    getCheckboxProps,
    getInputProps,
    getLabelProps,
    htmlProps
  };
}
/**
 * Prevent `onBlur` being fired when the checkbox label is touched
 */

function stopEvent(event) {
  event.preventDefault();
  event.stopPropagation();
}

const CheckboxControl = chakra("span", {
  baseStyle: {
    display: "inline-flex",
    alignItems: "center",
    justifyContent: "center",
    verticalAlign: "top",
    userSelect: "none",
    flexShrink: 0
  }
});
const Label = chakra("label", {
  baseStyle: {
    cursor: "pointer",
    display: "inline-flex",
    alignItems: "center",
    verticalAlign: "top",
    position: "relative",
    _disabled: {
      cursor: "not-allowed"
    }
  }
});

/**
 * Checkbox
 *
 * React component used in forms when a user needs to select
 * multiple values from several options.
 *
 * @see Docs https://chakra-ui.com/checkbox
 */
const Checkbox = /*#__PURE__*/forwardRef((props, ref) => {
  const group = useCheckboxGroupContext();
  const mergedProps = { ...group,
    ...props
  };
  const styles = useMultiStyleConfig("Checkbox", mergedProps);
  const ownProps = omitThemingProps(props);
  const {
    spacing = "0.5rem",
    className,
    children,
    iconColor,
    iconSize,
    icon = /*#__PURE__*/React.createElement(CheckboxIcon, null),
    isChecked: isCheckedProp,
    isDisabled = group?.isDisabled,
    onChange: onChangeProp,
    ...rest
  } = ownProps;
  let isChecked = isCheckedProp;

  if (group?.value && ownProps.value) {
    isChecked = group.value.includes(ownProps.value);
  }

  let onChange = onChangeProp;

  if (group?.onChange && ownProps.value) {
    onChange = callAll(group.onChange, onChangeProp);
  }

  const {
    state,
    getInputProps,
    getCheckboxProps,
    getLabelProps,
    getRootProps
  } = useCheckbox({ ...rest,
    isDisabled,
    isChecked,
    onChange
  });
  const iconStyles = React.useMemo(() => ({
    opacity: state.isChecked || state.isIndeterminate ? 1 : 0,
    transform: state.isChecked || state.isIndeterminate ? "scale(1)" : "scale(0.95)",
    fontSize: iconSize,
    color: iconColor,
    ...styles.icon
  }), [iconColor, iconSize, state.isChecked, state.isIndeterminate, styles.icon]);
  const clonedIcon = /*#__PURE__*/React.cloneElement(icon, {
    __css: iconStyles,
    isIndeterminate: state.isIndeterminate,
    isChecked: state.isChecked
  });
  return /*#__PURE__*/React.createElement(Label, _extends({
    __css: styles.container,
    className: cx("chakra-checkbox", className)
  }, getRootProps()), /*#__PURE__*/React.createElement("input", _extends({
    className: "chakra-checkbox__input"
  }, getInputProps({}, ref))), /*#__PURE__*/React.createElement(CheckboxControl, _extends({
    __css: styles.control,
    className: "chakra-checkbox__control"
  }, getCheckboxProps()), clonedIcon), children && /*#__PURE__*/React.createElement(chakra.span, _extends({
    className: "chakra-checkbox__label"
  }, getLabelProps(), {
    __css: {
      marginStart: spacing,
      ...styles.label
    }
  }), children));
});

if (__DEV__) {
  Checkbox.displayName = "Checkbox";
}

export { Checkbox, CheckboxGroup, useCheckbox, useCheckboxGroup, useCheckboxGroupContext };

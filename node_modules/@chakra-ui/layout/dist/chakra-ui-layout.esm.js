import { forwardRef, chakra, useStyleConfig, omitThemingProps, useMultiStyleConfig, StylesProvider, useStyles, tokenToCSSVar } from '@chakra-ui/system';
import { cx, mapResponsive, __DEV__, filterUndefined, isNull, isNumber } from '@chakra-ui/utils';
import * as React from 'react';
import { Icon } from '@chakra-ui/icon';
import { getValidChildren } from '@chakra-ui/react-utils';

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

/**
 * React component used to cropping media (videos, images and maps)
 * to a desired aspect ratio.
 *
 * @see Docs https://chakra-ui.com/aspectratiobox
 */
const AspectRatio = /*#__PURE__*/forwardRef((props, ref) => {
  const {
    ratio = 4 / 3,
    children,
    className,
    ...rest
  } = props; // enforce single child

  const child = React.Children.only(children);

  const _className = cx("chakra-aspect-ratio", className);

  return /*#__PURE__*/React.createElement(chakra.div, _extends({
    ref: ref,
    position: "relative",
    className: _className,
    _before: {
      height: 0,
      content: `""`,
      display: "block",
      paddingBottom: mapResponsive(ratio, r => `${1 / r * 100}%`)
    },
    __css: {
      "& > *:not(style)": {
        overflow: "hidden",
        position: "absolute",
        top: "0",
        right: "0",
        bottom: "0",
        left: "0",
        display: "flex",
        justifyContent: "center",
        alignItems: "center",
        width: "100%",
        height: "100%"
      },
      "& > img, & > video": {
        objectFit: "cover"
      }
    }
  }, rest), child);
});

if (__DEV__) {
  AspectRatio.displayName = "AspectRatio";
}

/**
 * React component used to display notifications, messages, or
 * statuses in different shapes and sizes.
 *
 * @see Docs https://chakra-ui.com/badge
 */
const Badge = /*#__PURE__*/forwardRef((props, ref) => {
  const styles = useStyleConfig("Badge", props);
  const {
    className,
    ...rest
  } = omitThemingProps(props);
  return /*#__PURE__*/React.createElement(chakra.span, _extends({
    ref: ref,
    className: cx("chakra-badge", props.className)
  }, rest, {
    __css: {
      display: "inline-block",
      whiteSpace: "nowrap",
      verticalAlign: "middle",
      ...styles
    }
  }));
});

if (__DEV__) {
  Badge.displayName = "Badge";
}

/**
 * Box is the most abstract component on top of which other chakra
 * components are built. It renders a `div` element by default.
 *
 * @see Docs https://chakra-ui.com/box
 */
const Box = chakra("div");

if (__DEV__) {
  Box.displayName = "Box";
}
/**
 * As a constraint, you can't pass size related props
 * Only `size` would be allowed
 */


const Square = /*#__PURE__*/forwardRef((props, ref) => {
  const {
    size,
    centerContent = true,
    ...rest
  } = props;
  const styles = centerContent ? {
    display: "flex",
    alignItems: "center",
    justifyContent: "center"
  } : {};
  return /*#__PURE__*/React.createElement(Box, _extends({
    ref: ref,
    boxSize: size,
    __css: { ...styles,
      flexShrink: 0,
      flexGrow: 0
    }
  }, rest));
});

if (__DEV__) {
  Square.displayName = "Square";
}

const Circle = /*#__PURE__*/forwardRef((props, ref) => {
  const {
    size,
    ...rest
  } = props;
  return /*#__PURE__*/React.createElement(Square, _extends({
    size: size,
    ref: ref,
    borderRadius: "9999px"
  }, rest));
});

if (__DEV__) {
  Circle.displayName = "Circle";
}

/**
 * React component used to horizontally and vertically center its child.
 * It uses the popular `display: flex` centering technique.
 *
 * @see Docs https://chakra-ui.com/center
 */
const Center = chakra("div", {
  baseStyle: {
    display: "flex",
    alignItems: "center",
    justifyContent: "center"
  }
});

if (__DEV__) {
  Center.displayName = "Center";
}

const centerStyles = {
  horizontal: {
    insetStart: "50%",
    transform: "translateX(-50%)"
  },
  vertical: {
    top: "50%",
    transform: "translateY(-50%)"
  },
  both: {
    insetStart: "50%",
    top: "50%",
    transform: "translate(-50%, -50%)"
  }
};
/**
 * React component used to horizontally and vertically center an element
 * relative to its parent dimensions.
 *
 * It uses the `position: absolute` strategy.
 *
 * @see Docs https://chakra-ui.com/center
 * @see WebDev https://web.dev/centering-in-css/#5.-pop-and-plop
 */

const AbsoluteCenter = /*#__PURE__*/forwardRef((props, ref) => {
  const {
    axis = "both",
    ...rest
  } = props;
  return /*#__PURE__*/React.createElement(chakra.div, _extends({
    ref: ref,
    __css: centerStyles[axis]
  }, rest, {
    position: "absolute"
  }));
});

/**
 * React component to render inline code snippets.
 *
 * @see Docs https://chakra-ui.com/code
 */
const Code = /*#__PURE__*/forwardRef((props, ref) => {
  const styles = useStyleConfig("Code", props);
  const {
    className,
    ...rest
  } = omitThemingProps(props);
  return /*#__PURE__*/React.createElement(chakra.code, _extends({
    ref: ref,
    className: cx("chakra-code", props.className)
  }, rest, {
    __css: {
      display: "inline-block",
      ...styles
    }
  }));
});

if (__DEV__) {
  Code.displayName = "Code";
}

/**
 * Layout component used to wrap app or website content
 *
 * It sets `margin-left` and `margin-right` to `auto`,
 * to keep its content centered.
 *
 * It also sets a default max-width of `60ch` (60 characters).
 */
const Container = /*#__PURE__*/forwardRef((props, ref) => {
  const {
    className,
    centerContent,
    ...rest
  } = omitThemingProps(props);
  const styles = useStyleConfig("Container", props);
  return /*#__PURE__*/React.createElement(chakra.div, _extends({
    ref: ref,
    className: cx("chakra-container", className)
  }, rest, {
    __css: { ...styles,
      ...(centerContent && {
        display: "flex",
        flexDirection: "column",
        alignItems: "center"
      })
    }
  }));
});

if (__DEV__) {
  Container.displayName = "Container";
}

/**
 * Layout component used to visually separate content in a list or group.
 * It display a thin horizontal or vertical line, and renders a `hr` tag.
 *
 * @see Docs https://chakra-ui.com/divider
 */

const Divider = /*#__PURE__*/forwardRef((props, ref) => {
  const {
    borderLeftWidth,
    borderBottomWidth,
    borderTopWidth,
    borderRightWidth,
    borderWidth,
    borderStyle,
    borderColor,
    ...styles
  } = useStyleConfig("Divider", props);
  const {
    className,
    orientation = "horizontal",
    __css,
    ...rest
  } = omitThemingProps(props);
  const dividerStyles = {
    vertical: {
      borderLeftWidth: borderLeftWidth || borderRightWidth || borderWidth || "1px",
      height: "100%"
    },
    horizontal: {
      borderBottomWidth: borderBottomWidth || borderTopWidth || borderWidth || "1px",
      width: "100%"
    }
  };
  return /*#__PURE__*/React.createElement(chakra.hr, _extends({
    ref: ref,
    "aria-orientation": orientation
  }, rest, {
    __css: { ...styles,
      border: "0",
      borderColor,
      borderStyle,
      ...dividerStyles[orientation],
      ...__css
    },
    className: cx("chakra-divider", className)
  }));
});

if (__DEV__) {
  Divider.displayName = "Divider";
}

/**
 * React component used to create flexbox layouts.
 *
 * It renders a `div` with `display: flex` and
 * comes with helpful style shorthand.
 *
 * @see Docs https://chakra-ui.com/flex
 */
const Flex = /*#__PURE__*/forwardRef((props, ref) => {
  const {
    direction,
    align,
    justify,
    wrap,
    basis,
    grow,
    shrink,
    ...rest
  } = props;
  const styles = {
    display: "flex",
    flexDirection: direction,
    alignItems: align,
    justifyContent: justify,
    flexWrap: wrap,
    flexBasis: basis,
    flexGrow: grow,
    flexShrink: shrink
  };
  return /*#__PURE__*/React.createElement(chakra.div, _extends({
    ref: ref,
    __css: styles
  }, rest));
});

if (__DEV__) {
  Flex.displayName = "Flex";
}

/**
 * React component used to create grid layouts.
 *
 * It renders a `div` with `display: grid` and
 * comes with helpful style shorthand.
 *
 * @see Docs https://chakra-ui.com/grid
 */
const Grid = /*#__PURE__*/forwardRef((props, ref) => {
  const {
    area,
    templateAreas,
    gap,
    rowGap,
    columnGap,
    column,
    row,
    autoFlow,
    autoRows,
    templateRows,
    autoColumns,
    templateColumns,
    ...rest
  } = props;
  const styles = {
    display: "grid",
    gridArea: area,
    gridTemplateAreas: templateAreas,
    gridGap: gap,
    gridRowGap: rowGap,
    gridColumnGap: columnGap,
    gridAutoColumns: autoColumns,
    gridColumn: column,
    gridRow: row,
    gridAutoFlow: autoFlow,
    gridAutoRows: autoRows,
    gridTemplateRows: templateRows,
    gridTemplateColumns: templateColumns
  };
  return /*#__PURE__*/React.createElement(chakra.div, _extends({
    ref: ref,
    __css: styles
  }, rest));
});

if (__DEV__) {
  Grid.displayName = "Grid";
}

function spanFn(span) {
  return mapResponsive(span, value => value === "auto" ? "auto" : `span ${value}/span ${value}`);
}

const GridItem = /*#__PURE__*/forwardRef((props, ref) => {
  const {
    colSpan,
    colStart,
    colEnd,
    rowEnd,
    rowSpan,
    rowStart,
    ...rest
  } = props;
  const styles = filterUndefined({
    gridColumn: spanFn(colSpan),
    gridRow: spanFn(rowSpan),
    gridColumnStart: colStart,
    gridColumnEnd: colEnd,
    gridRowStart: rowStart,
    gridRowEnd: rowEnd
  });
  return /*#__PURE__*/React.createElement(chakra.div, _extends({
    ref: ref,
    __css: styles
  }, rest));
});

const Heading = /*#__PURE__*/forwardRef((props, ref) => {
  const styles = useStyleConfig("Heading", props);
  const {
    className,
    ...rest
  } = omitThemingProps(props);
  return /*#__PURE__*/React.createElement(chakra.h2, _extends({
    ref: ref,
    className: cx("chakra-heading", props.className)
  }, rest, {
    __css: styles
  }));
});

if (__DEV__) {
  Heading.displayName = "Heading";
}

/**
 * Semantic component to render a keyboard shortcut
 * within an application.
 *
 * @example
 *
 * ```jsx
 * <Kbd>⌘ + T</Kbd>
 * ```
 *
 * @see Docs https://chakra-ui.com/kbd
 */
const Kbd = /*#__PURE__*/forwardRef((props, ref) => {
  const styles = useStyleConfig("Kbd", props);
  const {
    className,
    ...rest
  } = omitThemingProps(props);
  return /*#__PURE__*/React.createElement(chakra.kbd, _extends({
    ref: ref,
    className: cx("chakra-kbd", className)
  }, rest, {
    __css: {
      fontFamily: "mono",
      ...styles
    }
  }));
});

if (__DEV__) {
  Kbd.displayName = "Kbd";
}

/**
 * Links are accessible elements used primarily for navigation.
 *
 * It integrates well with other routing libraries like
 * React Router, Reach Router and Next.js Link.
 *
 * @example
 *
 * ```jsx
 * <Link as={ReactRouterLink} to="/home">Home</Link>
 * ```
 *
 * @see Docs https://chakra-ui.com/link
 */
const Link = /*#__PURE__*/forwardRef((props, ref) => {
  const styles = useStyleConfig("Link", props);
  const {
    className,
    isExternal,
    ...rest
  } = omitThemingProps(props);
  return /*#__PURE__*/React.createElement(chakra.a, _extends({
    target: isExternal ? "_blank" : undefined,
    rel: isExternal ? "noopener noreferrer" : undefined,
    ref: ref,
    className: cx("chakra-link", className)
  }, rest, {
    __css: styles
  }));
});

if (__DEV__) {
  Link.displayName = "Link";
}

/**
 * List is used to display list items, it renders a `<ul>` by default.
 *
 * @see Docs https://chakra-ui.com/list
 */
const List = /*#__PURE__*/forwardRef((props, ref) => {
  const styles = useMultiStyleConfig("List", props);
  const {
    children,
    styleType = "none",
    stylePosition,
    spacing,
    ...rest
  } = omitThemingProps(props);
  const validChildren = getValidChildren(children);
  const selector = "& > *:not(style) ~ *:not(style)";
  const spacingStyle = spacing ? {
    [selector]: {
      mt: spacing
    }
  } : {};
  return /*#__PURE__*/React.createElement(StylesProvider, {
    value: styles
  }, /*#__PURE__*/React.createElement(chakra.ul, _extends({
    ref: ref,
    listStyleType: styleType,
    listStylePosition: stylePosition
    /**
     * We added this role to fix the Safari accessibility issue with list-style-type: none
     * @see https://www.scottohara.me/blog/2019/01/12/lists-and-safari.html
     */
    ,
    role: "list",
    __css: { ...styles.container,
      ...spacingStyle
    }
  }, rest), validChildren));
});

if (__DEV__) {
  List.displayName = "List";
}

const OrderedList = /*#__PURE__*/forwardRef((props, ref) => {
  const {
    as,
    ...rest
  } = props;
  return /*#__PURE__*/React.createElement(List, _extends({
    ref: ref,
    as: "ol",
    styleType: "decimal",
    marginStart: "1em"
  }, rest));
});

if (__DEV__) {
  OrderedList.displayName = "OrderedList";
}

const UnorderedList = /*#__PURE__*/forwardRef((props, ref) => {
  const {
    as,
    ...rest
  } = props;
  return /*#__PURE__*/React.createElement(List, _extends({
    ref: ref,
    as: "ul",
    styleType: "initial",
    marginStart: "1em"
  }, rest));
});

if (__DEV__) {
  UnorderedList.displayName = "UnorderedList";
}

/**
 * ListItem
 *
 * Used to render a list item
 */
const ListItem = /*#__PURE__*/forwardRef((props, ref) => {
  const styles = useStyles();
  return /*#__PURE__*/React.createElement(chakra.li, _extends({
    ref: ref
  }, props, {
    __css: styles.item
  }));
});

if (__DEV__) {
  ListItem.displayName = "ListItem";
}
/**
 * ListIcon
 *
 * Used to render an icon beside the list item text
 */


const ListIcon = /*#__PURE__*/forwardRef((props, ref) => {
  const styles = useStyles();
  return /*#__PURE__*/React.createElement(Icon, _extends({
    ref: ref,
    role: "presentation"
  }, props, {
    __css: styles.icon
  }));
});

if (__DEV__) {
  ListIcon.displayName = "ListIcon";
}

/**
 * SimpleGrid
 *
 * React component make that providers a simpler interface, and
 * make its easy to create responsive grid layouts.
 *
 * @see Docs https://chakra-ui.com/simplegrid
 */
const SimpleGrid = /*#__PURE__*/forwardRef((props, ref) => {
  const {
    columns,
    spacingX,
    spacingY,
    spacing,
    minChildWidth,
    ...rest
  } = props;
  const templateColumns = minChildWidth ? widthToColumns(minChildWidth) : countToColumns(columns);
  return /*#__PURE__*/React.createElement(Grid, _extends({
    ref: ref,
    gap: spacing,
    columnGap: spacingX,
    rowGap: spacingY,
    templateColumns: templateColumns
  }, rest));
});

if (__DEV__) {
  SimpleGrid.displayName = "SimpleGrid";
}

function toPx(n) {
  return isNumber(n) ? `${n}px` : n;
}

function widthToColumns(width) {
  return mapResponsive(width, value => isNull(value) ? null : `repeat(auto-fit, minmax(${toPx(value)}, 1fr))`);
}

function countToColumns(count) {
  return mapResponsive(count, value => isNull(value) ? null : `repeat(${value}, minmax(0, 1fr))`);
}

/**
 * A flexible flex spacer that expands along the major axis of its containing flex layout.
 * It renders a `div` by default, and takes up any available space.
 *
 * @see Docs https://chakra-ui.com/flex#using-the-spacer
 */
const Spacer = chakra("div", {
  baseStyle: {
    flex: 1,
    justifySelf: "stretch",
    alignSelf: "stretch"
  }
});

if (__DEV__) {
  Spacer.displayName = "Spacer";
}

/**
 * If we ever run into SSR issues with this, check this post to find a fix for it:
 * @see https://medium.com/@emmenko/patching-lobotomized-owl-selector-for-emotion-ssr-5a582a3c424c
 */
const selector = "& > *:not(style) ~ *:not(style)";
function getStackStyles(options) {
  const {
    spacing,
    direction
  } = options;
  const directionStyles = {
    column: {
      marginTop: spacing,
      marginEnd: 0,
      marginBottom: 0,
      marginStart: 0
    },
    row: {
      marginTop: 0,
      marginEnd: 0,
      marginBottom: 0,
      marginStart: spacing
    },
    "column-reverse": {
      marginTop: 0,
      marginEnd: 0,
      marginBottom: spacing,
      marginStart: 0
    },
    "row-reverse": {
      marginTop: 0,
      marginEnd: spacing,
      marginBottom: 0,
      marginStart: 0
    }
  };
  return {
    flexDirection: direction,
    [selector]: mapResponsive(direction, value => directionStyles[value])
  };
}
function getDividerStyles(options) {
  const {
    spacing,
    direction
  } = options;
  const dividerStyles = {
    column: {
      my: spacing,
      mx: 0,
      borderLeftWidth: 0,
      borderBottomWidth: "1px"
    },
    "column-reverse": {
      my: spacing,
      mx: 0,
      borderLeftWidth: 0,
      borderBottomWidth: "1px"
    },
    row: {
      mx: spacing,
      my: 0,
      borderLeftWidth: "1px",
      borderBottomWidth: 0
    },
    "row-reverse": {
      mx: spacing,
      my: 0,
      borderLeftWidth: "1px",
      borderBottomWidth: 0
    }
  };
  return {
    "&": mapResponsive(direction, value => dividerStyles[value])
  };
}

const StackDivider = props => /*#__PURE__*/React.createElement(chakra.div, _extends({
  className: "chakra-stack__divider"
}, props, {
  __css: { ...props["__css"],
    borderWidth: 0,
    alignSelf: "stretch",
    borderColor: "inherit",
    width: "auto",
    height: "auto"
  }
}));
const StackItem = props => /*#__PURE__*/React.createElement(chakra.div, _extends({
  className: "chakra-stack__item"
}, props, {
  __css: {
    display: "inline-block",
    flex: "0 0 auto",
    minWidth: 0,
    ...props["__css"]
  }
}));

/**
 * Stacks help you easily create flexible and automatically distributed layouts
 *
 * You can stack elements in the horizontal or vertical direction,
 * and apply a space or/and divider between each element.
 *
 * It uses `display: flex` internally and renders a `div`.
 *
 * @see Docs https://chakra-ui.com/stack
 *
 */
const Stack = /*#__PURE__*/forwardRef((props, ref) => {
  const {
    isInline,
    direction: directionProp,
    align,
    justify,
    spacing = "0.5rem",
    wrap,
    children,
    divider,
    className,
    shouldWrapChildren,
    ...rest
  } = props;
  const direction = isInline ? "row" : directionProp ?? "column";
  const styles = React.useMemo(() => getStackStyles({
    direction,
    spacing
  }), [direction, spacing]);
  const dividerStyle = React.useMemo(() => getDividerStyles({
    spacing,
    direction
  }), [spacing, direction]);
  const hasDivider = !!divider;
  const shouldUseChildren = !shouldWrapChildren && !hasDivider;
  const validChildren = getValidChildren(children);
  const clones = shouldUseChildren ? validChildren : validChildren.map((child, index) => {
    // Prefer provided child key, fallback to index
    const key = typeof child.key !== "undefined" ? child.key : index;
    const isLast = index + 1 === validChildren.length;
    const wrappedChild = /*#__PURE__*/React.createElement(StackItem, {
      key: key
    }, child);

    const _child = shouldWrapChildren ? wrappedChild : child;

    if (!hasDivider) return _child;
    const clonedDivider = /*#__PURE__*/React.cloneElement(divider, {
      __css: dividerStyle
    });

    const _divider = isLast ? null : clonedDivider;

    return /*#__PURE__*/React.createElement(React.Fragment, {
      key: key
    }, _child, _divider);
  });

  const _className = cx("chakra-stack", className);

  return /*#__PURE__*/React.createElement(chakra.div, _extends({
    ref: ref,
    display: "flex",
    alignItems: align,
    justifyContent: justify,
    flexDirection: styles.flexDirection,
    flexWrap: wrap,
    className: _className,
    __css: hasDivider ? {} : {
      [selector]: styles[selector]
    }
  }, rest), clones);
});

if (__DEV__) {
  Stack.displayName = "Stack";
}
/**
 * A view that arranges its children in a horizontal line.
 */


const HStack = /*#__PURE__*/forwardRef((props, ref) => /*#__PURE__*/React.createElement(Stack, _extends({
  align: "center"
}, props, {
  direction: "row",
  ref: ref
})));

if (__DEV__) {
  HStack.displayName = "HStack";
}
/**
 * A view that arranges its children in a vertical line.
 */


const VStack = /*#__PURE__*/forwardRef((props, ref) => /*#__PURE__*/React.createElement(Stack, _extends({
  align: "center"
}, props, {
  direction: "column",
  ref: ref
})));

if (__DEV__) {
  VStack.displayName = "VStack";
}

/**
 * Used to render texts or paragraphs.
 *
 * @see Docs https://chakra-ui.com/text
 */
const Text = /*#__PURE__*/forwardRef((props, ref) => {
  const styles = useStyleConfig("Text", props);
  const {
    className,
    align,
    decoration,
    casing,
    ...rest
  } = omitThemingProps(props);
  const aliasedProps = filterUndefined({
    textAlign: props.align,
    textDecoration: props.decoration,
    textTransform: props.casing
  });
  return /*#__PURE__*/React.createElement(chakra.p, _extends({
    ref: ref,
    className: cx("chakra-text", props.className)
  }, aliasedProps, rest, {
    __css: styles
  }));
});

if (__DEV__) {
  Text.displayName = "Text";
}

/**
 * Layout component used to stack elements that differ in length
 * and are liable to wrap.
 *
 * Common use cases:
 * - Buttons that appear together at the end of forms
 * - Lists of tags and chips
 *
 * @see Docs https://chakra-ui.com/wrap
 */
const Wrap = /*#__PURE__*/forwardRef((props, ref) => {
  const {
    spacing = "0.5rem",
    children,
    justify,
    direction,
    align,
    className,
    shouldWrapChildren,
    ...rest
  } = props;
  const styles = React.useMemo(() => ({
    "--chakra-wrap-spacing": theme => mapResponsive(spacing, value => tokenToCSSVar("space", value)(theme)),
    "--wrap-spacing": "calc(var(--chakra-wrap-spacing) / 2)",
    display: "flex",
    flexWrap: "wrap",
    justifyContent: justify,
    alignItems: align,
    flexDirection: direction,
    listStyleType: "none",
    padding: "0",
    margin: "calc(var(--wrap-spacing) * -1)",
    "& > *:not(style)": {
      margin: "var(--wrap-spacing)"
    }
  }), [spacing, justify, align, direction]);
  const childrenToRender = shouldWrapChildren ? React.Children.map(children, (child, index) => /*#__PURE__*/React.createElement(WrapItem, {
    key: index
  }, child)) : children;
  return /*#__PURE__*/React.createElement(chakra.div, _extends({
    ref: ref,
    className: cx("chakra-wrap", className)
  }, rest), /*#__PURE__*/React.createElement(chakra.ul, {
    className: "chakra-wrap__list",
    __css: styles
  }, childrenToRender));
});

if (__DEV__) {
  Wrap.displayName = "Wrap";
}

const WrapItem = /*#__PURE__*/forwardRef((props, ref) => {
  const {
    className,
    ...rest
  } = props;
  return /*#__PURE__*/React.createElement(chakra.li, _extends({
    ref: ref,
    __css: {
      display: "flex",
      alignItems: "flex-start"
    },
    className: cx("chakra-wrap__listitem", className)
  }, rest));
});

if (__DEV__) {
  WrapItem.displayName = "WrapItem";
}

const LinkOverlay = /*#__PURE__*/forwardRef((props, ref) => {
  const {
    isExternal,
    target,
    rel,
    className,
    ...rest
  } = props;
  return /*#__PURE__*/React.createElement(chakra.a, _extends({}, rest, {
    ref: ref,
    className: cx("chakra-linkbox__overlay", className),
    rel: isExternal ? "noopener noreferrer" : rel,
    target: isExternal ? "_blank" : target,
    __css: {
      position: "static",
      "&::before": {
        content: "''",
        cursor: "inherit",
        display: "block",
        position: "absolute",
        top: 0,
        left: 0,
        zIndex: 0,
        width: "100%",
        height: "100%"
      }
    }
  }));
});

/**
 * `LinkBox` is used to wrap content areas within a link while ensuring semantic html
 *
 * @see Docs https://chakra-ui.com/docs/navigation/link-overlay
 * @see Resources https://www.sarasoueidan.com/blog/nested-links
 */
const LinkBox = /*#__PURE__*/forwardRef((props, ref) => {
  const {
    className,
    ...rest
  } = props;
  return /*#__PURE__*/React.createElement(chakra.div, _extends({
    ref: ref,
    position: "relative"
  }, rest, {
    className: cx("chakra-linkbox", className),
    __css: {
      /* Elevate the links and abbreviations up */
      "a[href]:not(.chakra-linkbox__overlay), abbr[title]": {
        position: "relative",
        zIndex: 1
      }
    }
  }));
});

export { AbsoluteCenter, AspectRatio, Badge, Box, Center, Circle, Code, Container, Divider, Flex, Grid, GridItem, HStack, Heading, Kbd, Link, LinkBox, LinkOverlay, List, ListIcon, ListItem, OrderedList, SimpleGrid, Spacer, Square, Stack, StackDivider, StackItem, Text, UnorderedList, VStack, Wrap, WrapItem };
